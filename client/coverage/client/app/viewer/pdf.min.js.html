
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for client/app/viewer/pdf.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">client/app/viewer</a> pdf.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/8595</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/3805</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1351</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */
<span class="cstat-no" title="statement not covered" >!function <span class="fstat-no" title="function not covered" >webpackUniversalModuleDefinition(</span>t,e){<span class="cstat-no" title="statement not covered" >"object"==typeof exports&amp;&amp;"object"==typeof module?module.exports=e():"function"==typeof define&amp;&amp;define.amd?define("pdfjs-dist/build/pdf",[],e):"object"==typeof exports?exports["pdfjs-dist/build/pdf"]=e():t["pdfjs-dist/build/pdf"]=t.pdfjsLib=e()}</span>(globalThis,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";var __webpack_modules__=<span class="cstat-no" title="statement not covered" >[,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.VerbosityLevel=e.Util=e.UnknownErrorException=e.UnexpectedResponseException=e.TextRenderingMode=e.RenderingIntentFlag=e.PromiseCapability=e.PermissionFlag=e.PasswordResponses=e.PasswordException=e.PageActionEventType=e.OPS=e.MissingPDFException=e.MAX_IMAGE_SIZE_TO_CACHE=e.LINE_FACTOR=e.LINE_DESCENT_FACTOR=e.InvalidPDFException=e.ImageKind=e.IDENTITY_MATRIX=e.FormatError=e.FeatureTest=e.FONT_IDENTITY_MATRIX=e.DocumentActionEventType=e.CMapCompressionType=e.BaseException=e.BASELINE_FACTOR=e.AnnotationType=e.AnnotationReplyType=e.AnnotationMode=e.AnnotationFlag=e.AnnotationFieldFlag=e.AnnotationEditorType=e.AnnotationEditorPrefix=e.AnnotationEditorParamsType=e.AnnotationBorderStyleType=e.AnnotationActionEventType=e.AbortException=void 0;<span class="cstat-no" title="statement not covered" >e</span>.assert=function <span class="fstat-no" title="function not covered" >assert(</span>t,e){<span class="cstat-no" title="statement not covered" >t||unreachable(e)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.bytesToString=function <span class="fstat-no" title="function not covered" >bytesToString(</span>t){<span class="cstat-no" title="statement not covered" >"object"==typeof t&amp;&amp;void 0!==t?.length||unreachable("Invalid argument for bytesToString");c</span>onst e=<span class="cstat-no" title="statement not covered" >t.length,</span>s=<span class="cstat-no" title="statement not covered" >8192;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;s)<span class="cstat-no" title="statement not covered" >return String.fromCharCode.apply(null,t);c</span></span>onst n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e;i+=s){const a=<span class="cstat-no" title="statement not covered" >Math.min(i+s,e),</span>r=<span class="cstat-no" title="statement not covered" >t.subarray(i,a);<span class="cstat-no" title="statement not covered" ></span>n.push(String.fromCharCode.apply(null,r))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.join("")}</span>;<span class="cstat-no" title="statement not covered" >e</span>.createValidAbsoluteUrl=function <span class="fstat-no" title="function not covered" >createValidAbsoluteUrl(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >if(s&amp;&amp;"string"==typeof t){<span class="cstat-no" title="statement not covered" >if(s.addDefaultProtocol&amp;&amp;t.startsWith("www.")){const e=<span class="cstat-no" title="statement not covered" >t.match(/\./g);<span class="cstat-no" title="statement not covered" ></span>e?.length&gt;=2&amp;&amp;(t=`http://${t}`)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.tryConvertEncoding)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=stringToUTF8String(t)}</span>catch{}}</span></span>c</span>onst n=<span class="cstat-no" title="statement not covered" >e?new URL(t,e):new URL(t);<span class="cstat-no" title="statement not covered" ></span>if(function <span class="fstat-no" title="function not covered" >_isValidProtocol(</span>t){<span class="cstat-no" title="statement not covered" >switch(t?.protocol){case"http:":case"https:":case"ftp:":case"mailto:":case"tel:":<span class="cstat-no" title="statement not covered" >return!0;d</span>efault:<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>(n))<span class="cstat-no" title="statement not covered" >return n}</span></span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn null}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getModificationDate=function <span class="fstat-no" title="function not covered" >getModificationDate(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >new Date)</span>{<span class="cstat-no" title="statement not covered" >return[t.getUTCFullYear().toString(),(t.getUTCMonth()+1).toString().padStart(2,"0"),t.getUTCDate().toString().padStart(2,"0"),t.getUTCHours().toString().padStart(2,"0"),t.getUTCMinutes().toString().padStart(2,"0"),t.getUTCSeconds().toString().padStart(2,"0")].join("")}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getVerbosityLevel=function <span class="fstat-no" title="function not covered" >getVerbosityLevel(</span>){<span class="cstat-no" title="statement not covered" >return n}</span>;<span class="cstat-no" title="statement not covered" >e</span>.info=function <span class="fstat-no" title="function not covered" >info(</span>t){<span class="cstat-no" title="statement not covered" >n&gt;=s.INFOS&amp;&amp;console.log(`Info: ${t}`)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isArrayBuffer=function <span class="fstat-no" title="function not covered" >isArrayBuffer(</span>t){<span class="cstat-no" title="statement not covered" >return"object"==typeof t&amp;&amp;void 0!==t?.byteLength}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isArrayEqual=function <span class="fstat-no" title="function not covered" >isArrayEqual(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.length!==e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++)<span class="cstat-no" title="statement not covered" >if(t[s]!==e[s])<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>;<span class="cstat-no" title="statement not covered" >e</span>.normalizeUnicode=function <span class="fstat-no" title="function not covered" >normalizeUnicode(</span>t){<span class="cstat-no" title="statement not covered" >if(!o){<span class="cstat-no" title="statement not covered" >o=/([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;<span class="cstat-no" title="statement not covered" >l</span>=new Map([["ﬅ","ſt"]])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.replaceAll(o,(<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >e?e.normalize("NFKC"):l.get(s))</span>)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.objectFromMap=function <span class="fstat-no" title="function not covered" >objectFromMap(</span>t){const e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(const[s,n]of t)<span class="cstat-no" title="statement not covered" >e[s]=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>;<span class="cstat-no" title="statement not covered" >e</span>.objectSize=function <span class="fstat-no" title="function not covered" >objectSize(</span>t){<span class="cstat-no" title="statement not covered" >return Object.keys(t).length}</span>;<span class="cstat-no" title="statement not covered" >e</span>.setVerbosityLevel=function <span class="fstat-no" title="function not covered" >setVerbosityLevel(</span>t){<span class="cstat-no" title="statement not covered" >Number.isInteger(t)&amp;&amp;(n=t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.shadow=shadow;<span class="cstat-no" title="statement not covered" >e</span>.string32=function <span class="fstat-no" title="function not covered" >string32(</span>t){<span class="cstat-no" title="statement not covered" >return String.fromCharCode(t&gt;&gt;24&amp;255,t&gt;&gt;16&amp;255,t&gt;&gt;8&amp;255,255&amp;t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.stringToBytes=stringToBytes;<span class="cstat-no" title="statement not covered" >e</span>.stringToPDFString=function <span class="fstat-no" title="function not covered" >stringToPDFString(</span>t){<span class="cstat-no" title="statement not covered" >if(t[0]&gt;="ï"){let e;<span class="cstat-no" title="statement not covered" >"þ"===t[0]&amp;&amp;"ÿ"===t[1]?e="utf-16be":"ÿ"===t[0]&amp;&amp;"þ"===t[1]?e="utf-16le":"ï"===t[0]&amp;&amp;"»"===t[1]&amp;&amp;"¿"===t[2]&amp;&amp;(e="utf-8");<span class="cstat-no" title="statement not covered" >i</span>f(e)<span class="cstat-no" title="statement not covered" >try{const s=<span class="cstat-no" title="statement not covered" >new TextDecoder(e,{fatal:!0}),</span>n=<span class="cstat-no" title="statement not covered" >stringToBytes(t);<span class="cstat-no" title="statement not covered" ></span>return s.decode(n)}</span>catch(t){<span class="cstat-no" title="statement not covered" >warn(`stringToPDFString: "${t}".`)}</span>}</span></span>c</span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++){const n=<span class="cstat-no" title="statement not covered" >r[t.charCodeAt(s)];<span class="cstat-no" title="statement not covered" ></span>e.push(n?String.fromCharCode(n):t.charAt(s))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.join("")}</span>;<span class="cstat-no" title="statement not covered" >e</span>.stringToUTF8String=stringToUTF8String;<span class="cstat-no" title="statement not covered" >e</span>.unreachable=unreachable;<span class="cstat-no" title="statement not covered" >e</span>.utf8StringToString=function <span class="fstat-no" title="function not covered" >utf8StringToString(</span>t){<span class="cstat-no" title="statement not covered" >return unescape(encodeURIComponent(t))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.warn=warn;<span class="cstat-no" title="statement not covered" >e</span>.IDENTITY_MATRIX=[1,0,0,1,0,0];<span class="cstat-no" title="statement not covered" >e</span>.FONT_IDENTITY_MATRIX=[.001,0,0,.001,0,0];<span class="cstat-no" title="statement not covered" >e</span>.MAX_IMAGE_SIZE_TO_CACHE=1e7;<span class="cstat-no" title="statement not covered" >e</span>.LINE_FACTOR=1.35;<span class="cstat-no" title="statement not covered" >e</span>.LINE_DESCENT_FACTOR=.35;<span class="cstat-no" title="statement not covered" >e</span>.BASELINE_FACTOR=.25925925925925924;<span class="cstat-no" title="statement not covered" >e</span>.RenderingIntentFlag={ANY:1,DISPLAY:2,PRINT:4,SAVE:8,ANNOTATIONS_FORMS:16,ANNOTATIONS_STORAGE:32,ANNOTATIONS_DISABLE:64,OPLIST:256};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationMode={DISABLE:0,ENABLE:1,ENABLE_FORMS:2,ENABLE_STORAGE:3};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorPrefix="pdfjs_internal_editor_";<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorType={DISABLE:-1,NONE:0,FREETEXT:3,STAMP:13,INK:15};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorParamsType={FREETEXT_SIZE:1,FREETEXT_COLOR:2,FREETEXT_OPACITY:3,INK_COLOR:11,INK_THICKNESS:12,INK_OPACITY:13};<span class="cstat-no" title="statement not covered" >e</span>.PermissionFlag={PRINT:4,MODIFY_CONTENTS:8,COPY:16,MODIFY_ANNOTATIONS:32,FILL_INTERACTIVE_FORMS:256,COPY_FOR_ACCESSIBILITY:512,ASSEMBLE:1024,PRINT_HIGH_QUALITY:2048};<span class="cstat-no" title="statement not covered" >e</span>.TextRenderingMode={FILL:0,STROKE:1,FILL_STROKE:2,INVISIBLE:3,FILL_ADD_TO_PATH:4,STROKE_ADD_TO_PATH:5,FILL_STROKE_ADD_TO_PATH:6,ADD_TO_PATH:7,FILL_STROKE_MASK:3,ADD_TO_PATH_FLAG:4};<span class="cstat-no" title="statement not covered" >e</span>.ImageKind={GRAYSCALE_1BPP:1,RGB_24BPP:2,RGBA_32BPP:3};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationType={TEXT:1,LINK:2,FREETEXT:3,LINE:4,SQUARE:5,CIRCLE:6,POLYGON:7,POLYLINE:8,HIGHLIGHT:9,UNDERLINE:10,SQUIGGLY:11,STRIKEOUT:12,STAMP:13,CARET:14,INK:15,POPUP:16,FILEATTACHMENT:17,SOUND:18,MOVIE:19,WIDGET:20,SCREEN:21,PRINTERMARK:22,TRAPNET:23,WATERMARK:24,THREED:25,REDACT:26};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationReplyType={GROUP:"Group",REPLY:"R"};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationFlag={INVISIBLE:1,HIDDEN:2,PRINT:4,NOZOOM:8,NOROTATE:16,NOVIEW:32,READONLY:64,LOCKED:128,TOGGLENOVIEW:256,LOCKEDCONTENTS:512};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationFieldFlag={READONLY:1,REQUIRED:2,NOEXPORT:4,MULTILINE:4096,PASSWORD:8192,NOTOGGLETOOFF:16384,RADIO:32768,PUSHBUTTON:65536,COMBO:131072,EDIT:262144,SORT:524288,FILESELECT:1048576,MULTISELECT:2097152,DONOTSPELLCHECK:4194304,DONOTSCROLL:8388608,COMB:16777216,RICHTEXT:33554432,RADIOSINUNISON:33554432,COMMITONSELCHANGE:67108864};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationBorderStyleType={SOLID:1,DASHED:2,BEVELED:3,INSET:4,UNDERLINE:5};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationActionEventType={E:"Mouse Enter",X:"Mouse Exit",D:"Mouse Down",U:"Mouse Up",Fo:"Focus",Bl:"Blur",PO:"PageOpen",PC:"PageClose",PV:"PageVisible",PI:"PageInvisible",K:"Keystroke",F:"Format",V:"Validate",C:"Calculate"};<span class="cstat-no" title="statement not covered" >e</span>.DocumentActionEventType={WC:"WillClose",WS:"WillSave",DS:"DidSave",WP:"WillPrint",DP:"DidPrint"};<span class="cstat-no" title="statement not covered" >e</span>.PageActionEventType={O:"PageOpen",C:"PageClose"};c</span>onst s=<span class="cstat-no" title="statement not covered" >{ERRORS:0,WARNINGS:1,INFOS:5};<span class="cstat-no" title="statement not covered" ></span>e.VerbosityLevel=s;<span class="cstat-no" title="statement not covered" >e</span>.CMapCompressionType={NONE:0,BINARY:1};<span class="cstat-no" title="statement not covered" >e</span>.OPS={dependency:1,setLineWidth:2,setLineCap:3,setLineJoin:4,setMiterLimit:5,setDash:6,setRenderingIntent:7,setFlatness:8,setGState:9,save:10,restore:11,transform:12,moveTo:13,lineTo:14,curveTo:15,curveTo2:16,curveTo3:17,closePath:18,rectangle:19,stroke:20,closeStroke:21,fill:22,eoFill:23,fillStroke:24,eoFillStroke:25,closeFillStroke:26,closeEOFillStroke:27,endPath:28,clip:29,eoClip:30,beginText:31,endText:32,setCharSpacing:33,setWordSpacing:34,setHScale:35,setLeading:36,setFont:37,setTextRenderingMode:38,setTextRise:39,moveText:40,setLeadingMoveText:41,setTextMatrix:42,nextLine:43,showText:44,showSpacedText:45,nextLineShowText:46,nextLineSetSpacingShowText:47,setCharWidth:48,setCharWidthAndBounds:49,setStrokeColorSpace:50,setFillColorSpace:51,setStrokeColor:52,setStrokeColorN:53,setFillColor:54,setFillColorN:55,setStrokeGray:56,setFillGray:57,setStrokeRGBColor:58,setFillRGBColor:59,setStrokeCMYKColor:60,setFillCMYKColor:61,shadingFill:62,beginInlineImage:63,beginImageData:64,endInlineImage:65,paintXObject:66,markPoint:67,markPointProps:68,beginMarkedContent:69,beginMarkedContentProps:70,endMarkedContent:71,beginCompat:72,endCompat:73,paintFormXObjectBegin:74,paintFormXObjectEnd:75,beginGroup:76,endGroup:77,beginAnnotation:80,endAnnotation:81,paintImageMaskXObject:83,paintImageMaskXObjectGroup:84,paintImageXObject:85,paintInlineImageXObject:86,paintInlineImageXObjectGroup:87,paintImageXObjectRepeat:88,paintImageMaskXObjectRepeat:89,paintSolidColorImageMask:90,constructPath:91};<span class="cstat-no" title="statement not covered" >e</span>.PasswordResponses={NEED_PASSWORD:1,INCORRECT_PASSWORD:2};l</span>et n=<span class="cstat-no" title="statement not covered" >s.WARNINGS;</span>function <span class="fstat-no" title="function not covered" >warn(</span>t){<span class="cstat-no" title="statement not covered" >n&gt;=s.WARNINGS&amp;&amp;console.log(`Warning: ${t}`)}</span>function <span class="fstat-no" title="function not covered" >unreachable(</span>t){<span class="cstat-no" title="statement not covered" >throw new Error(t)}</span>function <span class="fstat-no" title="function not covered" >shadow(</span>t,e,s,n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,e,{value:s,enumerable:!n,configurable:!0,writable:!1});<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>const i=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >BaseExceptionClosure(</span>){function <span class="fstat-no" title="function not covered" >BaseException(</span>t,e){<span class="cstat-no" title="statement not covered" >this.constructor===BaseException&amp;&amp;unreachable("Cannot initialize BaseException.");<span class="cstat-no" title="statement not covered" >t</span>his.message=t;<span class="cstat-no" title="statement not covered" >t</span>his.name=e}<span class="cstat-no" title="statement not covered" ></span>BaseException.prototype=new Error;<span class="cstat-no" title="statement not covered" >B</span>aseException.constructor=BaseException;<span class="cstat-no" title="statement not covered" >r</span>eturn BaseException}</span>();<span class="cstat-no" title="statement not covered" ></span>e.BaseException=i;<span class="cstat-no" title="statement not covered" >e</span>.PasswordException=class PasswordException extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,"PasswordException");<span class="cstat-no" title="statement not covered" >t</span>his.code=e}</span>};<span class="cstat-no" title="statement not covered" >e</span>.UnknownErrorException=class UnknownErrorException extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,"UnknownErrorException");<span class="cstat-no" title="statement not covered" >t</span>his.details=e}</span>};<span class="cstat-no" title="statement not covered" >e</span>.InvalidPDFException=class InvalidPDFException extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"InvalidPDFException")}</span>};<span class="cstat-no" title="statement not covered" >e</span>.MissingPDFException=class MissingPDFException extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"MissingPDFException")}</span>};<span class="cstat-no" title="statement not covered" >e</span>.UnexpectedResponseException=class UnexpectedResponseException extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,"UnexpectedResponseException");<span class="cstat-no" title="statement not covered" >t</span>his.status=e}</span>};<span class="cstat-no" title="statement not covered" >e</span>.FormatError=class FormatError extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"FormatError")}</span>};<span class="cstat-no" title="statement not covered" >e</span>.AbortException=class AbortException extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"AbortException")}</span>};f</span>unction <span class="fstat-no" title="function not covered" >stringToBytes(</span>t){<span class="cstat-no" title="statement not covered" >"string"!=typeof t&amp;&amp;unreachable("Invalid argument for stringToBytes");c</span>onst e=<span class="cstat-no" title="statement not covered" >t.length,</span>s=<span class="cstat-no" title="statement not covered" >new Uint8Array(e);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;++n)<span class="cstat-no" title="statement not covered" >s[n]=255&amp;t.charCodeAt(n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="cstat-no" title="statement not covered" ></span>e.FeatureTest=class FeatureTest{<span class="fstat-no" title="function not covered" >st</span>atic get isLittleEndian(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isLittleEndian",function <span class="fstat-no" title="function not covered" >isLittleEndian(</span>){const t=<span class="cstat-no" title="statement not covered" >new Uint8Array(4);<span class="cstat-no" title="statement not covered" ></span>t[0]=1;<span class="cstat-no" title="statement not covered" >r</span>eturn 1===new Uint32Array(t.buffer,0,1)[0]}</span>())}<span class="fstat-no" title="function not covered" ></span>st</span>atic get isEvalSupported(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isEvalSupported",function <span class="fstat-no" title="function not covered" >isEvalSupported(</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >new Function("");<span class="cstat-no" title="statement not covered" >r</span>eturn!0}</span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>())}<span class="fstat-no" title="function not covered" ></span>st</span>atic get isOffscreenCanvasSupported(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isOffscreenCanvasSupported","undefined"!=typeof OffscreenCanvas)}<span class="fstat-no" title="function not covered" ></span>st</span>atic get platform(){<span class="cstat-no" title="statement not covered" >return"undefined"==typeof navigator?shadow(this,"platform",{isWin:!1,isMac:!1}):shadow(this,"platform",{isWin:navigator.platform.includes("Win"),isMac:navigator.platform.includes("Mac")})}</span>};c</span>onst a=<span class="cstat-no" title="statement not covered" >[...Array(256).keys()].map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.toString(16).padStart(2,"0"))</span>);<span class="cstat-no" title="statement not covered" ></span>e.Util=class Util{<span class="fstat-no" title="function not covered" >st</span>atic makeHexColor(t,e,s){<span class="cstat-no" title="statement not covered" >return`#${a[t]}${a[e]}${a[s]}`}<span class="fstat-no" title="function not covered" ></span>st</span>atic scaleMinMax(t,e){let s;<span class="cstat-no" title="statement not covered" >if(t[0]){<span class="cstat-no" title="statement not covered" >if(t[0]&lt;0){<span class="cstat-no" title="statement not covered" >s=e[0];<span class="cstat-no" title="statement not covered" >e</span>[0]=e[1];<span class="cstat-no" title="statement not covered" >e</span>[1]=s}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]*=t[0];<span class="cstat-no" title="statement not covered" >e</span>[1]*=t[0];<span class="cstat-no" title="statement not covered" >i</span>f(t[3]&lt;0){<span class="cstat-no" title="statement not covered" >s=e[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=e[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=s}<span class="cstat-no" title="statement not covered" ></span>e</span>[2]*=t[3];<span class="cstat-no" title="statement not covered" >e</span>[3]*=t[3]}</span>else{<span class="cstat-no" title="statement not covered" >s=e[0];<span class="cstat-no" title="statement not covered" >e</span>[0]=e[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=s;<span class="cstat-no" title="statement not covered" >s</span>=e[1];<span class="cstat-no" title="statement not covered" >e</span>[1]=e[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=s;<span class="cstat-no" title="statement not covered" >i</span>f(t[1]&lt;0){<span class="cstat-no" title="statement not covered" >s=e[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=e[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=s}<span class="cstat-no" title="statement not covered" ></span>e</span>[2]*=t[1];<span class="cstat-no" title="statement not covered" >e</span>[3]*=t[1];<span class="cstat-no" title="statement not covered" >i</span>f(t[2]&lt;0){<span class="cstat-no" title="statement not covered" >s=e[0];<span class="cstat-no" title="statement not covered" >e</span>[0]=e[1];<span class="cstat-no" title="statement not covered" >e</span>[1]=s}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]*=t[2];<span class="cstat-no" title="statement not covered" >e</span>[1]*=t[2]}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]+=t[4];<span class="cstat-no" title="statement not covered" >e</span>[1]+=t[4];<span class="cstat-no" title="statement not covered" >e</span>[2]+=t[5];<span class="cstat-no" title="statement not covered" >e</span>[3]+=t[5]}<span class="fstat-no" title="function not covered" ></span>st</span>atic transform(t,e){<span class="cstat-no" title="statement not covered" >return[t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]]}<span class="fstat-no" title="function not covered" ></span>st</span>atic applyTransform(t,e){<span class="cstat-no" title="statement not covered" >return[t[0]*e[0]+t[1]*e[2]+e[4],t[0]*e[1]+t[1]*e[3]+e[5]]}<span class="fstat-no" title="function not covered" ></span>st</span>atic applyInverseTransform(t,e){const s=<span class="cstat-no" title="statement not covered" >e[0]*e[3]-e[1]*e[2];<span class="cstat-no" title="statement not covered" ></span>return[(t[0]*e[3]-t[1]*e[2]+e[2]*e[5]-e[4]*e[3])/s,(-t[0]*e[1]+t[1]*e[0]+e[4]*e[1]-e[5]*e[0])/s]}<span class="fstat-no" title="function not covered" ></span>st</span>atic getAxialAlignedBoundingBox(t,e){const s=<span class="cstat-no" title="statement not covered" >this.applyTransform(t,e),</span>n=<span class="cstat-no" title="statement not covered" >this.applyTransform(t.slice(2,4),e),</span>i=<span class="cstat-no" title="statement not covered" >this.applyTransform([t[0],t[3]],e),</span>a=<span class="cstat-no" title="statement not covered" >this.applyTransform([t[2],t[1]],e);<span class="cstat-no" title="statement not covered" ></span>return[Math.min(s[0],n[0],i[0],a[0]),Math.min(s[1],n[1],i[1],a[1]),Math.max(s[0],n[0],i[0],a[0]),Math.max(s[1],n[1],i[1],a[1])]}<span class="fstat-no" title="function not covered" ></span>st</span>atic inverseTransform(t){const e=<span class="cstat-no" title="statement not covered" >t[0]*t[3]-t[1]*t[2];<span class="cstat-no" title="statement not covered" ></span>return[t[3]/e,-t[1]/e,-t[2]/e,t[0]/e,(t[2]*t[5]-t[4]*t[3])/e,(t[4]*t[1]-t[5]*t[0])/e]}<span class="fstat-no" title="function not covered" ></span>st</span>atic singularValueDecompose2dScale(t){const e=<span class="cstat-no" title="statement not covered" >[t[0],t[2],t[1],t[3]],</span>s=<span class="cstat-no" title="statement not covered" >t[0]*e[0]+t[1]*e[2],</span>n=<span class="cstat-no" title="statement not covered" >t[0]*e[1]+t[1]*e[3],</span>i=<span class="cstat-no" title="statement not covered" >t[2]*e[0]+t[3]*e[2],</span>a=<span class="cstat-no" title="statement not covered" >t[2]*e[1]+t[3]*e[3],</span>r=<span class="cstat-no" title="statement not covered" >(s+a)/2,</span>o=<span class="cstat-no" title="statement not covered" >Math.sqrt((s+a)**2-4*(s*a-i*n))/2,</span>l=<span class="cstat-no" title="statement not covered" >r+o||1,</span>c=<span class="cstat-no" title="statement not covered" >r-o||1;<span class="cstat-no" title="statement not covered" ></span>return[Math.sqrt(l),Math.sqrt(c)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic normalizeRect(t){const e=<span class="cstat-no" title="statement not covered" >t.slice(0);<span class="cstat-no" title="statement not covered" ></span>if(t[0]&gt;t[2]){<span class="cstat-no" title="statement not covered" >e[0]=t[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=t[0]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t[1]&gt;t[3]){<span class="cstat-no" title="statement not covered" >e[1]=t[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=t[1]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>st</span>atic intersect(t,e){const s=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t[0],t[2]),Math.min(e[0],e[2])),</span>n=<span class="cstat-no" title="statement not covered" >Math.min(Math.max(t[0],t[2]),Math.max(e[0],e[2]));<span class="cstat-no" title="statement not covered" ></span>if(s&gt;n)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t[1],t[3]),Math.min(e[1],e[3])),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(Math.max(t[1],t[3]),Math.max(e[1],e[3]));<span class="cstat-no" title="statement not covered" ></span>return i&gt;a?null:[s,i,n,a]}<span class="fstat-no" title="function not covered" ></span>st</span>atic bezierBoundingBox(t,e,s,n,i,a,r,o){const l=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >[[],[]];</span>let h,d,u,p,g,f,m,b;<span class="cstat-no" title="statement not covered" >for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;2;++c){<span class="cstat-no" title="statement not covered" >if(0===c){<span class="cstat-no" title="statement not covered" >d=6*t-12*s+6*i;<span class="cstat-no" title="statement not covered" >h</span>=-3*t+9*s-9*i+3*r;<span class="cstat-no" title="statement not covered" >u</span>=3*s-3*t}</span>else{<span class="cstat-no" title="statement not covered" >d=6*e-12*n+6*a;<span class="cstat-no" title="statement not covered" >h</span>=-3*e+9*n-9*a+3*o;<span class="cstat-no" title="statement not covered" >u</span>=3*n-3*e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Math.abs(h)&lt;1e-12){<span class="cstat-no" title="statement not covered" >if(Math.abs(d)&lt;1e-12)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span></span>=-u/d;<span class="cstat-no" title="statement not covered" >0</span>&lt;p&amp;&amp;p&lt;1&amp;&amp;l.push(p)}</span>else{<span class="cstat-no" title="statement not covered" >m=d*d-4*u*h;<span class="cstat-no" title="statement not covered" >b</span>=Math.sqrt(m);<span class="cstat-no" title="statement not covered" >i</span>f(!(m&lt;0)){<span class="cstat-no" title="statement not covered" >g=(-d+b)/(2*h);<span class="cstat-no" title="statement not covered" >0</span>&lt;g&amp;&amp;g&lt;1&amp;&amp;l.push(g);<span class="cstat-no" title="statement not covered" >f</span>=(-d-b)/(2*h);<span class="cstat-no" title="statement not covered" >0</span>&lt;f&amp;&amp;f&lt;1&amp;&amp;l.push(f)}</span>}</span>}</span>l</span>et A,_=<span class="cstat-no" title="statement not covered" >l.length;</span>const y=<span class="cstat-no" title="statement not covered" >_;<span class="cstat-no" title="statement not covered" ></span>for(;_--;){<span class="cstat-no" title="statement not covered" >p=l[_];<span class="cstat-no" title="statement not covered" >A</span>=1-p;<span class="cstat-no" title="statement not covered" >c</span>[0][_]=A*A*A*t+3*A*A*p*s+3*A*p*p*i+p*p*p*r;<span class="cstat-no" title="statement not covered" >c</span>[1][_]=A*A*A*e+3*A*A*p*n+3*A*p*p*a+p*p*p*o}<span class="cstat-no" title="statement not covered" ></span>c</span>[0][y]=t;<span class="cstat-no" title="statement not covered" >c</span>[1][y]=e;<span class="cstat-no" title="statement not covered" >c</span>[0][y+1]=r;<span class="cstat-no" title="statement not covered" >c</span>[1][y+1]=o;<span class="cstat-no" title="statement not covered" >c</span>[0].length=c[1].length=y+2;<span class="cstat-no" title="statement not covered" >r</span>eturn[Math.min(...c[0]),Math.min(...c[1]),Math.max(...c[0]),Math.max(...c[1])]}</span>};c</span>onst r=<span class="cstat-no" title="statement not covered" >[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,728,711,710,729,733,731,730,732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8226,8224,8225,8230,8212,8211,402,8260,8249,8250,8722,8240,8222,8220,8221,8216,8217,8218,8482,64257,64258,321,338,352,376,381,305,322,339,353,382,0,8364];</span>function <span class="fstat-no" title="function not covered" >stringToUTF8String(</span>t){<span class="cstat-no" title="statement not covered" >return decodeURIComponent(escape(t))}<span class="cstat-no" title="statement not covered" ></span>e.PromiseCapability=class PromiseCapability{#t=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.promise=new Promise((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.resolve=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#t=!0;<span class="cstat-no" title="statement not covered" >t</span>(e)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.reject=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#t=!0;<span class="cstat-no" title="statement not covered" >e</span>(t)}</span>}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>t settled(){<span class="cstat-no" title="statement not covered" >return this.#t}</span>};l</span>et o=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >null}</span>,<span class="fstat-no" title="function not covered" >(_</span>_unused_webpack_module,exports,__w_pdfjs_require__)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(exports,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>xports.build=exports.RenderTask=exports.PDFWorkerUtil=exports.PDFWorker=exports.PDFPageProxy=exports.PDFDocumentProxy=exports.PDFDocumentLoadingTask=exports.PDFDataRangeTransport=exports.LoopbackPort=exports.DefaultStandardFontDataFactory=exports.DefaultFilterFactory=exports.DefaultCanvasFactory=exports.DefaultCMapReaderFactory=void 0;<span class="cstat-no" title="statement not covered" >e</span>xports.getDocument=getDocument;<span class="cstat-no" title="statement not covered" >e</span>xports.version=void 0;v</span>ar _util=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(1),</span>_annotation_storage=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(3),</span>_display_utils=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(6),</span>_font_loader=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(9),</span>_canvas=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(11),</span>_worker_options=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(14),</span>_is_node=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(10),</span>_message_handler=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(15),</span>_metadata=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(16),</span>_optional_content_config=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(17),</span>_transport_stream=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(18),</span>_xfa_text=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(19);</span>const DEFAULT_RANGE_CHUNK_SIZE=<span class="cstat-no" title="statement not covered" >65536,</span>RENDERING_CANCELLED_TIMEOUT=<span class="cstat-no" title="statement not covered" >100,</span>DELAYED_CLEANUP_TIMEOUT=<span class="cstat-no" title="statement not covered" >5e3,</span>DefaultCanvasFactory=<span class="cstat-no" title="statement not covered" >_is_node.isNodeJS?__w_pdfjs_require__(20).NodeCanvasFactory:_display_utils.DOMCanvasFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultCanvasFactory=DefaultCanvasFactory;c</span>onst DefaultCMapReaderFactory=<span class="cstat-no" title="statement not covered" >_is_node.isNodeJS?__w_pdfjs_require__(20).NodeCMapReaderFactory:_display_utils.DOMCMapReaderFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultCMapReaderFactory=DefaultCMapReaderFactory;c</span>onst DefaultFilterFactory=<span class="cstat-no" title="statement not covered" >_is_node.isNodeJS?__w_pdfjs_require__(20).NodeFilterFactory:_display_utils.DOMFilterFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultFilterFactory=DefaultFilterFactory;c</span>onst DefaultStandardFontDataFactory=<span class="cstat-no" title="statement not covered" >_is_node.isNodeJS?__w_pdfjs_require__(20).NodeStandardFontDataFactory:_display_utils.DOMStandardFontDataFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultStandardFontDataFactory=DefaultStandardFontDataFactory;l</span>et createPDFNetworkStream;<span class="cstat-no" title="statement not covered" >if(_is_node.isNodeJS){const{PDFNodeStream:t}=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(21);<span class="cstat-no" title="statement not covered" ></span>createPDFNetworkStream=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new t(e)}</span></span>else{const{PDFNetworkStream:t}=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(24),</span>{PDFFetchStream:e}=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(25);<span class="cstat-no" title="statement not covered" ></span>createPDFNetworkStream=<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >(0,_display_utils.isValidFetchUrl)(s.url)?new e(s):new t(s)}</span></span>f</span>unction <span class="fstat-no" title="function not covered" >getDocument(</span>t){<span class="cstat-no" title="statement not covered" >"string"==typeof t||t instanceof URL?t={url:t}:(0,_util.isArrayBuffer)(t)&amp;&amp;(t={data:t});<span class="cstat-no" title="statement not covered" >i</span>f("object"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid parameter in getDocument, need parameter object.");<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.url&amp;&amp;!t.data&amp;&amp;!t.range)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid parameter object: need either .data, .range or .url");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >new PDFDocumentLoadingTask,</span>{docId:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >t.url?getUrlProp(t.url):null,</span>i=<span class="cstat-no" title="statement not covered" >t.data?getDataProp(t.data):null,</span>a=<span class="cstat-no" title="statement not covered" >t.httpHeaders||null,</span>r=<span class="cstat-no" title="statement not covered" >!0===t.withCredentials,</span>o=<span class="cstat-no" title="statement not covered" >t.password??null,</span>l=<span class="cstat-no" title="statement not covered" >t.range instanceof PDFDataRangeTransport?t.range:null,</span>c=<span class="cstat-no" title="statement not covered" >Number.isInteger(t.rangeChunkSize)&amp;&amp;t.rangeChunkSize&gt;0?t.rangeChunkSize:DEFAULT_RANGE_CHUNK_SIZE;</span>let h=<span class="cstat-no" title="statement not covered" >t.worker instanceof PDFWorker?t.worker:null;</span>const d=<span class="cstat-no" title="statement not covered" >t.verbosity,</span>u=<span class="cstat-no" title="statement not covered" >"string"!=typeof t.docBaseUrl||(0,_display_utils.isDataScheme)(t.docBaseUrl)?null:t.docBaseUrl,</span>p=<span class="cstat-no" title="statement not covered" >"string"==typeof t.cMapUrl?t.cMapUrl:null,</span>g=<span class="cstat-no" title="statement not covered" >!1!==t.cMapPacked,</span>f=<span class="cstat-no" title="statement not covered" >t.CMapReaderFactory||DefaultCMapReaderFactory,</span>m=<span class="cstat-no" title="statement not covered" >"string"==typeof t.standardFontDataUrl?t.standardFontDataUrl:null,</span>b=<span class="cstat-no" title="statement not covered" >t.StandardFontDataFactory||DefaultStandardFontDataFactory,</span>A=<span class="cstat-no" title="statement not covered" >!0!==t.stopAtErrors,</span>_=<span class="cstat-no" title="statement not covered" >Number.isInteger(t.maxImageSize)&amp;&amp;t.maxImageSize&gt;-1?t.maxImageSize:-1,</span>y=<span class="cstat-no" title="statement not covered" >!1!==t.isEvalSupported,</span>v=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.isOffscreenCanvasSupported?t.isOffscreenCanvasSupported:!_is_node.isNodeJS,</span>S=<span class="cstat-no" title="statement not covered" >Number.isInteger(t.canvasMaxAreaInBytes)?t.canvasMaxAreaInBytes:-1,</span>E=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.disableFontFace?t.disableFontFace:_is_node.isNodeJS,</span>x=<span class="cstat-no" title="statement not covered" >!0===t.fontExtraProperties,</span>C=<span class="cstat-no" title="statement not covered" >!0===t.enableXfa,</span>w=<span class="cstat-no" title="statement not covered" >t.ownerDocument||globalThis.document,</span>T=<span class="cstat-no" title="statement not covered" >!0===t.disableRange,</span>P=<span class="cstat-no" title="statement not covered" >!0===t.disableStream,</span>F=<span class="cstat-no" title="statement not covered" >!0===t.disableAutoFetch,</span>k=<span class="cstat-no" title="statement not covered" >!0===t.pdfBug,</span>M=<span class="cstat-no" title="statement not covered" >l?l.length:t.length??NaN,</span>R=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.useSystemFonts?t.useSystemFonts:!_is_node.isNodeJS&amp;&amp;!E,</span>D=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.useWorkerFetch?t.useWorkerFetch:f===_display_utils.DOMCMapReaderFactory&amp;&amp;b===_display_utils.DOMStandardFontDataFactory&amp;&amp;(0,_display_utils.isValidFetchUrl)(p,document.baseURI)&amp;&amp;(0,_display_utils.isValidFetchUrl)(m,document.baseURI),</span>I=<span class="cstat-no" title="statement not covered" >t.canvasFactory||new DefaultCanvasFactory({ownerDocument:w}),</span>O=<span class="cstat-no" title="statement not covered" >t.filterFactory||new DefaultFilterFactory({docId:s,ownerDocument:w});<span class="cstat-no" title="statement not covered" ></span>(0,_util.setVerbosityLevel)(d);c</span>onst L=<span class="cstat-no" title="statement not covered" >{canvasFactory:I,filterFactory:O};<span class="cstat-no" title="statement not covered" ></span>if(!D){<span class="cstat-no" title="statement not covered" >L.cMapReaderFactory=new f({baseUrl:p,isCompressed:g});<span class="cstat-no" title="statement not covered" >L</span>.standardFontDataFactory=new b({baseUrl:m})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!h){const t=<span class="cstat-no" title="statement not covered" >{verbosity:d,port:_worker_options.GlobalWorkerOptions.workerPort};<span class="cstat-no" title="statement not covered" ></span>h=t.port?PDFWorker.fromPort(t):new PDFWorker(t);<span class="cstat-no" title="statement not covered" >e</span>._worker=h}</span>c</span>onst N=<span class="cstat-no" title="statement not covered" >{docId:s,apiVersion:"3.8.162",data:i,password:o,disableAutoFetch:F,rangeChunkSize:c,length:M,docBaseUrl:u,enableXfa:C,evaluatorOptions:{maxImageSize:_,disableFontFace:E,ignoreErrors:A,isEvalSupported:y,isOffscreenCanvasSupported:v,canvasMaxAreaInBytes:S,fontExtraProperties:x,useSystemFonts:R,cMapUrl:D?p:null,standardFontDataUrl:D?m:null}},</span>B=<span class="cstat-no" title="statement not covered" >{ignoreErrors:A,isEvalSupported:y,disableFontFace:E,fontExtraProperties:x,enableXfa:C,ownerDocument:w,disableAutoFetch:F,pdfBug:k,styleElement:null};<span class="cstat-no" title="statement not covered" ></span>h.promise.then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(e.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Loading aborted");c</span></span>onst t=<span class="cstat-no" title="statement not covered" >_fetchDocument(h,N),</span>o=<span class="cstat-no" title="statement not covered" >new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e;<span class="cstat-no" title="statement not covered" >l?e=new _transport_stream.PDFDataTransportStream({length:M,initialData:l.initialData,progressiveDone:l.progressiveDone,contentDispositionFilename:l.contentDispositionFilename,disableRange:T,disableStream:P},l):i||(e=createPDFNetworkStream({url:n,length:M,httpHeaders:a,withCredentials:r,rangeChunkSize:c,disableRange:T,disableStream:P}));<span class="cstat-no" title="statement not covered" >t</span>(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>return Promise.all([t,o]).then((<span class="fstat-no" title="function not covered" >fu</span>nction([t,n]){<span class="cstat-no" title="statement not covered" >if(e.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Loading aborted");c</span></span>onst i=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler(s,t,h.port),</span>a=<span class="cstat-no" title="statement not covered" >new WorkerTransport(i,e,n,B,L);<span class="cstat-no" title="statement not covered" ></span>e._transport=a;<span class="cstat-no" title="statement not covered" >i</span>.send("Ready",null)}</span>))}</span>)).catch(e._capability.reject);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>async function <span class="fstat-no" title="function not covered" >_fetchDocument(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Worker was destroyed");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >await t.messageHandler.sendWithPromise("GetDocRequest",e,e.data?[e.data.buffer]:null);<span class="cstat-no" title="statement not covered" ></span>if(t.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Worker was destroyed");<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>function <span class="fstat-no" title="function not covered" >getUrlProp(</span>t){<span class="cstat-no" title="statement not covered" >if(t instanceof URL)<span class="cstat-no" title="statement not covered" >return t.href;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return new URL(t,window.location).href}</span>catch{<span class="cstat-no" title="statement not covered" >if(_is_node.isNodeJS&amp;&amp;"string"==typeof t)<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow new Error("Invalid PDF url data: either string or URL-object is expected in the url property.")}</span>function <span class="fstat-no" title="function not covered" >getDataProp(</span>t){<span class="cstat-no" title="statement not covered" >if(_is_node.isNodeJS&amp;&amp;"undefined"!=typeof Buffer&amp;&amp;t instanceof Buffer)<span class="cstat-no" title="statement not covered" >throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof Uint8Array&amp;&amp;t.byteLength===t.buffer.byteLength)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"==typeof t)<span class="cstat-no" title="statement not covered" >return(0,_util.stringToBytes)(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("object"==typeof t&amp;&amp;!isNaN(t?.length)||(0,_util.isArrayBuffer)(t))<span class="cstat-no" title="statement not covered" >return new Uint8Array(t);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.")}</span>class PDFDocumentLoadingTask{static#e=<span class="cstat-no" title="statement not covered" >0;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._capability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._transport=null;<span class="cstat-no" title="statement not covered" >t</span>his._worker=null;<span class="cstat-no" title="statement not covered" >t</span>his.docId="d"+PDFDocumentLoadingTask.#e++;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1;<span class="cstat-no" title="statement not covered" >t</span>his.onPassword=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this._capability.promise}<span class="fstat-no" title="function not covered" ></span>as</span>ync destroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0;<span class="cstat-no" title="statement not covered" >a</span>wait(this._transport?.destroy());<span class="cstat-no" title="statement not covered" >t</span>his._transport=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._worker){<span class="cstat-no" title="statement not covered" >this._worker.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._worker=null}</span>}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFDocumentLoadingTask=PDFDocumentLoadingTask;c</span>lass PDFDataRangeTransport{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >this.length=t;<span class="cstat-no" title="statement not covered" >t</span>his.initialData=e;<span class="cstat-no" title="statement not covered" >t</span>his.progressiveDone=s;<span class="cstat-no" title="statement not covered" >t</span>his.contentDispositionFilename=n;<span class="cstat-no" title="statement not covered" >t</span>his._rangeListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressiveReadListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressiveDoneListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability=new _util.PromiseCapability}<span class="fstat-no" title="function not covered" ></span>ad</span>dRangeListener(t){<span class="cstat-no" title="statement not covered" >this._rangeListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dProgressListener(t){<span class="cstat-no" title="statement not covered" >this._progressListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dProgressiveReadListener(t){<span class="cstat-no" title="statement not covered" >this._progressiveReadListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dProgressiveDoneListener(t){<span class="cstat-no" title="statement not covered" >this._progressiveDoneListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>on</span>DataRange(t,e){<span class="cstat-no" title="statement not covered" >for(const s of this._rangeListeners)<span class="cstat-no" title="statement not covered" >s(t,e)}<span class="fstat-no" title="function not covered" ></span></span>on</span>DataProgress(t,e){<span class="cstat-no" title="statement not covered" >this._readyCapability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const s of this._progressListeners)<span class="cstat-no" title="statement not covered" >s(t,e)}</span></span>))}<span class="fstat-no" title="function not covered" ></span>on</span>DataProgressiveRead(t){<span class="cstat-no" title="statement not covered" >this._readyCapability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of this._progressiveReadListeners)<span class="cstat-no" title="statement not covered" >e(t)}</span></span>))}<span class="fstat-no" title="function not covered" ></span>on</span>DataProgressiveDone(){<span class="cstat-no" title="statement not covered" >this._readyCapability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const t of this._progressiveDoneListeners)<span class="cstat-no" title="statement not covered" >t()}</span></span>))}<span class="fstat-no" title="function not covered" ></span>tr</span>ansportReady(){<span class="cstat-no" title="statement not covered" >this._readyCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>re</span>questDataRange(t,e){<span class="cstat-no" title="statement not covered" >(0,_util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange")}<span class="fstat-no" title="function not covered" ></span>ab</span>ort(){}}<span class="cstat-no" title="statement not covered" >exports.PDFDataRangeTransport=PDFDataRangeTransport;c</span>lass PDFDocumentProxy{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._pdfInfo=t;<span class="cstat-no" title="statement not covered" >t</span>his._transport=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t annotationStorage(){<span class="cstat-no" title="statement not covered" >return this._transport.annotationStorage}<span class="fstat-no" title="function not covered" ></span>ge</span>t filterFactory(){<span class="cstat-no" title="statement not covered" >return this._transport.filterFactory}<span class="fstat-no" title="function not covered" ></span>ge</span>t numPages(){<span class="cstat-no" title="statement not covered" >return this._pdfInfo.numPages}<span class="fstat-no" title="function not covered" ></span>ge</span>t fingerprints(){<span class="cstat-no" title="statement not covered" >return this._pdfInfo.fingerprints}<span class="fstat-no" title="function not covered" ></span>ge</span>t isPureXfa(){<span class="cstat-no" title="statement not covered" >return(0,_util.shadow)(this,"isPureXfa",!!this._transport._htmlForXfa)}<span class="fstat-no" title="function not covered" ></span>ge</span>t allXfaHtml(){<span class="cstat-no" title="statement not covered" >return this._transport._htmlForXfa}<span class="fstat-no" title="function not covered" ></span>ge</span>tPage(t){<span class="cstat-no" title="statement not covered" >return this._transport.getPage(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageIndex(t){<span class="cstat-no" title="statement not covered" >return this._transport.getPageIndex(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestinations(){<span class="cstat-no" title="statement not covered" >return this._transport.getDestinations()}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestination(t){<span class="cstat-no" title="statement not covered" >return this._transport.getDestination(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLabels(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageLabels()}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLayout(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageLayout()}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageMode(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageMode()}<span class="fstat-no" title="function not covered" ></span>ge</span>tViewerPreferences(){<span class="cstat-no" title="statement not covered" >return this._transport.getViewerPreferences()}<span class="fstat-no" title="function not covered" ></span>ge</span>tOpenAction(){<span class="cstat-no" title="statement not covered" >return this._transport.getOpenAction()}<span class="fstat-no" title="function not covered" ></span>ge</span>tAttachments(){<span class="cstat-no" title="statement not covered" >return this._transport.getAttachments()}<span class="fstat-no" title="function not covered" ></span>ge</span>tJavaScript(){<span class="cstat-no" title="statement not covered" >return this._transport.getJavaScript()}<span class="fstat-no" title="function not covered" ></span>ge</span>tJSActions(){<span class="cstat-no" title="statement not covered" >return this._transport.getDocJSActions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tOutline(){<span class="cstat-no" title="statement not covered" >return this._transport.getOutline()}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionalContentConfig(){<span class="cstat-no" title="statement not covered" >return this._transport.getOptionalContentConfig()}<span class="fstat-no" title="function not covered" ></span>ge</span>tPermissions(){<span class="cstat-no" title="statement not covered" >return this._transport.getPermissions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tMetadata(){<span class="cstat-no" title="statement not covered" >return this._transport.getMetadata()}<span class="fstat-no" title="function not covered" ></span>ge</span>tMarkInfo(){<span class="cstat-no" title="statement not covered" >return this._transport.getMarkInfo()}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this._transport.getData()}<span class="fstat-no" title="function not covered" ></span>sa</span>veDocument(){<span class="cstat-no" title="statement not covered" >return this._transport.saveDocument()}<span class="fstat-no" title="function not covered" ></span>ge</span>tDownloadInfo(){<span class="cstat-no" title="statement not covered" >return this._transport.downloadInfoCapability.promise}<span class="fstat-no" title="function not covered" ></span>cl</span>eanup(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return this._transport.startCleanup(t||this.isPureXfa)}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >return this.loadingTask.destroy()}<span class="fstat-no" title="function not covered" ></span>ge</span>t loadingParams(){<span class="cstat-no" title="statement not covered" >return this._transport.loadingParams}<span class="fstat-no" title="function not covered" ></span>ge</span>t loadingTask(){<span class="cstat-no" title="statement not covered" >return this._transport.loadingTask}<span class="fstat-no" title="function not covered" ></span>ge</span>tFieldObjects(){<span class="cstat-no" title="statement not covered" >return this._transport.getFieldObjects()}<span class="fstat-no" title="function not covered" ></span>ha</span>sJSActions(){<span class="cstat-no" title="statement not covered" >return this._transport.hasJSActions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tCalculationOrderIds(){<span class="cstat-no" title="statement not covered" >return this._transport.getCalculationOrderIds()}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFDocumentProxy=PDFDocumentProxy;c</span>lass PDFPageProxy{#s=<span class="cstat-no" title="statement not covered" >null;</span>#n=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,s,n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this._pageIndex=t;<span class="cstat-no" title="statement not covered" >t</span>his._pageInfo=e;<span class="cstat-no" title="statement not covered" >t</span>his._transport=s;<span class="cstat-no" title="statement not covered" >t</span>his._stats=n?new _display_utils.StatTimer:null;<span class="cstat-no" title="statement not covered" >t</span>his._pdfBug=n;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=s.commonObjs;<span class="cstat-no" title="statement not covered" >t</span>his.objs=new PDFObjects;<span class="cstat-no" title="statement not covered" >t</span>his._maybeCleanupAfterRender=!1;<span class="cstat-no" title="statement not covered" >t</span>his._intentStates=new Map;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>t pageNumber(){<span class="cstat-no" title="statement not covered" >return this._pageIndex+1}<span class="fstat-no" title="function not covered" ></span>ge</span>t rotate(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.rotate}<span class="fstat-no" title="function not covered" ></span>ge</span>t ref(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.ref}<span class="fstat-no" title="function not covered" ></span>ge</span>t userUnit(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.userUnit}<span class="fstat-no" title="function not covered" ></span>ge</span>t view(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.view}<span class="fstat-no" title="function not covered" ></span>ge</span>tViewport({scale:t,rotation:e=<span class="branch-0 cbranch-no" title="branch not covered" >this.rotate,</span>offsetX:s=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>offsetY:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dontFlip:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new _display_utils.PageViewport({viewBox:this.view,scale:t,rotation:e,offsetX:s,offsetY:n,dontFlip:i})}<span class="fstat-no" title="function not covered" ></span>ge</span>tAnnotations({intent:t=<span class="branch-0 cbranch-no" title="branch not covered" >"display"}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >this._transport.getRenderingIntent(t);<span class="cstat-no" title="statement not covered" ></span>return this._transport.getAnnotations(this._pageIndex,e.renderingIntent)}<span class="fstat-no" title="function not covered" ></span>ge</span>tJSActions(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageJSActions(this._pageIndex)}<span class="fstat-no" title="function not covered" ></span>ge</span>t filterFactory(){<span class="cstat-no" title="statement not covered" >return this._transport.filterFactory}<span class="fstat-no" title="function not covered" ></span>ge</span>t isPureXfa(){<span class="cstat-no" title="statement not covered" >return(0,_util.shadow)(this,"isPureXfa",!!this._transport._htmlForXfa)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getXfa(){<span class="cstat-no" title="statement not covered" >return this._transport._htmlForXfa?.children[this._pageIndex]||null}<span class="fstat-no" title="function not covered" ></span>re</span>nder({canvasContext:t,viewport:e,intent:s=<span class="branch-0 cbranch-no" title="branch not covered" >"display",</span>annotationMode:n=<span class="branch-0 cbranch-no" title="branch not covered" >_util.AnnotationMode.ENABLE,</span>transform:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>background:a=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>optionalContentConfigPromise:r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>annotationCanvasMap:o=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>pageColors:l=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>printAnnotationStorage:c=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this._stats?.time("Overall");c</span>onst h=<span class="cstat-no" title="statement not covered" >this._transport.getRenderingIntent(s,n,c);<span class="cstat-no" title="statement not covered" ></span>this.#n=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#i();<span class="cstat-no" title="statement not covered" >r</span>||(r=this._transport.getOptionalContentConfig());l</span>et d=<span class="cstat-no" title="statement not covered" >this._intentStates.get(h.cacheKey);<span class="cstat-no" title="statement not covered" ></span>if(!d){<span class="cstat-no" title="statement not covered" >d=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his._intentStates.set(h.cacheKey,d)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.streamReaderCancelTimeout){<span class="cstat-no" title="statement not covered" >clearTimeout(d.streamReaderCancelTimeout);<span class="cstat-no" title="statement not covered" >d</span>.streamReaderCancelTimeout=null}</span>c</span>onst u=<span class="cstat-no" title="statement not covered" >!!(h.renderingIntent&amp;_util.RenderingIntentFlag.PRINT);<span class="cstat-no" title="statement not covered" ></span>if(!d.displayReadyCapability){<span class="cstat-no" title="statement not covered" >d.displayReadyCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >d</span>.operatorList={fnArray:[],argsArray:[],lastChunk:!1,separateAnnots:null};<span class="cstat-no" title="statement not covered" >t</span>his._stats?.time("Page Request");<span class="cstat-no" title="statement not covered" >t</span>his._pumpOperatorList(h)}</span>c</span>onst complete=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >d.renderTasks.delete(p);<span class="cstat-no" title="statement not covered" >(</span>this._maybeCleanupAfterRender||u)&amp;&amp;(this.#n=!0);<span class="cstat-no" title="statement not covered" >t</span>his.#a(!u);<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >p.capability.reject(t);<span class="cstat-no" title="statement not covered" >t</span>his._abortOperatorList({intentState:d,reason:t instanceof Error?t:new Error(t)})}</span>else <span class="cstat-no" title="statement not covered" >p.capability.resolve();<span class="cstat-no" title="statement not covered" >t</span></span>his._stats?.timeEnd("Rendering");<span class="cstat-no" title="statement not covered" >t</span>his._stats?.timeEnd("Overall")}</span>,</span>p=<span class="cstat-no" title="statement not covered" >new InternalRenderTask({callback:complete,params:{canvasContext:t,viewport:e,transform:i,background:a},objs:this.objs,commonObjs:this.commonObjs,annotationCanvasMap:o,operatorList:d.operatorList,pageIndex:this._pageIndex,canvasFactory:this._transport.canvasFactory,filterFactory:this._transport.filterFactory,useRequestAnimationFrame:!u,pdfBug:this._pdfBug,pageColors:l});<span class="cstat-no" title="statement not covered" ></span>(d.renderTasks||=new Set).add(p);c</span>onst g=<span class="cstat-no" title="statement not covered" >p.task;<span class="cstat-no" title="statement not covered" ></span>Promise.all([d.displayReadyCapability.promise,r]).then((<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >complete();e</span>lse{<span class="cstat-no" title="statement not covered" >this._stats?.time("Rendering");<span class="cstat-no" title="statement not covered" >p</span>.initializeGraphics({transparency:t,optionalContentConfig:e});<span class="cstat-no" title="statement not covered" >p</span>.operatorListChanged()}</span>}</span>)).catch(complete);<span class="cstat-no" title="statement not covered" >r</span>eturn g}<span class="fstat-no" title="function not covered" ></span>ge</span>tOperatorList({intent:t=<span class="branch-0 cbranch-no" title="branch not covered" >"display",</span>annotationMode:e=<span class="branch-0 cbranch-no" title="branch not covered" >_util.AnnotationMode.ENABLE,</span>printAnnotationStorage:s=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const n=<span class="cstat-no" title="statement not covered" >this._transport.getRenderingIntent(t,e,s,!0);</span>let i,a=<span class="cstat-no" title="statement not covered" >this._intentStates.get(n.cacheKey);<span class="cstat-no" title="statement not covered" ></span>if(!a){<span class="cstat-no" title="statement not covered" >a=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his._intentStates.set(n.cacheKey,a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!a.opListReadCapability){<span class="cstat-no" title="statement not covered" >i=Object.create(null);<span class="cstat-no" title="statement not covered" >i</span>.operatorListChanged=function <span class="fstat-no" title="function not covered" >operatorListChanged(</span>){<span class="cstat-no" title="statement not covered" >if(a.operatorList.lastChunk){<span class="cstat-no" title="statement not covered" >a.opListReadCapability.resolve(a.operatorList);<span class="cstat-no" title="statement not covered" >a</span>.renderTasks.delete(i)}</span>}</span>;<span class="cstat-no" title="statement not covered" >a</span>.opListReadCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >(</span>a.renderTasks||=new Set).add(i);<span class="cstat-no" title="statement not covered" >a</span>.operatorList={fnArray:[],argsArray:[],lastChunk:!1,separateAnnots:null};<span class="cstat-no" title="statement not covered" >t</span>his._stats?.time("Page Request");<span class="cstat-no" title="statement not covered" >t</span>his._pumpOperatorList(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.opListReadCapability.promise}<span class="fstat-no" title="function not covered" ></span>st</span>reamTextContent({includeMarkedContent:t=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>disableNormalization:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this._transport.messageHandler.sendWithStream("GetTextContent",{pageIndex:this._pageIndex,includeMarkedContent:!0===t,disableNormalization:!0===e},{highWaterMark:100,size:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.items.length}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tTextContent(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(this._transport._htmlForXfa)<span class="cstat-no" title="statement not covered" >return this.getXfa().then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >_xfa_text.XfaText.textContent(t))</span>);c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.streamTextContent(t);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){const n=<span class="cstat-no" title="statement not covered" >e.getReader(),</span>i=<span class="cstat-no" title="statement not covered" >{items:[],styles:Object.create(null)};<span class="cstat-no" title="statement not covered" ></span>!function <span class="fstat-no" title="function not covered" >pump(</span>){<span class="cstat-no" title="statement not covered" >n.read().then((<span class="fstat-no" title="function not covered" >fu</span>nction({value:e,done:s}){<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >t(i);e</span>lse{<span class="cstat-no" title="statement not covered" >Object.assign(i.styles,e.styles);<span class="cstat-no" title="statement not covered" >i</span>.items.push(...e.items);<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>}</span>),s)}</span>()}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>tStructTree(){<span class="cstat-no" title="statement not covered" >return this._transport.getStructTree(this._pageIndex)}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0;c</span>onst t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of this._intentStates.values()){<span class="cstat-no" title="statement not covered" >this._abortOperatorList({intentState:e,reason:new Error("Page was destroyed."),force:!0});<span class="cstat-no" title="statement not covered" >i</span>f(!e.opListReadCapability)<span class="cstat-no" title="statement not covered" >for(const s of e.renderTasks){<span class="cstat-no" title="statement not covered" >t.push(s.completed);<span class="cstat-no" title="statement not covered" >s</span>.cancel()}</span>}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.objs.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#n=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#i();<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.all(t)}<span class="fstat-no" title="function not covered" ></span>cl</span>eanup(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.#n=!0;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.#a(!1);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;e&amp;&amp;(this._stats&amp;&amp;=new _display_utils.StatTimer);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>#a(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.#i();<span class="cstat-no" title="statement not covered" >i</span>f(!this.#n||this.destroyed)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(t){<span class="cstat-no" title="statement not covered" >this.#s=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#s=null;<span class="cstat-no" title="statement not covered" >t</span>his.#a(!1)}</span>),DELAYED_CLEANUP_TIMEOUT);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const{renderTasks:t,operatorList:e}of this._intentStates.values())<span class="cstat-no" title="statement not covered" >if(t.size&gt;0||!e.lastChunk)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span></span>his._intentStates.clear();<span class="cstat-no" title="statement not covered" >t</span>his.objs.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#n=!1;<span class="cstat-no" title="statement not covered" >r</span>eturn!0}</span>#i(){<span class="cstat-no" title="statement not covered" >if(this.#s){<span class="cstat-no" title="statement not covered" >clearTimeout(this.#s);<span class="cstat-no" title="statement not covered" >t</span>his.#s=null}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>tartRenderPage(t,e){const s=<span class="cstat-no" title="statement not covered" >this._intentStates.get(e);<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >this._stats?.timeEnd("Page Request");<span class="cstat-no" title="statement not covered" >s</span>.displayReadyCapability?.resolve(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_r</span>enderPageChunk(t,e){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++){<span class="cstat-no" title="statement not covered" >e.operatorList.fnArray.push(t.fnArray[s]);<span class="cstat-no" title="statement not covered" >e</span>.operatorList.argsArray.push(t.argsArray[s])}<span class="cstat-no" title="statement not covered" ></span>e</span>.operatorList.lastChunk=t.lastChunk;<span class="cstat-no" title="statement not covered" >e</span>.operatorList.separateAnnots=t.separateAnnots;<span class="cstat-no" title="statement not covered" >f</span>or(const t of e.renderTasks)<span class="cstat-no" title="statement not covered" >t.operatorListChanged();<span class="cstat-no" title="statement not covered" >t</span></span>.lastChunk&amp;&amp;this.#a(!0)}<span class="fstat-no" title="function not covered" ></span>_p</span>umpOperatorList({renderingIntent:t,cacheKey:e,annotationStorageSerializable:s}){const{map:n,transfers:i}=<span class="cstat-no" title="statement not covered" >s,</span>a=<span class="cstat-no" title="statement not covered" >this._transport.messageHandler.sendWithStream("GetOperatorList",{pageIndex:this._pageIndex,intent:t,cacheKey:e,annotationStorage:n},i).getReader(),</span>r=<span class="cstat-no" title="statement not covered" >this._intentStates.get(e);<span class="cstat-no" title="statement not covered" ></span>r.streamReader=a;c</span>onst pump=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >a.read().then((<span class="fstat-no" title="function not covered" >({</span>value:t,done:e})=&gt;{<span class="cstat-no" title="statement not covered" >if(e)<span class="cstat-no" title="statement not covered" >r.streamReader=null;e</span>lse <span class="cstat-no" title="statement not covered" >if(!this._transport.destroyed){<span class="cstat-no" title="statement not covered" >this._renderPageChunk(t,r);<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>}</span></span>),(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.streamReader=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this._transport.destroyed){<span class="cstat-no" title="statement not covered" >if(r.operatorList){<span class="cstat-no" title="statement not covered" >r.operatorList.lastChunk=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of r.renderTasks)<span class="cstat-no" title="statement not covered" >t.operatorListChanged();<span class="cstat-no" title="statement not covered" >t</span></span>his.#a(!0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.displayReadyCapability)<span class="cstat-no" title="statement not covered" >r.displayReadyCapability.reject(t);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!r.opListReadCapability)<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >r</span></span>.opListReadCapability.reject(t)}</span>}</span>}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>pump()}<span class="fstat-no" title="function not covered" ></span>_a</span>bortOperatorList({intentState:t,reason:e,force:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){<span class="cstat-no" title="statement not covered" >if(t.streamReader){<span class="cstat-no" title="statement not covered" >if(t.streamReaderCancelTimeout){<span class="cstat-no" title="statement not covered" >clearTimeout(t.streamReaderCancelTimeout);<span class="cstat-no" title="statement not covered" >t</span>.streamReaderCancelTimeout=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!s){<span class="cstat-no" title="statement not covered" >if(t.renderTasks.size&gt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof _display_utils.RenderingCancelledException){let s=<span class="cstat-no" title="statement not covered" >RENDERING_CANCELLED_TIMEOUT;<span class="cstat-no" title="statement not covered" ></span>e.extraDelay&gt;0&amp;&amp;e.extraDelay&lt;1e3&amp;&amp;(s+=e.extraDelay);<span class="cstat-no" title="statement not covered" >t</span>.streamReaderCancelTimeout=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.streamReaderCancelTimeout=null;<span class="cstat-no" title="statement not covered" >t</span>his._abortOperatorList({intentState:t,reason:e,force:!0})}</span>),s);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.streamReader.cancel(new _util.AbortException(e.message)).catch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{}));<span class="cstat-no" title="statement not covered" >t</span>.streamReader=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this._transport.destroyed){<span class="cstat-no" title="statement not covered" >for(const[e,s]of this._intentStates)<span class="cstat-no" title="statement not covered" >if(s===t){<span class="cstat-no" title="statement not covered" >this._intentStates.delete(e);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.cleanup()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t stats(){<span class="cstat-no" title="statement not covered" >return this._stats}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFPageProxy=PDFPageProxy;c</span>lass LoopbackPort{#r=<span class="cstat-no" title="statement not covered" >new Set;</span>#o=<span class="cstat-no" title="statement not covered" >Promise.resolve();<span class="fstat-no" title="function not covered" ></span>po</span>stMessage(t,e){const s=<span class="cstat-no" title="statement not covered" >{data:structuredClone(t,e?{transfer:e}:null)};<span class="cstat-no" title="statement not covered" ></span>this.#o.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const t of this.#r)<span class="cstat-no" title="statement not covered" >t.call(this,s)}</span></span>))}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e){<span class="cstat-no" title="statement not covered" >this.#r.add(e)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(t,e){<span class="cstat-no" title="statement not covered" >this.#r.delete(e)}<span class="fstat-no" title="function not covered" ></span>te</span>rminate(){<span class="cstat-no" title="statement not covered" >this.#r.clear()}</span>}<span class="cstat-no" title="statement not covered" >exports.LoopbackPort=LoopbackPort;c</span>onst PDFWorkerUtil=<span class="cstat-no" title="statement not covered" >{isWorkerDisabled:!1,fallbackWorkerSrc:null,fakeWorkerId:0};<span class="cstat-no" title="statement not covered" ></span>exports.PDFWorkerUtil=PDFWorkerUtil;<span class="cstat-no" title="statement not covered" >i</span>f(_is_node.isNodeJS&amp;&amp;"function"==typeof require){<span class="cstat-no" title="statement not covered" >PDFWorkerUtil.isWorkerDisabled=!0;<span class="cstat-no" title="statement not covered" >P</span>DFWorkerUtil.fallbackWorkerSrc="./pdf.worker.js"}</span>else <span class="cstat-no" title="statement not covered" >if("object"==typeof document){const t=<span class="cstat-no" title="statement not covered" >document?.currentScript?.src;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(PDFWorkerUtil.fallbackWorkerSrc=t.replace(/(\.(?:min\.)?js)(\?.*)?$/i,".worker$1$2"))}<span class="cstat-no" title="statement not covered" ></span>P</span></span>DFWorkerUtil.isSameOrigin=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let s;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >s=new URL(t);<span class="cstat-no" title="statement not covered" >i</span>f(!s.origin||"null"===s.origin)<span class="cstat-no" title="statement not covered" >return!1}</span></span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >new URL(e,s);<span class="cstat-no" title="statement not covered" ></span>return s.origin===n.origin}</span>;<span class="cstat-no" title="statement not covered" >P</span>DFWorkerUtil.createCDNWrapper=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >`importScripts("${t}");`;<span class="cstat-no" title="statement not covered" ></span>return URL.createObjectURL(new Blob([e]))}</span>;c</span>lass PDFWorker{static#l=<span class="cstat-no" title="statement not covered" >new WeakMap;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({name:t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>port:e=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>verbosity:s=<span class="branch-0 cbranch-no" title="branch not covered" >(0,_util.getVerbosityLevel)()}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;PDFWorker.#l.has(e))<span class="cstat-no" title="statement not covered" >throw new Error("Cannot use more than one PDFWorker per port.");<span class="cstat-no" title="statement not covered" >t</span></span>his.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1;<span class="cstat-no" title="statement not covered" >t</span>his.verbosity=s;<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._port=null;<span class="cstat-no" title="statement not covered" >t</span>his._webWorker=null;<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler=null;<span class="cstat-no" title="statement not covered" >i</span>f(e){<span class="cstat-no" title="statement not covered" >PDFWorker.#l.set(e,this);<span class="cstat-no" title="statement not covered" >t</span>his._initializeFromPort(e)}</span>else <span class="cstat-no" title="statement not covered" >this._initialize()}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this._readyCapability.promise}<span class="fstat-no" title="function not covered" ></span>ge</span>t port(){<span class="cstat-no" title="statement not covered" >return this._port}<span class="fstat-no" title="function not covered" ></span>ge</span>t messageHandler(){<span class="cstat-no" title="statement not covered" >return this._messageHandler}<span class="fstat-no" title="function not covered" ></span>_i</span>nitializeFromPort(t){<span class="cstat-no" title="statement not covered" >this._port=t;<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler=new _message_handler.MessageHandler("main","worker",t);<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler.on("ready",(<span class="fstat-no" title="function not covered" >fu</span>nction(){}));<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler.send("configure",{verbosity:this.verbosity})}<span class="fstat-no" title="function not covered" ></span>_i</span>nitialize(){<span class="cstat-no" title="statement not covered" >if(!PDFWorkerUtil.isWorkerDisabled&amp;&amp;!PDFWorker._mainThreadWorkerMessageHandler){let{workerSrc:t}=<span class="cstat-no" title="statement not covered" >PDFWorker;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >PDFWorkerUtil.isSameOrigin(window.location.href,t)||(t=PDFWorkerUtil.createCDNWrapper(new URL(t,window.location).href));c</span>onst e=<span class="cstat-no" title="statement not covered" >new Worker(t),</span>s=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler("main","worker",e),</span>terminateEarly=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >s</span>.destroy();<span class="cstat-no" title="statement not covered" >e</span>.terminate();<span class="cstat-no" title="statement not covered" >t</span>his.destroyed?this._readyCapability.reject(new Error("Worker was destroyed")):this._setupFakeWorker()}</span>,</span>onWorkerError=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._webWorker||terminateEarly()}</span>;<span class="cstat-no" title="statement not covered" ></span>e.addEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >s</span>.on("test",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >i</span>f(this.destroyed)<span class="cstat-no" title="statement not covered" >terminateEarly();e</span>lse <span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >this._messageHandler=s;<span class="cstat-no" title="statement not covered" >t</span>his._port=e;<span class="cstat-no" title="statement not covered" >t</span>his._webWorker=e;<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability.resolve();<span class="cstat-no" title="statement not covered" >s</span>.send("configure",{verbosity:this.verbosity})}</span>else{<span class="cstat-no" title="statement not covered" >this._setupFakeWorker();<span class="cstat-no" title="statement not covered" >s</span>.destroy();<span class="cstat-no" title="statement not covered" >e</span>.terminate()}</span>}</span></span>));<span class="cstat-no" title="statement not covered" >s</span>.on("ready",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >i</span>f(this.destroyed)<span class="cstat-no" title="statement not covered" >terminateEarly();e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >sendTest()}</span>catch{<span class="cstat-no" title="statement not covered" >this._setupFakeWorker()}</span>}</span></span>));c</span>onst sendTest=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >new Uint8Array;<span class="cstat-no" title="statement not covered" ></span>s.send("test",t,[t.buffer])}</span>;<span class="cstat-no" title="statement not covered" ></span>sendTest();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>catch{<span class="cstat-no" title="statement not covered" >(0,_util.info)("The worker has been disabled.")}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setupFakeWorker()}<span class="fstat-no" title="function not covered" ></span>_s</span>etupFakeWorker(){<span class="cstat-no" title="statement not covered" >if(!PDFWorkerUtil.isWorkerDisabled){<span class="cstat-no" title="statement not covered" >(0,_util.warn)("Setting up fake worker.");<span class="cstat-no" title="statement not covered" >P</span>DFWorkerUtil.isWorkerDisabled=!0}<span class="cstat-no" title="statement not covered" ></span>P</span>DFWorker._setupFakeWorkerGlobal.then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed){<span class="cstat-no" title="statement not covered" >this._readyCapability.reject(new Error("Worker was destroyed"));<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >new LoopbackPort;<span class="cstat-no" title="statement not covered" ></span>this._port=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >"fake"+PDFWorkerUtil.fakeWorkerId++,</span>n=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler(s+"_worker",s,e);<span class="cstat-no" title="statement not covered" ></span>t.setup(n,e);c</span>onst i=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler(s,s+"_worker",e);<span class="cstat-no" title="statement not covered" ></span>this._messageHandler=i;<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability.resolve();<span class="cstat-no" title="statement not covered" >i</span>.send("configure",{verbosity:this.verbosity})}</span>)).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t.message}".`))}</span>))}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0;<span class="cstat-no" title="statement not covered" >i</span>f(this._webWorker){<span class="cstat-no" title="statement not covered" >this._webWorker.terminate();<span class="cstat-no" title="statement not covered" >t</span>his._webWorker=null}<span class="cstat-no" title="statement not covered" ></span>P</span>DFWorker.#l.delete(this._port);<span class="cstat-no" title="statement not covered" >t</span>his._port=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._messageHandler){<span class="cstat-no" title="statement not covered" >this._messageHandler.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler=null}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic fromPort(t){<span class="cstat-no" title="statement not covered" >if(!t?.port)<span class="cstat-no" title="statement not covered" >throw new Error("PDFWorker.fromPort - invalid method signature.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.#l.has(t.port)?this.#l.get(t.port):new PDFWorker(t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic get workerSrc(){<span class="cstat-no" title="statement not covered" >if(_worker_options.GlobalWorkerOptions.workerSrc)<span class="cstat-no" title="statement not covered" >return _worker_options.GlobalWorkerOptions.workerSrc;<span class="cstat-no" title="statement not covered" >i</span></span>f(null!==PDFWorkerUtil.fallbackWorkerSrc){<span class="cstat-no" title="statement not covered" >_is_node.isNodeJS||(0,_display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');<span class="cstat-no" title="statement not covered" >r</span>eturn PDFWorkerUtil.fallbackWorkerSrc}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Error('No "GlobalWorkerOptions.workerSrc" specified.')}<span class="fstat-no" title="function not covered" ></span>st</span>atic get _mainThreadWorkerMessageHandler(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return globalThis.pdfjsWorker?.WorkerMessageHandler||null}</span>catch{<span class="cstat-no" title="statement not covered" >return null}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic get _setupFakeWorkerGlobal(){const loader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const mainWorkerMessageHandler=<span class="cstat-no" title="statement not covered" >this._mainThreadWorkerMessageHandler;<span class="cstat-no" title="statement not covered" ></span>if(mainWorkerMessageHandler)<span class="cstat-no" title="statement not covered" >return mainWorkerMessageHandler;<span class="cstat-no" title="statement not covered" >i</span></span>f(_is_node.isNodeJS&amp;&amp;"function"==typeof require){const worker=<span class="cstat-no" title="statement not covered" >eval("require")(this.workerSrc);<span class="cstat-no" title="statement not covered" ></span>return worker.WorkerMessageHandler}<span class="cstat-no" title="statement not covered" ></span>a</span>wait(0,_display_utils.loadScript)(this.workerSrc);<span class="cstat-no" title="statement not covered" >r</span>eturn window.pdfjsWorker.WorkerMessageHandler}</span>;<span class="cstat-no" title="statement not covered" ></span>return(0,_util.shadow)(this,"_setupFakeWorkerGlobal",loader())}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFWorker=PDFWorker;c</span>lass WorkerTransport{#c=<span class="cstat-no" title="statement not covered" >new Map;</span>#h=<span class="cstat-no" title="statement not covered" >new Map;</span>#d=<span class="cstat-no" title="statement not covered" >new Map;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,s,n,i){<span class="cstat-no" title="statement not covered" >this.messageHandler=t;<span class="cstat-no" title="statement not covered" >t</span>his.loadingTask=e;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=new PDFObjects;<span class="cstat-no" title="statement not covered" >t</span>his.fontLoader=new _font_loader.FontLoader({ownerDocument:n.ownerDocument,styleElement:n.styleElement});<span class="cstat-no" title="statement not covered" >t</span>his._params=n;<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory=i.canvasFactory;<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory=i.filterFactory;<span class="cstat-no" title="statement not covered" >t</span>his.cMapReaderFactory=i.cMapReaderFactory;<span class="cstat-no" title="statement not covered" >t</span>his.standardFontDataFactory=i.standardFontDataFactory;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1;<span class="cstat-no" title="statement not covered" >t</span>his.destroyCapability=null;<span class="cstat-no" title="statement not covered" >t</span>his._passwordCapability=null;<span class="cstat-no" title="statement not covered" >t</span>his._networkStream=s;<span class="cstat-no" title="statement not covered" >t</span>his._fullReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastProgress=null;<span class="cstat-no" title="statement not covered" >t</span>his.downloadInfoCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.setupMessageHandler()}</span>#u(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const s=<span class="cstat-no" title="statement not covered" >this.#c.get(t);<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return s;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise(t,e);<span class="cstat-no" title="statement not covered" ></span>this.#c.set(t,n);<span class="cstat-no" title="statement not covered" >r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>t annotationStorage(){<span class="cstat-no" title="statement not covered" >return(0,_util.shadow)(this,"annotationStorage",new _annotation_storage.AnnotationStorage)}<span class="fstat-no" title="function not covered" ></span>ge</span>tRenderingIntent(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >_util.AnnotationMode.ENABLE,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{let i=<span class="cstat-no" title="statement not covered" >_util.RenderingIntentFlag.DISPLAY,</span>a=<span class="cstat-no" title="statement not covered" >_annotation_storage.SerializableEmpty;<span class="cstat-no" title="statement not covered" ></span>switch(t){case"any":<span class="cstat-no" title="statement not covered" >i=_util.RenderingIntentFlag.ANY;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"display":<span class="cstat-no" title="statement not covered" >break;c</span>ase"print":<span class="cstat-no" title="statement not covered" >i=_util.RenderingIntentFlag.PRINT;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,_util.warn)(`getRenderingIntent - invalid intent: ${t}`)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(e){case _util.AnnotationMode.DISABLE:<span class="cstat-no" title="statement not covered" >i+=_util.RenderingIntentFlag.ANNOTATIONS_DISABLE;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase _util.AnnotationMode.ENABLE:<span class="cstat-no" title="statement not covered" >break;c</span>ase _util.AnnotationMode.ENABLE_FORMS:<span class="cstat-no" title="statement not covered" >i+=_util.RenderingIntentFlag.ANNOTATIONS_FORMS;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase _util.AnnotationMode.ENABLE_STORAGE:<span class="cstat-no" title="statement not covered" >i+=_util.RenderingIntentFlag.ANNOTATIONS_STORAGE;<span class="cstat-no" title="statement not covered" >a</span>=(i&amp;_util.RenderingIntentFlag.PRINT&amp;&amp;s instanceof _annotation_storage.PrintAnnotationStorage?s:this.annotationStorage).serializable;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,_util.warn)(`getRenderingIntent - invalid annotationMode: ${e}`)}<span class="cstat-no" title="statement not covered" ></span>n</span>&amp;&amp;(i+=_util.RenderingIntentFlag.OPLIST);<span class="cstat-no" title="statement not covered" >r</span>eturn{renderingIntent:i,cacheKey:`${i}_${a.hash}`,annotationStorageSerializable:a}}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >if(this.destroyCapability)<span class="cstat-no" title="statement not covered" >return this.destroyCapability.promise;<span class="cstat-no" title="statement not covered" >t</span></span>his.destroyed=!0;<span class="cstat-no" title="statement not covered" >t</span>his.destroyCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._passwordCapability&amp;&amp;this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));c</span>onst t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#h.values())<span class="cstat-no" title="statement not covered" >t.push(e._destroy());<span class="cstat-no" title="statement not covered" >t</span></span>his.#h.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#d.clear();<span class="cstat-no" title="statement not covered" >t</span>his.hasOwnProperty("annotationStorage")&amp;&amp;this.annotationStorage.resetModified();c</span>onst e=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise("Terminate",null);<span class="cstat-no" title="statement not covered" ></span>t.push(e);<span class="cstat-no" title="statement not covered" >P</span>romise.all(t).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.commonObjs.clear();<span class="cstat-no" title="statement not covered" >t</span>his.fontLoader.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#c.clear();<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._networkStream&amp;&amp;this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));<span class="cstat-no" title="statement not covered" >i</span>f(this.messageHandler){<span class="cstat-no" title="statement not covered" >this.messageHandler.destroy();<span class="cstat-no" title="statement not covered" >t</span>his.messageHandler=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.destroyCapability.resolve()}</span>),this.destroyCapability.reject);<span class="cstat-no" title="statement not covered" >r</span>eturn this.destroyCapability.promise}<span class="fstat-no" title="function not covered" ></span>se</span>tupMessageHandler(){const{messageHandler:t,loadingTask:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.on("GetReader",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(this._networkStream,"GetReader - no `IPDFStream` instance available.");<span class="cstat-no" title="statement not covered" >t</span>his._fullReader=this._networkStream.getFullReader();<span class="cstat-no" title="statement not covered" >t</span>his._fullReader.onProgress=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._lastProgress={loaded:t.loaded,total:t.total}}</span>;<span class="cstat-no" title="statement not covered" >e</span>.onPull=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._fullReader.read().then((<span class="fstat-no" title="function not covered" >fu</span>nction({value:t,done:s}){<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >e.close();e</span>lse{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(t instanceof ArrayBuffer,"GetReader - expected an ArrayBuffer.");<span class="cstat-no" title="statement not covered" >e</span>.enqueue(new Uint8Array(t),1,[t])}</span>}</span>)).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.error(t)}</span>))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.onCancel=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._fullReader.cancel(t);<span class="cstat-no" title="statement not covered" >e</span>.ready.catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!this.destroyed)<span class="cstat-no" title="statement not covered" >throw t}</span></span>))}</span>}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("ReaderHeadersReady",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >new _util.PromiseCapability,</span>n=<span class="cstat-no" title="statement not covered" >this._fullReader;<span class="cstat-no" title="statement not covered" ></span>n.headersReady.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!n.isStreamingSupported||!n.isRangeSupported){<span class="cstat-no" title="statement not covered" >this._lastProgress&amp;&amp;e.onProgress?.(this._lastProgress);<span class="cstat-no" title="statement not covered" >n</span>.onProgress=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.onProgress?.({loaded:t.loaded,total:t.total})}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>.resolve({isStreamingSupported:n.isStreamingSupported,isRangeSupported:n.isRangeSupported,contentLength:n.contentLength})}</span>),s.reject);<span class="cstat-no" title="statement not covered" >r</span>eturn s.promise}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("GetRangeReader",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(this._networkStream,"GetRangeReader - no `IPDFStream` instance available.");c</span>onst s=<span class="cstat-no" title="statement not covered" >this._networkStream.getRangeReader(t.begin,t.end);<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >e.onPull=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s.read().then((<span class="fstat-no" title="function not covered" >fu</span>nction({value:t,done:s}){<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >e.close();e</span>lse{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(t instanceof ArrayBuffer,"GetRangeReader - expected an ArrayBuffer.");<span class="cstat-no" title="statement not covered" >e</span>.enqueue(new Uint8Array(t),1,[t])}</span>}</span>)).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.error(t)}</span>))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.onCancel=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.cancel(t);<span class="cstat-no" title="statement not covered" >e</span>.ready.catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!this.destroyed)<span class="cstat-no" title="statement not covered" >throw t}</span></span>))}</span>}</span>else <span class="cstat-no" title="statement not covered" >e.close()}</span></span>));<span class="cstat-no" title="statement not covered" >t</span>.on("GetDoc",(<span class="fstat-no" title="function not covered" >({</span>pdfInfo:t})=&gt;{<span class="cstat-no" title="statement not covered" >this._numPages=t.numPages;<span class="cstat-no" title="statement not covered" >t</span>his._htmlForXfa=t.htmlForXfa;<span class="cstat-no" title="statement not covered" >d</span>elete t.htmlForXfa;<span class="cstat-no" title="statement not covered" >e</span>._capability.resolve(new PDFDocumentProxy(t,this))}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("DocException",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){let s;<span class="cstat-no" title="statement not covered" >switch(t.name){case"PasswordException":<span class="cstat-no" title="statement not covered" >s=new _util.PasswordException(t.message,t.code);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidPDFException":<span class="cstat-no" title="statement not covered" >s=new _util.InvalidPDFException(t.message);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MissingPDFException":<span class="cstat-no" title="statement not covered" >s=new _util.MissingPDFException(t.message);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnexpectedResponseException":<span class="cstat-no" title="statement not covered" >s=new _util.UnexpectedResponseException(t.message,t.status);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownErrorException":<span class="cstat-no" title="statement not covered" >s=new _util.UnknownErrorException(t.message,t.details);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,_util.unreachable)("DocException - expected a valid Error.")}<span class="cstat-no" title="statement not covered" ></span>e</span>._capability.reject(s)}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("PasswordRequest",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._passwordCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >i</span>f(e.onPassword){const updatePassword=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t instanceof Error?this._passwordCapability.reject(t):this._passwordCapability.resolve({password:t})}</span>;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >e.onPassword(updatePassword,t.code)}</span>catch(t){<span class="cstat-no" title="statement not covered" >this._passwordCapability.reject(t)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this._passwordCapability.reject(new _util.PasswordException(t.message,t.code));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._passwordCapability.promise}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("DataLoaded",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.onProgress?.({loaded:t.length,total:t.length});<span class="cstat-no" title="statement not covered" >t</span>his.downloadInfoCapability.resolve(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("StartRenderPage",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#h.get(t.pageIndex)._startRenderPage(t.transparency,t.cacheKey)}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("commonobj",(<span class="fstat-no" title="function not covered" >([</span>e,s,n])=&gt;{<span class="cstat-no" title="statement not covered" >if(!this.destroyed&amp;&amp;!this.commonObjs.has(e))<span class="cstat-no" title="statement not covered" >switch(s){case"Font":const i=<span class="cstat-no" title="statement not covered" >this._params;<span class="cstat-no" title="statement not covered" ></span>if("error"in n){const t=<span class="cstat-no" title="statement not covered" >n.error;<span class="cstat-no" title="statement not covered" ></span>(0,_util.warn)(`Error during font loading: ${t}`);<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs.resolve(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >i.pdfBug&amp;&amp;globalThis.FontInspector?.enabled?<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >globalThis.FontInspector.fontAdded(t,e):</span>null,</span>r=<span class="cstat-no" title="statement not covered" >new _font_loader.FontFaceObject(n,{isEvalSupported:i.isEvalSupported,disableFontFace:i.disableFontFace,ignoreErrors:i.ignoreErrors,inspectFont:a});<span class="cstat-no" title="statement not covered" ></span>this.fontLoader.bind(r).catch((<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t.sendWithPromise("FontFallback",{id:e}))</span>).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!i.fontExtraProperties&amp;&amp;r.data&amp;&amp;(r.data=null);<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs.resolve(e,r)}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"FontPath":case"Image":case"Pattern":<span class="cstat-no" title="statement not covered" >this.commonObjs.resolve(e,n);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Got unknown common object type ${s}`)}</span>}</span></span>));<span class="cstat-no" title="statement not covered" >t</span>.on("obj",(<span class="fstat-no" title="function not covered" >([</span>t,e,s,n])=&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.#h.get(e);<span class="cstat-no" title="statement not covered" ></span>if(!i.objs.has(t))<span class="cstat-no" title="statement not covered" >switch(s){case"Image":<span class="cstat-no" title="statement not covered" >i.objs.resolve(t,n);<span class="cstat-no" title="statement not covered" >i</span>f(n){let t;<span class="cstat-no" title="statement not covered" >if(n.bitmap){const{width:e,height:s}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>t=e*s*4}</span>else <span class="cstat-no" title="statement not covered" >t=n.data?.length||0;<span class="cstat-no" title="statement not covered" >t</span></span>&gt;_util.MAX_IMAGE_SIZE_TO_CACHE&amp;&amp;(i._maybeCleanupAfterRender=!0)}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"Pattern":<span class="cstat-no" title="statement not covered" >i.objs.resolve(t,n);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Got unknown object type ${s}`)}</span>}</span></span>));<span class="cstat-no" title="statement not covered" >t</span>.on("DocProgress",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.destroyed||e.onProgress?.({loaded:t.loaded,total:t.total})}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("FetchBuiltInCMap",(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.destroyed?Promise.reject(new Error("Worker was destroyed.")):this.cMapReaderFactory?this.cMapReaderFactory.fetch(t):Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.")))</span>);<span class="cstat-no" title="statement not covered" >t</span>.on("FetchStandardFontData",(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.destroyed?Promise.reject(new Error("Worker was destroyed.")):this.standardFontDataFactory?this.standardFontDataFactory.fetch(t):Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")))</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetData",null)}<span class="fstat-no" title="function not covered" ></span>sa</span>veDocument(){<span class="cstat-no" title="statement not covered" >this.annotationStorage.size&lt;=0&amp;&amp;(0,_util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");c</span>onst{map:t,transfers:e}=<span class="cstat-no" title="statement not covered" >this.annotationStorage.serializable;<span class="cstat-no" title="statement not covered" ></span>return this.messageHandler.sendWithPromise("SaveDocument",{isPureXfa:!!this._htmlForXfa,numPages:this._numPages,annotationStorage:t,filename:this._fullReader?.filename??null},e).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.annotationStorage.resetModified()}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>tPage(t){<span class="cstat-no" title="statement not covered" >if(!Number.isInteger(t)||t&lt;=0||t&gt;this._numPages)<span class="cstat-no" title="statement not covered" >return Promise.reject(new Error("Invalid page request."));c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t-1,</span>s=<span class="cstat-no" title="statement not covered" >this.#d.get(e);<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return s;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise("GetPage",{pageIndex:e}).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Transport destroyed");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new PDFPageProxy(e,t,this,this._params.pdfBug);<span class="cstat-no" title="statement not covered" ></span>this.#h.set(e,s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>));<span class="cstat-no" title="statement not covered" ></span>this.#d.set(e,n);<span class="cstat-no" title="statement not covered" >r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageIndex(t){<span class="cstat-no" title="statement not covered" >return"object"!=typeof t||null===t||!Number.isInteger(t.num)||t.num&lt;0||!Number.isInteger(t.gen)||t.gen&lt;0?Promise.reject(new Error("Invalid pageIndex request.")):this.messageHandler.sendWithPromise("GetPageIndex",{num:t.num,gen:t.gen})}<span class="fstat-no" title="function not covered" ></span>ge</span>tAnnotations(t,e){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetAnnotations",{pageIndex:t,intent:e})}<span class="fstat-no" title="function not covered" ></span>ge</span>tFieldObjects(){<span class="cstat-no" title="statement not covered" >return this.#u("GetFieldObjects")}<span class="fstat-no" title="function not covered" ></span>ha</span>sJSActions(){<span class="cstat-no" title="statement not covered" >return this.#u("HasJSActions")}<span class="fstat-no" title="function not covered" ></span>ge</span>tCalculationOrderIds(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetCalculationOrderIds",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestinations(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetDestinations",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestination(t){<span class="cstat-no" title="statement not covered" >return"string"!=typeof t?Promise.reject(new Error("Invalid destination request.")):this.messageHandler.sendWithPromise("GetDestination",{id:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLabels(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageLabels",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLayout(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageLayout",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageMode(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageMode",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tViewerPreferences(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetViewerPreferences",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tOpenAction(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetOpenAction",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAttachments(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetAttachments",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tJavaScript(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetJavaScript",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDocJSActions(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetDocJSActions",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageJSActions(t){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageJSActions",{pageIndex:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tStructTree(t){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetStructTree",{pageIndex:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tOutline(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetOutline",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionalContentConfig(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetOptionalContentConfig",null).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new _optional_content_config.OptionalContentConfig(t))</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPermissions(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPermissions",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMetadata(){const t=<span class="cstat-no" title="statement not covered" >"GetMetadata",</span>e=<span class="cstat-no" title="statement not covered" >this.#c.get(t);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise(t,null).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{info:t[0],metadata:t[1]?new _metadata.Metadata(t[1]):null,contentDispositionFilename:this._fullReader?.filename??null,contentLength:this._fullReader?.contentLength??null})</span>));<span class="cstat-no" title="statement not covered" ></span>this.#c.set(t,s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tMarkInfo(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetMarkInfo",null)}<span class="fstat-no" title="function not covered" ></span>as</span>ync startCleanup(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!this.destroyed){<span class="cstat-no" title="statement not covered" >await this.messageHandler.sendWithPromise("Cleanup",null);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#h.values()){<span class="cstat-no" title="statement not covered" >if(!t.cleanup())<span class="cstat-no" title="statement not covered" >throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.commonObjs.clear();<span class="cstat-no" title="statement not covered" >t</span>||this.fontLoader.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#c.clear();<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory.destroy(!0)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t loadingParams(){const{disableAutoFetch:t,enableXfa:e}=<span class="cstat-no" title="statement not covered" >this._params;<span class="cstat-no" title="statement not covered" ></span>return(0,_util.shadow)(this,"loadingParams",{disableAutoFetch:t,enableXfa:e})}</span>}class PDFObjects{#p=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>#g(t){const e=<span class="cstat-no" title="statement not covered" >this.#p[t];<span class="cstat-no" title="statement not covered" ></span>return e||(this.#p[t]={capability:new _util.PromiseCapability,data:null})}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(e){const s=<span class="cstat-no" title="statement not covered" >this.#g(t);<span class="cstat-no" title="statement not covered" ></span>s.capability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(s.data))</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn null}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >this.#p[t];<span class="cstat-no" title="statement not covered" ></span>if(!s?.capability.settled)<span class="cstat-no" title="statement not covered" >throw new Error(`Requesting object that isn't resolved yet ${t}.`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.data}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){const e=<span class="cstat-no" title="statement not covered" >this.#p[t];<span class="cstat-no" title="statement not covered" ></span>return e?.capability.settled||!1}<span class="fstat-no" title="function not covered" ></span>re</span>solve(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const s=<span class="cstat-no" title="statement not covered" >this.#g(t);<span class="cstat-no" title="statement not covered" ></span>s.data=e;<span class="cstat-no" title="statement not covered" >s</span>.capability.resolve()}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >for(const t in this.#p){const{data:e}=<span class="cstat-no" title="statement not covered" >this.#p[t];<span class="cstat-no" title="statement not covered" ></span>e?.bitmap?.close()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#p=Object.create(null)}</span>}class RenderTask{#f=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.#f=t;<span class="cstat-no" title="statement not covered" >t</span>his.onContinue=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this.#f.capability.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >this.#f.cancel(null,t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t separateAnnots(){const{separateAnnots:t}=<span class="cstat-no" title="statement not covered" >this.#f.operatorList;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst{annotationCanvasMap:e}=<span class="cstat-no" title="statement not covered" >this.#f;<span class="cstat-no" title="statement not covered" ></span>return t.form||t.canvas&amp;&amp;e?.size&gt;0}</span>}<span class="cstat-no" title="statement not covered" >exports.RenderTask=RenderTask;c</span>lass InternalRenderTask{static#m=<span class="cstat-no" title="statement not covered" >new WeakSet;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({callback:t,params:e,objs:s,commonObjs:n,annotationCanvasMap:i,operatorList:a,pageIndex:r,canvasFactory:o,filterFactory:l,useRequestAnimationFrame:c=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>pdfBug:h=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>pageColors:d=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this.callback=t;<span class="cstat-no" title="statement not covered" >t</span>his.params=e;<span class="cstat-no" title="statement not covered" >t</span>his.objs=s;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=n;<span class="cstat-no" title="statement not covered" >t</span>his.annotationCanvasMap=i;<span class="cstat-no" title="statement not covered" >t</span>his.operatorListIdx=null;<span class="cstat-no" title="statement not covered" >t</span>his.operatorList=a;<span class="cstat-no" title="statement not covered" >t</span>his._pageIndex=r;<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory=o;<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory=l;<span class="cstat-no" title="statement not covered" >t</span>his._pdfBug=h;<span class="cstat-no" title="statement not covered" >t</span>his.pageColors=d;<span class="cstat-no" title="statement not covered" >t</span>his.running=!1;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReadyCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReady=!1;<span class="cstat-no" title="statement not covered" >t</span>his._useRequestAnimationFrame=!0===c&amp;&amp;"undefined"!=typeof window;<span class="cstat-no" title="statement not covered" >t</span>his.cancelled=!1;<span class="cstat-no" title="statement not covered" >t</span>his.capability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.task=new RenderTask(this);<span class="cstat-no" title="statement not covered" >t</span>his._cancelBound=this.cancel.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._continueBound=this._continue.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._scheduleNextBound=this._scheduleNext.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._nextBound=this._next.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._canvas=e.canvasContext.canvas}<span class="fstat-no" title="function not covered" ></span>ge</span>t completed(){<span class="cstat-no" title="statement not covered" >return this.capability.promise.catch((<span class="fstat-no" title="function not covered" >fu</span>nction(){}))}<span class="fstat-no" title="function not covered" ></span>in</span>itializeGraphics({transparency:t=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>optionalContentConfig:e}){<span class="cstat-no" title="statement not covered" >if(this.cancelled)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._canvas){<span class="cstat-no" title="statement not covered" >if(InternalRenderTask.#m.has(this._canvas))<span class="cstat-no" title="statement not covered" >throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");<span class="cstat-no" title="statement not covered" >I</span></span>nternalRenderTask.#m.add(this._canvas)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._pdfBug&amp;&amp;globalThis.StepperManager?.enabled){<span class="cstat-no" title="statement not covered" >this.stepper=globalThis.StepperManager.create(this._pageIndex);<span class="cstat-no" title="statement not covered" >t</span>his.stepper.init(this.operatorList);<span class="cstat-no" title="statement not covered" >t</span>his.stepper.nextBreakPoint=this.stepper.getNextBreakPoint()}</span>c</span>onst{canvasContext:s,viewport:n,transform:i,background:a}=<span class="cstat-no" title="statement not covered" >this.params;<span class="cstat-no" title="statement not covered" ></span>this.gfx=new _canvas.CanvasGraphics(s,this.commonObjs,this.objs,this.canvasFactory,this.filterFactory,{optionalContentConfig:e},this.annotationCanvasMap,this.pageColors);<span class="cstat-no" title="statement not covered" >t</span>his.gfx.beginDrawing({transform:i,viewport:n,transparency:t,background:a});<span class="cstat-no" title="statement not covered" >t</span>his.operatorListIdx=0;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReady=!0;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReadyCallback?.()}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >this.running=!1;<span class="cstat-no" title="statement not covered" >t</span>his.cancelled=!0;<span class="cstat-no" title="statement not covered" >t</span>his.gfx?.endDrawing();<span class="cstat-no" title="statement not covered" >t</span>his._canvas&amp;&amp;InternalRenderTask.#m.delete(this._canvas);<span class="cstat-no" title="statement not covered" >t</span>his.callback(t||new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex+1}`,e))}<span class="fstat-no" title="function not covered" ></span>op</span>eratorListChanged(){<span class="cstat-no" title="statement not covered" >if(this.graphicsReady){<span class="cstat-no" title="statement not covered" >this.stepper?.updateOperatorList(this.operatorList);<span class="cstat-no" title="statement not covered" >t</span>his.running||this._continue()}</span>else <span class="cstat-no" title="statement not covered" >this.graphicsReadyCallback||=this._continueBound}<span class="fstat-no" title="function not covered" ></span></span>_c</span>ontinue(){<span class="cstat-no" title="statement not covered" >this.running=!0;<span class="cstat-no" title="statement not covered" >t</span>his.cancelled||(this.task.onContinue?this.task.onContinue(this._scheduleNextBound):this._scheduleNext())}<span class="fstat-no" title="function not covered" ></span>_s</span>cheduleNext(){<span class="cstat-no" title="statement not covered" >this._useRequestAnimationFrame?window.requestAnimationFrame((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._nextBound().catch(this._cancelBound)}</span>)):Promise.resolve().then(this._nextBound).catch(this._cancelBound)}<span class="fstat-no" title="function not covered" ></span>as</span>ync _next(){<span class="cstat-no" title="statement not covered" >if(!this.cancelled){<span class="cstat-no" title="statement not covered" >this.operatorListIdx=this.gfx.executeOperatorList(this.operatorList,this.operatorListIdx,this._continueBound,this.stepper);<span class="cstat-no" title="statement not covered" >i</span>f(this.operatorListIdx===this.operatorList.argsArray.length){<span class="cstat-no" title="statement not covered" >this.running=!1;<span class="cstat-no" title="statement not covered" >i</span>f(this.operatorList.lastChunk){<span class="cstat-no" title="statement not covered" >this.gfx.endDrawing(this.pageColors);<span class="cstat-no" title="statement not covered" >t</span>his._canvas&amp;&amp;InternalRenderTask.#m.delete(this._canvas);<span class="cstat-no" title="statement not covered" >t</span>his.callback()}</span>}</span>}</span>}</span>}const version=<span class="cstat-no" title="statement not covered" >"3.8.162";<span class="cstat-no" title="statement not covered" ></span>exports.version=version;c</span>onst build=<span class="cstat-no" title="statement not covered" >"2c74323e3";<span class="cstat-no" title="statement not covered" ></span>exports.build=build}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.SerializableEmpty=e.PrintAnnotationStorage=e.AnnotationStorage=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(4),</span>a=<span class="cstat-no" title="statement not covered" >s(8);</span>const r=<span class="cstat-no" title="statement not covered" >Object.freeze({map:null,hash:"",transfers:void 0});<span class="cstat-no" title="statement not covered" ></span>e.SerializableEmpty=r;c</span>lass AnnotationStorage{#b=<span class="cstat-no" title="statement not covered" >!1;</span>#A=<span class="cstat-no" title="statement not covered" >new Map;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.onSetModified=null;<span class="cstat-no" title="statement not covered" >t</span>his.onResetModified=null;<span class="cstat-no" title="statement not covered" >t</span>his.onAnnotationEditor=null}<span class="fstat-no" title="function not covered" ></span>ge</span>tValue(t,e){const s=<span class="cstat-no" title="statement not covered" >this.#A.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===s?e:Object.assign(e,s)}<span class="fstat-no" title="function not covered" ></span>ge</span>tRawValue(t){<span class="cstat-no" title="statement not covered" >return this.#A.get(t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >this.#A.delete(t);<span class="cstat-no" title="statement not covered" >0</span>===this.#A.size&amp;&amp;this.resetModified();<span class="cstat-no" title="statement not covered" >i</span>f("function"==typeof this.onAnnotationEditor){<span class="cstat-no" title="statement not covered" >for(const t of this.#A.values())<span class="cstat-no" title="statement not covered" >if(t instanceof i.AnnotationEditor)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span></span>his.onAnnotationEditor(null)}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tValue(t,e){const s=<span class="cstat-no" title="statement not covered" >this.#A.get(t);</span>let n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==s){<span class="cstat-no" title="statement not covered" >for(const[t,i]of Object.entries(e))<span class="cstat-no" title="statement not covered" >if(s[t]!==i){<span class="cstat-no" title="statement not covered" >n=!0;<span class="cstat-no" title="statement not covered" >s</span>[t]=i}</span>}</span></span>else{<span class="cstat-no" title="statement not covered" >n=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#A.set(t,e)}<span class="cstat-no" title="statement not covered" ></span>n</span>&amp;&amp;this.#_();<span class="cstat-no" title="statement not covered" >e</span> instanceof i.AnnotationEditor&amp;&amp;"function"==typeof this.onAnnotationEditor&amp;&amp;this.onAnnotationEditor(e.constructor._type)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this.#A.has(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAll(){<span class="cstat-no" title="statement not covered" >return this.#A.size&gt;0?(0,n.objectFromMap)(this.#A):null}<span class="fstat-no" title="function not covered" ></span>se</span>tAll(t){<span class="cstat-no" title="statement not covered" >for(const[e,s]of Object.entries(t))<span class="cstat-no" title="statement not covered" >this.setValue(e,s)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t size(){<span class="cstat-no" title="statement not covered" >return this.#A.size}</span>#_(){<span class="cstat-no" title="statement not covered" >if(!this.#b){<span class="cstat-no" title="statement not covered" >this.#b=!0;<span class="cstat-no" title="statement not covered" >"</span>function"==typeof this.onSetModified&amp;&amp;this.onSetModified()}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>setModified(){<span class="cstat-no" title="statement not covered" >if(this.#b){<span class="cstat-no" title="statement not covered" >this.#b=!1;<span class="cstat-no" title="statement not covered" >"</span>function"==typeof this.onResetModified&amp;&amp;this.onResetModified()}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t print(){<span class="cstat-no" title="statement not covered" >return new PrintAnnotationStorage(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t serializable(){<span class="cstat-no" title="statement not covered" >if(0===this.#A.size)<span class="cstat-no" title="statement not covered" >return r;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new Map,</span>e=<span class="cstat-no" title="statement not covered" >new a.MurmurHash3_64,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const[n,a]of this.#A){const r=<span class="cstat-no" title="statement not covered" >a instanceof i.AnnotationEditor?a.serialize():a;<span class="cstat-no" title="statement not covered" ></span>if(r){<span class="cstat-no" title="statement not covered" >t.set(n,r);<span class="cstat-no" title="statement not covered" >e</span>.update(`${n}:${JSON.stringify(r)}`);<span class="cstat-no" title="statement not covered" >r</span>.bitmap&amp;&amp;s.push(r.bitmap)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.size&gt;0?{map:t,hash:e.hexdigest(),transfers:s}:r}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationStorage=AnnotationStorage;c</span>lass PrintAnnotationStorage extends AnnotationStorage{#y;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();c</span>onst{map:e,hash:s,transfers:n}=<span class="cstat-no" title="statement not covered" >t.serializable,</span>i=<span class="cstat-no" title="statement not covered" >structuredClone(e,n?{transfer:n}:null);<span class="cstat-no" title="statement not covered" ></span>this.#y={map:i,hash:s,transfers:n}}<span class="fstat-no" title="function not covered" ></span>ge</span>t print(){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Should not call PrintAnnotationStorage.print")}<span class="fstat-no" title="function not covered" ></span>ge</span>t serializable(){<span class="cstat-no" title="statement not covered" >return this.#y}</span>}<span class="cstat-no" title="statement not covered" >e.PrintAnnotationStorage=PrintAnnotationStorage}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditor=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(5),</span>i=<span class="cstat-no" title="statement not covered" >s(1);</span>class AnnotationEditor{#v=<span class="cstat-no" title="statement not covered" >this.focusin.bind(this);</span>#S=<span class="cstat-no" title="statement not covered" >this.focusout.bind(this);</span>#E=<span class="cstat-no" title="statement not covered" >!1;</span>#x=<span class="cstat-no" title="statement not covered" >!1;</span>#C=<span class="cstat-no" title="statement not covered" >!1;</span>_uiManager=<span class="cstat-no" title="statement not covered" >null;</span>#w=<span class="cstat-no" title="statement not covered" >AnnotationEditor._zIndex++;</span>static _colorManager=<span class="cstat-no" title="statement not covered" >new n.ColorManager;</span>static _zIndex=<span class="cstat-no" title="statement not covered" >1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.constructor===AnnotationEditor&amp;&amp;(0,i.unreachable)("Cannot initialize AnnotationEditor.");<span class="cstat-no" title="statement not covered" >t</span>his.parent=t.parent;<span class="cstat-no" title="statement not covered" >t</span>his.id=t.id;<span class="cstat-no" title="statement not covered" >t</span>his.width=this.height=null;<span class="cstat-no" title="statement not covered" >t</span>his.pageIndex=t.parent.pageIndex;<span class="cstat-no" title="statement not covered" >t</span>his.name=t.name;<span class="cstat-no" title="statement not covered" >t</span>his.div=null;<span class="cstat-no" title="statement not covered" >t</span>his._uiManager=t.uiManager;<span class="cstat-no" title="statement not covered" >t</span>his.annotationElementId=null;c</span>onst{rotation:e,rawDims:{pageWidth:s,pageHeight:n,pageX:a,pageY:r}}=<span class="cstat-no" title="statement not covered" >this.parent.viewport;<span class="cstat-no" title="statement not covered" ></span>this.rotation=e;<span class="cstat-no" title="statement not covered" >t</span>his.pageRotation=(360+e-this._uiManager.viewParameters.rotation)%360;<span class="cstat-no" title="statement not covered" >t</span>his.pageDimensions=[s,n];<span class="cstat-no" title="statement not covered" >t</span>his.pageTranslation=[a,r];c</span>onst[o,l]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.x=t.x/o;<span class="cstat-no" title="statement not covered" >t</span>his.y=t.y/l;<span class="cstat-no" title="statement not covered" >t</span>his.isAttachedToDOM=!1;<span class="cstat-no" title="statement not covered" >t</span>his.deleted=!1}<span class="fstat-no" title="function not covered" ></span>st</span>atic get _defaultLineColor(){<span class="cstat-no" title="statement not covered" >return(0,i.shadow)(this,"_defaultLineColor",this._colorManager.getHexCode("CanvasText"))}<span class="fstat-no" title="function not covered" ></span>st</span>atic deleteAnnotationElement(t){const e=<span class="cstat-no" title="statement not covered" >new FakeEditor({id:t.parent.getNextId(),parent:t.parent,uiManager:t._uiManager});<span class="cstat-no" title="statement not covered" ></span>e.annotationElementId=t.annotationElementId;<span class="cstat-no" title="statement not covered" >e</span>.deleted=!0;<span class="cstat-no" title="statement not covered" >e</span>._uiManager.addToAnnotationStorage(e)}<span class="fstat-no" title="function not covered" ></span>ad</span>dCommands(t){<span class="cstat-no" title="statement not covered" >this._uiManager.addCommands(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t currentLayer(){<span class="cstat-no" title="statement not covered" >return this._uiManager.currentLayer}<span class="fstat-no" title="function not covered" ></span>se</span>tInBackground(){<span class="cstat-no" title="statement not covered" >this.div.style.zIndex=0}<span class="fstat-no" title="function not covered" ></span>se</span>tInForeground(){<span class="cstat-no" title="statement not covered" >this.div.style.zIndex=this.#w}<span class="fstat-no" title="function not covered" ></span>se</span>tParent(t){<span class="cstat-no" title="statement not covered" >if(null!==t){<span class="cstat-no" title="statement not covered" >this.pageIndex=t.pageIndex;<span class="cstat-no" title="statement not covered" >t</span>his.pageDimensions=t.pageDimensions}<span class="cstat-no" title="statement not covered" ></span>t</span>his.parent=t}<span class="fstat-no" title="function not covered" ></span>fo</span>cusin(t){<span class="cstat-no" title="statement not covered" >this.#E?this.#E=!1:this.parent.setSelected(this)}<span class="fstat-no" title="function not covered" ></span>fo</span>cusout(t){<span class="cstat-no" title="statement not covered" >if(!this.isAttachedToDOM)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.relatedTarget;<span class="cstat-no" title="statement not covered" ></span>if(!e?.closest(`#${this.id}`)){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.parent?.isMultipleSelection||this.commitOrRemove()}</span>}<span class="fstat-no" title="function not covered" ></span>co</span>mmitOrRemove(){<span class="cstat-no" title="statement not covered" >this.isEmpty()?this.remove():this.commit()}<span class="fstat-no" title="function not covered" ></span>co</span>mmit(){<span class="cstat-no" title="statement not covered" >this.addToAnnotationStorage()}<span class="fstat-no" title="function not covered" ></span>ad</span>dToAnnotationStorage(){<span class="cstat-no" title="statement not covered" >this._uiManager.addToAnnotationStorage(this)}<span class="fstat-no" title="function not covered" ></span>dr</span>agstart(t){const e=<span class="cstat-no" title="statement not covered" >this.parent.div.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>this.startX=t.clientX-e.x;<span class="cstat-no" title="statement not covered" >t</span>his.startY=t.clientY-e.y;<span class="cstat-no" title="statement not covered" >t</span>.dataTransfer.setData("text/plain",this.id);<span class="cstat-no" title="statement not covered" >t</span>.dataTransfer.effectAllowed="move"}<span class="fstat-no" title="function not covered" ></span>se</span>tAt(t,e,s,n){const[i,a]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>[s,n]=this.screenToPageTranslation(s,n);<span class="cstat-no" title="statement not covered" >t</span>his.x=(t+s)/i;<span class="cstat-no" title="statement not covered" >t</span>his.y=(e+n)/a;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.left=100*this.x+"%";<span class="cstat-no" title="statement not covered" >t</span>his.div.style.top=100*this.y+"%"}<span class="fstat-no" title="function not covered" ></span>tr</span>anslate(t,e){const[s,n]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>[t,e]=this.screenToPageTranslation(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.x+=t/s;<span class="cstat-no" title="statement not covered" >t</span>his.y+=e/n;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.left=100*this.x+"%";<span class="cstat-no" title="statement not covered" >t</span>his.div.style.top=100*this.y+"%"}<span class="fstat-no" title="function not covered" ></span>sc</span>reenToPageTranslation(t,e){<span class="cstat-no" title="statement not covered" >switch(this.parentRotation){case 90:<span class="cstat-no" title="statement not covered" >return[e,-t];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[-t,-e];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[-e,t];d</span>efault:<span class="cstat-no" title="statement not covered" >return[t,e]}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t parentScale(){<span class="cstat-no" title="statement not covered" >return this._uiManager.viewParameters.realScale}<span class="fstat-no" title="function not covered" ></span>ge</span>t parentRotation(){<span class="cstat-no" title="statement not covered" >return(this._uiManager.viewParameters.rotation+this.pageRotation)%360}<span class="fstat-no" title="function not covered" ></span>ge</span>t parentDimensions(){const{realScale:t}=<span class="cstat-no" title="statement not covered" >this._uiManager.viewParameters,</span>[e,s]=<span class="cstat-no" title="statement not covered" >this.pageDimensions;<span class="cstat-no" title="statement not covered" ></span>return[e*t,s*t]}<span class="fstat-no" title="function not covered" ></span>se</span>tDims(t,e){const[s,n]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.div.style.width=100*t/s+"%";<span class="cstat-no" title="statement not covered" >t</span>his.div.style.height=100*e/n+"%"}<span class="fstat-no" title="function not covered" ></span>fi</span>xDims(){const{style:t}=<span class="cstat-no" title="statement not covered" >this.div,</span>{height:e,width:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >s.endsWith("%"),</span>i=<span class="cstat-no" title="statement not covered" >e.endsWith("%");<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst[a,r]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>n||(t.width=100*parseFloat(s)/a+"%");<span class="cstat-no" title="statement not covered" >i</span>||(t.height=100*parseFloat(e)/r+"%")}<span class="fstat-no" title="function not covered" ></span>ge</span>tInitialTranslation(){<span class="cstat-no" title="statement not covered" >return[0,0]}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.div=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("data-editor-rotation",(360-this.rotation)%360);<span class="cstat-no" title="statement not covered" >t</span>his.div.className=this.name;<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("id",this.id);<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("tabIndex",0);<span class="cstat-no" title="statement not covered" >t</span>his.setInForeground();<span class="cstat-no" title="statement not covered" >t</span>his.div.addEventListener("focusin",this.#v);<span class="cstat-no" title="statement not covered" >t</span>his.div.addEventListener("focusout",this.#S);c</span>onst[t,e]=<span class="cstat-no" title="statement not covered" >this.getInitialTranslation();<span class="cstat-no" title="statement not covered" ></span>this.translate(t,e);<span class="cstat-no" title="statement not covered" >(</span>0,n.bindEvents)(this,this.div,["dragstart","pointerdown"]);<span class="cstat-no" title="statement not covered" >r</span>eturn this.div}<span class="fstat-no" title="function not covered" ></span>po</span>interdown(t){const{isMac:e}=<span class="cstat-no" title="statement not covered" >i.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(0!==t.button||t.ctrlKey&amp;&amp;e)<span class="cstat-no" title="statement not covered" >t.preventDefault();e</span>lse{<span class="cstat-no" title="statement not covered" >t.ctrlKey&amp;&amp;!e||t.shiftKey||t.metaKey&amp;&amp;e?this.parent.toggleSelected(this):this.parent.setSelected(this);<span class="cstat-no" title="statement not covered" >t</span>his.#E=!0}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tRect(t,e){const s=<span class="cstat-no" title="statement not covered" >this.parentScale,</span>[n,i]=<span class="cstat-no" title="statement not covered" >this.pageDimensions,</span>[a,r]=<span class="cstat-no" title="statement not covered" >this.pageTranslation,</span>o=<span class="cstat-no" title="statement not covered" >t/s,</span>l=<span class="cstat-no" title="statement not covered" >e/s,</span>c=<span class="cstat-no" title="statement not covered" >this.x*n,</span>h=<span class="cstat-no" title="statement not covered" >this.y*i,</span>d=<span class="cstat-no" title="statement not covered" >this.width*n,</span>u=<span class="cstat-no" title="statement not covered" >this.height*i;<span class="cstat-no" title="statement not covered" ></span>switch(this.rotation){case 0:<span class="cstat-no" title="statement not covered" >return[c+o+a,i-h-l-u+r,c+o+d+a,i-h-l+r];c</span>ase 90:<span class="cstat-no" title="statement not covered" >return[c+l+a,i-h+o+r,c+l+u+a,i-h+o+d+r];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[c-o-d+a,i-h+l+r,c-o+a,i-h+l+u+r];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[c-l-u+a,i-h-o-d+r,c-l+a,i-h-o+r];d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tRectInCurrentCoords(t,e){const[s,n,i,a]=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >i-s,</span>o=<span class="cstat-no" title="statement not covered" >a-n;<span class="cstat-no" title="statement not covered" ></span>switch(this.rotation){case 0:<span class="cstat-no" title="statement not covered" >return[s,e-a,r,o];c</span>ase 90:<span class="cstat-no" title="statement not covered" >return[s,e-n,o,r];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[i,e-n,r,o];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[i,e-a,o,r];d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>ceAdded(){}<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditMode(){<span class="cstat-no" title="statement not covered" >this.#C=!0}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditMode(){<span class="cstat-no" title="statement not covered" >this.#C=!1}<span class="fstat-no" title="function not covered" ></span>is</span>InEditMode(){<span class="cstat-no" title="statement not covered" >return this.#C}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldGetKeyboardEvents(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ne</span>edsToBeRebuilt(){<span class="cstat-no" title="statement not covered" >return this.div&amp;&amp;!this.isAttachedToDOM}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >this.div?.addEventListener("focusin",this.#v);<span class="cstat-no" title="statement not covered" >t</span>his.div?.addEventListener("focusout",this.#S)}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >(0,i.unreachable)("An editor must be serializable")}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,s){const n=<span class="cstat-no" title="statement not covered" >new this.prototype.constructor({parent:e,id:e.getNextId(),uiManager:s});<span class="cstat-no" title="statement not covered" ></span>n.rotation=t.rotation;c</span>onst[i,a]=<span class="cstat-no" title="statement not covered" >n.pageDimensions,</span>[r,o,l,c]=<span class="cstat-no" title="statement not covered" >n.getRectInCurrentCoords(t.rect,a);<span class="cstat-no" title="statement not covered" ></span>n.x=r/i;<span class="cstat-no" title="statement not covered" >n</span>.y=o/a;<span class="cstat-no" title="statement not covered" >n</span>.width=l/i;<span class="cstat-no" title="statement not covered" >n</span>.height=c/a;<span class="cstat-no" title="statement not covered" >r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >this.div.removeEventListener("focusin",this.#v);<span class="cstat-no" title="statement not covered" >t</span>his.div.removeEventListener("focusout",this.#S);<span class="cstat-no" title="statement not covered" >t</span>his.isEmpty()||this.commit();<span class="cstat-no" title="statement not covered" >t</span>his.parent.remove(this)}<span class="fstat-no" title="function not covered" ></span>se</span>lect(){<span class="cstat-no" title="statement not covered" >this.div?.classList.add("selectedEditor")}<span class="fstat-no" title="function not covered" ></span>un</span>select(){<span class="cstat-no" title="statement not covered" >this.div?.classList.remove("selectedEditor")}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){}<span class="fstat-no" title="function not covered" >di</span>sableEditing(){}<span class="fstat-no" title="function not covered" >en</span>ableEditing(){}<span class="fstat-no" title="function not covered" >ge</span>t propertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return{}}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentDiv(){<span class="cstat-no" title="statement not covered" >return this.div}<span class="fstat-no" title="function not covered" ></span>ge</span>t isEditing(){<span class="cstat-no" title="statement not covered" >return this.#x}<span class="fstat-no" title="function not covered" ></span>se</span>t isEditing(t){<span class="cstat-no" title="statement not covered" >this.#x=t;<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >this.parent.setSelected(this);<span class="cstat-no" title="statement not covered" >t</span>his.parent.setActiveEditor(this)}</span>else <span class="cstat-no" title="statement not covered" >this.parent.setActiveEditor(null)}</span></span>}<span class="cstat-no" title="statement not covered" >e.AnnotationEditor=AnnotationEditor;c</span>lass FakeEditor extends AnnotationEditor{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);<span class="cstat-no" title="statement not covered" >t</span>his.annotationElementId=t.annotationElementId;<span class="cstat-no" title="statement not covered" >t</span>his.deleted=!0}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(){<span class="cstat-no" title="statement not covered" >return{id:this.annotationElementId,deleted:!0,pageIndex:this.pageIndex}}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.KeyboardManager=e.CommandManager=e.ColorManager=e.AnnotationEditorUIManager=void 0;<span class="cstat-no" title="statement not covered" >e</span>.bindEvents=function <span class="fstat-no" title="function not covered" >bindEvents(</span>t,e,s){<span class="cstat-no" title="statement not covered" >for(const n of s)<span class="cstat-no" title="statement not covered" >e.addEventListener(n,t[n].bind(t))}</span></span>;<span class="cstat-no" title="statement not covered" >e</span>.opacityToHex=function <span class="fstat-no" title="function not covered" >opacityToHex(</span>t){<span class="cstat-no" title="statement not covered" >return Math.round(Math.min(255,Math.max(1,255*t))).toString(16).padStart(2,"0")}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(6);</span>class IdManager{#T=<span class="cstat-no" title="statement not covered" >0;<span class="fstat-no" title="function not covered" ></span>ge</span>tId(){<span class="cstat-no" title="statement not covered" >return`${n.AnnotationEditorPrefix}${this.#T++}`}</span>}class CommandManager{#P=<span class="cstat-no" title="statement not covered" >[];</span>#F=<span class="cstat-no" title="statement not covered" >!1;</span>#k;#M=<span class="cstat-no" title="statement not covered" >-1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >128)</span>{<span class="cstat-no" title="statement not covered" >this.#k=t}<span class="fstat-no" title="function not covered" ></span>ad</span>d({cmd:t,undo:e,mustExec:s,type:n=<span class="branch-0 cbranch-no" title="branch not covered" >NaN,</span>overwriteIfSameType:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>keepUndo:a=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){<span class="cstat-no" title="statement not covered" >s&amp;&amp;t();<span class="cstat-no" title="statement not covered" >i</span>f(this.#F)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >{cmd:t,undo:e,type:n};<span class="cstat-no" title="statement not covered" ></span>if(-1===this.#M){<span class="cstat-no" title="statement not covered" >this.#P.length&gt;0&amp;&amp;(this.#P.length=0);<span class="cstat-no" title="statement not covered" >t</span>his.#M=0;<span class="cstat-no" title="statement not covered" >t</span>his.#P.push(r);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i&amp;&amp;this.#P[this.#M].type===n){<span class="cstat-no" title="statement not covered" >a&amp;&amp;(r.undo=this.#P[this.#M].undo);<span class="cstat-no" title="statement not covered" >t</span>his.#P[this.#M]=r;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >this.#M+1;<span class="cstat-no" title="statement not covered" ></span>if(o===this.#k)<span class="cstat-no" title="statement not covered" >this.#P.splice(0,1);e</span>lse{<span class="cstat-no" title="statement not covered" >this.#M=o;<span class="cstat-no" title="statement not covered" >o</span>&lt;this.#P.length&amp;&amp;this.#P.splice(o)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#P.push(r)}<span class="fstat-no" title="function not covered" ></span>un</span>do(){<span class="cstat-no" title="statement not covered" >if(-1!==this.#M){<span class="cstat-no" title="statement not covered" >this.#F=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#P[this.#M].undo();<span class="cstat-no" title="statement not covered" >t</span>his.#F=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#M-=1}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>do(){<span class="cstat-no" title="statement not covered" >if(this.#M&lt;this.#P.length-1){<span class="cstat-no" title="statement not covered" >this.#M+=1;<span class="cstat-no" title="statement not covered" >t</span>his.#F=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#P[this.#M].cmd();<span class="cstat-no" title="statement not covered" >t</span>his.#F=!1}</span>}<span class="fstat-no" title="function not covered" ></span>ha</span>sSomethingToUndo(){<span class="cstat-no" title="statement not covered" >return-1!==this.#M}<span class="fstat-no" title="function not covered" ></span>ha</span>sSomethingToRedo(){<span class="cstat-no" title="statement not covered" >return this.#M&lt;this.#P.length-1}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.#P=null}</span>}<span class="cstat-no" title="statement not covered" >e.CommandManager=CommandManager;c</span>lass KeyboardManager{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.buffer=[];<span class="cstat-no" title="statement not covered" >t</span>his.callbacks=new Map;<span class="cstat-no" title="statement not covered" >t</span>his.allKeys=new Set;c</span>onst{isMac:e}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>for(const[s,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1]</span>of t)<span class="cstat-no" title="statement not covered" >for(const t of s){const s=<span class="cstat-no" title="statement not covered" >t.startsWith("mac+");<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;s){<span class="cstat-no" title="statement not covered" >this.callbacks.set(t.slice(4),{callback:n,bubbles:i});<span class="cstat-no" title="statement not covered" >t</span>his.allKeys.add(t.split("+").at(-1))}</span>else <span class="cstat-no" title="statement not covered" >if(!e&amp;&amp;!s){<span class="cstat-no" title="statement not covered" >this.callbacks.set(t,{callback:n,bubbles:i});<span class="cstat-no" title="statement not covered" >t</span>his.allKeys.add(t.split("+").at(-1))}</span>}</span></span>}</span></span>#R(t){<span class="cstat-no" title="statement not covered" >t.altKey&amp;&amp;this.buffer.push("alt");<span class="cstat-no" title="statement not covered" >t</span>.ctrlKey&amp;&amp;this.buffer.push("ctrl");<span class="cstat-no" title="statement not covered" >t</span>.metaKey&amp;&amp;this.buffer.push("meta");<span class="cstat-no" title="statement not covered" >t</span>.shiftKey&amp;&amp;this.buffer.push("shift");<span class="cstat-no" title="statement not covered" >t</span>his.buffer.push(t.key);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.buffer.join("+");<span class="cstat-no" title="statement not covered" ></span>this.buffer.length=0;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>ex</span>ec(t,e){<span class="cstat-no" title="statement not covered" >if(!this.allKeys.has(e.key))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.callbacks.get(this.#R(e));<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{callback:n,bubbles:i}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>n.bind(t)();<span class="cstat-no" title="statement not covered" >i</span>f(!i){<span class="cstat-no" title="statement not covered" >e.stopPropagation();<span class="cstat-no" title="statement not covered" >e</span>.preventDefault()}</span>}</span>}<span class="cstat-no" title="statement not covered" >e.KeyboardManager=KeyboardManager;c</span>lass ColorManager{static _colorsMapping=<span class="cstat-no" title="statement not covered" >new Map([["CanvasText",[0,0,0]],["Canvas",[255,255,255]]]);<span class="fstat-no" title="function not covered" ></span>ge</span>t _colors(){const t=<span class="cstat-no" title="statement not covered" >new Map([["CanvasText",null],["Canvas",null]]);<span class="cstat-no" title="statement not covered" ></span>(0,i.getColorValues)(t);<span class="cstat-no" title="statement not covered" >r</span>eturn(0,n.shadow)(this,"_colors",t)}<span class="fstat-no" title="function not covered" ></span>co</span>nvert(t){const e=<span class="cstat-no" title="statement not covered" >(0,i.getRGB)(t);<span class="cstat-no" title="statement not covered" ></span>if(!window.matchMedia("(forced-colors: active)").matches)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(const[t,s]of this._colors)<span class="cstat-no" title="statement not covered" >if(s.every((<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t===e[s])</span>))<span class="cstat-no" title="statement not covered" >return ColorManager._colorsMapping.get(t);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tHexCode(t){const e=<span class="cstat-no" title="statement not covered" >this._colors.get(t);<span class="cstat-no" title="statement not covered" ></span>return e?n.Util.makeHexColor(...e):t}</span>}<span class="cstat-no" title="statement not covered" >e.ColorManager=ColorManager;c</span>lass AnnotationEditorUIManager{#D=<span class="cstat-no" title="statement not covered" >null;</span>#I=<span class="cstat-no" title="statement not covered" >new Map;</span>#O=<span class="cstat-no" title="statement not covered" >new Map;</span>#L=<span class="cstat-no" title="statement not covered" >null;</span>#N=<span class="cstat-no" title="statement not covered" >new CommandManager;</span>#B=<span class="cstat-no" title="statement not covered" >0;</span>#j=<span class="cstat-no" title="statement not covered" >new Set;</span>#U=<span class="cstat-no" title="statement not covered" >null;</span>#H=<span class="cstat-no" title="statement not covered" >new Set;</span>#q=<span class="cstat-no" title="statement not covered" >null;</span>#W=<span class="cstat-no" title="statement not covered" >new IdManager;</span>#G=<span class="cstat-no" title="statement not covered" >!1;</span>#z=<span class="cstat-no" title="statement not covered" >n.AnnotationEditorType.NONE;</span>#V=<span class="cstat-no" title="statement not covered" >new Set;</span>#X=<span class="cstat-no" title="statement not covered" >this.copy.bind(this);</span>#$=<span class="cstat-no" title="statement not covered" >this.cut.bind(this);</span>#K=<span class="cstat-no" title="statement not covered" >this.paste.bind(this);</span>#Y=<span class="cstat-no" title="statement not covered" >this.keydown.bind(this);</span>#J=<span class="cstat-no" title="statement not covered" >this.onEditingAction.bind(this);</span>#Q=<span class="cstat-no" title="statement not covered" >this.onPageChanging.bind(this);</span>#Z=<span class="cstat-no" title="statement not covered" >this.onScaleChanging.bind(this);</span>#tt=<span class="cstat-no" title="statement not covered" >this.onRotationChanging.bind(this);</span>#et=<span class="cstat-no" title="statement not covered" >{isEditing:!1,isEmpty:!0,hasSomethingToUndo:!1,hasSomethingToRedo:!1,hasSelectedEditor:!1};</span>#st=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>st</span>atic get _keyboardManager(){<span class="cstat-no" title="statement not covered" >return(0,n.shadow)(this,"_keyboardManager",new KeyboardManager([[["ctrl+a","mac+meta+a"],AnnotationEditorUIManager.prototype.selectAll],[["ctrl+z","mac+meta+z"],AnnotationEditorUIManager.prototype.undo],[["ctrl+y","ctrl+shift+Z","mac+meta+shift+Z"],AnnotationEditorUIManager.prototype.redo],[["Backspace","alt+Backspace","ctrl+Backspace","shift+Backspace","mac+Backspace","mac+alt+Backspace","mac+ctrl+Backspace","Delete","ctrl+Delete","shift+Delete"],AnnotationEditorUIManager.prototype.delete],[["Escape","mac+Escape"],AnnotationEditorUIManager.prototype.unselectAll]]))}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >this.#st=t;<span class="cstat-no" title="statement not covered" >t</span>his.#q=e;<span class="cstat-no" title="statement not covered" >t</span>his.#q._on("editingaction",this.#J);<span class="cstat-no" title="statement not covered" >t</span>his.#q._on("pagechanging",this.#Q);<span class="cstat-no" title="statement not covered" >t</span>his.#q._on("scalechanging",this.#Z);<span class="cstat-no" title="statement not covered" >t</span>his.#q._on("rotationchanging",this.#tt);<span class="cstat-no" title="statement not covered" >t</span>his.#L=s;<span class="cstat-no" title="statement not covered" >t</span>his.viewParameters={realScale:i.PixelsPerInch.PDF_TO_CSS_UNITS,rotation:0}}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.#nt();<span class="cstat-no" title="statement not covered" >t</span>his.#q._off("editingaction",this.#J);<span class="cstat-no" title="statement not covered" >t</span>his.#q._off("pagechanging",this.#Q);<span class="cstat-no" title="statement not covered" >t</span>his.#q._off("scalechanging",this.#Z);<span class="cstat-no" title="statement not covered" >t</span>his.#q._off("rotationchanging",this.#tt);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#O.values())<span class="cstat-no" title="statement not covered" >t.destroy();<span class="cstat-no" title="statement not covered" >t</span></span>his.#O.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#I.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#H.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#D=null;<span class="cstat-no" title="statement not covered" >t</span>his.#V.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#N.destroy()}<span class="fstat-no" title="function not covered" ></span>on</span>PageChanging({pageNumber:t}){<span class="cstat-no" title="statement not covered" >this.#B=t-1}<span class="fstat-no" title="function not covered" ></span>fo</span>cusMainContainer(){<span class="cstat-no" title="statement not covered" >this.#st.focus()}<span class="fstat-no" title="function not covered" ></span>ad</span>dShouldRescale(t){<span class="cstat-no" title="statement not covered" >this.#H.add(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveShouldRescale(t){<span class="cstat-no" title="statement not covered" >this.#H.delete(t)}<span class="fstat-no" title="function not covered" ></span>on</span>ScaleChanging({scale:t}){<span class="cstat-no" title="statement not covered" >this.commitOrRemove();<span class="cstat-no" title="statement not covered" >t</span>his.viewParameters.realScale=t*i.PixelsPerInch.PDF_TO_CSS_UNITS;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#H)<span class="cstat-no" title="statement not covered" >t.onScaleChanging()}<span class="fstat-no" title="function not covered" ></span></span>on</span>RotationChanging({pagesRotation:t}){<span class="cstat-no" title="statement not covered" >this.commitOrRemove();<span class="cstat-no" title="statement not covered" >t</span>his.viewParameters.rotation=t}<span class="fstat-no" title="function not covered" ></span>ad</span>dToAnnotationStorage(t){<span class="cstat-no" title="statement not covered" >t.isEmpty()||!this.#L||this.#L.has(t.id)||this.#L.setValue(t.id,t)}</span>#it(){<span class="cstat-no" title="statement not covered" >this.#st.addEventListener("keydown",this.#Y)}</span>#nt(){<span class="cstat-no" title="statement not covered" >this.#st.removeEventListener("keydown",this.#Y)}</span>#at(){<span class="cstat-no" title="statement not covered" >document.addEventListener("copy",this.#X);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener("cut",this.#$);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener("paste",this.#K)}</span>#rt(){<span class="cstat-no" title="statement not covered" >document.removeEventListener("copy",this.#X);<span class="cstat-no" title="statement not covered" >d</span>ocument.removeEventListener("cut",this.#$);<span class="cstat-no" title="statement not covered" >d</span>ocument.removeEventListener("paste",this.#K)}<span class="fstat-no" title="function not covered" ></span>co</span>py(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.#D&amp;&amp;this.#D.commitOrRemove();<span class="cstat-no" title="statement not covered" >i</span>f(!this.hasSelection)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const t of this.#V){const s=<span class="cstat-no" title="statement not covered" >t.serialize(!0);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;e.push(s)}<span class="cstat-no" title="statement not covered" ></span>0</span>!==e.length&amp;&amp;t.clipboardData.setData("application/pdfjs",JSON.stringify(e))}<span class="fstat-no" title="function not covered" ></span>cu</span>t(t){<span class="cstat-no" title="statement not covered" >this.copy(t);<span class="cstat-no" title="statement not covered" >t</span>his.delete()}<span class="fstat-no" title="function not covered" ></span>pa</span>ste(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();l</span>et e=<span class="cstat-no" title="statement not covered" >t.clipboardData.getData("application/pdfjs");<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >e=JSON.parse(e)}</span>catch(t){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`paste: "${t.message}".`);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.unselectAll();c</span>onst s=<span class="cstat-no" title="statement not covered" >this.#O.get(this.#B);<span class="cstat-no" title="statement not covered" ></span>try{const t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const n of e){const e=<span class="cstat-no" title="statement not covered" >s.deserialize(n);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.push(e)}</span>c</span>onst cmd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >this.#ot(e);<span class="cstat-no" title="statement not covered" >t</span></span>his.#lt(t)}</span>,</span>undo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.remove()}</span></span>;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:cmd,undo:undo,mustExec:!0})}</span>catch(t){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`paste: "${t.message}".`)}</span>}<span class="fstat-no" title="function not covered" ></span>ke</span>ydown(t){<span class="cstat-no" title="statement not covered" >this.getActive()?.shouldGetKeyboardEvents()||AnnotationEditorUIManager._keyboardManager.exec(this,t)}<span class="fstat-no" title="function not covered" ></span>on</span>EditingAction(t){<span class="cstat-no" title="statement not covered" >["undo","redo","delete","selectAll"].includes(t.name)&amp;&amp;this[t.name]()}</span>#ct(t){<span class="cstat-no" title="statement not covered" >Object.entries(t).some((<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >this.#et[t]!==e)</span>)&amp;&amp;this.#q.dispatch("annotationeditorstateschanged",{source:this,details:Object.assign(this.#et,t)})}</span>#ht(t){<span class="cstat-no" title="statement not covered" >this.#q.dispatch("annotationeditorparamschanged",{source:this,details:t})}<span class="fstat-no" title="function not covered" ></span>se</span>tEditingState(t){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >this.#it();<span class="cstat-no" title="statement not covered" >t</span>his.#at();<span class="cstat-no" title="statement not covered" >t</span>his.#ct({isEditing:this.#z!==n.AnnotationEditorType.NONE,isEmpty:this.#dt(),hasSomethingToUndo:this.#N.hasSomethingToUndo(),hasSomethingToRedo:this.#N.hasSomethingToRedo(),hasSelectedEditor:!1})}</span>else{<span class="cstat-no" title="statement not covered" >this.#nt();<span class="cstat-no" title="statement not covered" >t</span>his.#rt();<span class="cstat-no" title="statement not covered" >t</span>his.#ct({isEditing:!1})}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>gisterEditorTypes(t){<span class="cstat-no" title="statement not covered" >if(!this.#U){<span class="cstat-no" title="statement not covered" >this.#U=t;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#U)<span class="cstat-no" title="statement not covered" >this.#ht(t.defaultPropertiesToUpdate)}</span></span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tId(){<span class="cstat-no" title="statement not covered" >return this.#W.getId()}<span class="fstat-no" title="function not covered" ></span>ge</span>t currentLayer(){<span class="cstat-no" title="statement not covered" >return this.#O.get(this.#B)}<span class="fstat-no" title="function not covered" ></span>ge</span>t currentPageIndex(){<span class="cstat-no" title="statement not covered" >return this.#B}<span class="fstat-no" title="function not covered" ></span>ad</span>dLayer(t){<span class="cstat-no" title="statement not covered" >this.#O.set(t.pageIndex,t);<span class="cstat-no" title="statement not covered" >t</span>his.#G?t.enable():t.disable()}<span class="fstat-no" title="function not covered" ></span>re</span>moveLayer(t){<span class="cstat-no" title="statement not covered" >this.#O.delete(t.pageIndex)}<span class="fstat-no" title="function not covered" ></span>up</span>dateMode(t){<span class="cstat-no" title="statement not covered" >this.#z=t;<span class="cstat-no" title="statement not covered" >i</span>f(t===n.AnnotationEditorType.NONE){<span class="cstat-no" title="statement not covered" >this.setEditingState(!1);<span class="cstat-no" title="statement not covered" >t</span>his.#ut()}</span>else{<span class="cstat-no" title="statement not covered" >this.setEditingState(!0);<span class="cstat-no" title="statement not covered" >t</span>his.#pt();<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.#O.values())<span class="cstat-no" title="statement not covered" >e.updateMode(t)}</span></span>}<span class="fstat-no" title="function not covered" ></span>up</span>dateToolbar(t){<span class="cstat-no" title="statement not covered" >t!==this.#z&amp;&amp;this.#q.dispatch("switchannotationeditormode",{source:this,mode:t})}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){<span class="cstat-no" title="statement not covered" >if(this.#U){<span class="cstat-no" title="statement not covered" >for(const s of this.#V)<span class="cstat-no" title="statement not covered" >s.updateParams(t,e);<span class="cstat-no" title="statement not covered" >f</span></span>or(const s of this.#U)<span class="cstat-no" title="statement not covered" >s.updateDefaultParams(t,e)}</span></span>}</span>#pt(){<span class="cstat-no" title="statement not covered" >if(!this.#G){<span class="cstat-no" title="statement not covered" >this.#G=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#O.values())<span class="cstat-no" title="statement not covered" >t.enable()}</span></span>}</span>#ut(){<span class="cstat-no" title="statement not covered" >this.unselectAll();<span class="cstat-no" title="statement not covered" >i</span>f(this.#G){<span class="cstat-no" title="statement not covered" >this.#G=!1;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#O.values())<span class="cstat-no" title="statement not covered" >t.disable()}</span></span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditors(t){const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const s of this.#I.values())<span class="cstat-no" title="statement not covered" >s.pageIndex===t&amp;&amp;e.push(s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditor(t){<span class="cstat-no" title="statement not covered" >return this.#I.get(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dEditor(t){<span class="cstat-no" title="statement not covered" >this.#I.set(t.id,t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEditor(t){<span class="cstat-no" title="statement not covered" >this.#I.delete(t.id);<span class="cstat-no" title="statement not covered" >t</span>his.unselect(t);<span class="cstat-no" title="statement not covered" >t</span>.annotationElementId&amp;&amp;this.#j.has(t.annotationElementId)||this.#L?.remove(t.id)}<span class="fstat-no" title="function not covered" ></span>ad</span>dDeletedAnnotationElement(t){<span class="cstat-no" title="statement not covered" >this.#j.add(t.annotationElementId);<span class="cstat-no" title="statement not covered" >t</span>.deleted=!0}<span class="fstat-no" title="function not covered" ></span>is</span>DeletedAnnotationElement(t){<span class="cstat-no" title="statement not covered" >return this.#j.has(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveDeletedAnnotationElement(t){<span class="cstat-no" title="statement not covered" >this.#j.delete(t.annotationElementId);<span class="cstat-no" title="statement not covered" >t</span>.deleted=!1}</span>#ot(t){const e=<span class="cstat-no" title="statement not covered" >this.#O.get(t.pageIndex);<span class="cstat-no" title="statement not covered" ></span>e?e.addOrRebuild(t):this.addEditor(t)}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveEditor(t){<span class="cstat-no" title="statement not covered" >if(this.#D!==t){<span class="cstat-no" title="statement not covered" >this.#D=t;<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;this.#ht(t.propertiesToUpdate)}</span>}<span class="fstat-no" title="function not covered" ></span>to</span>ggleSelected(t){<span class="cstat-no" title="statement not covered" >if(this.#V.has(t)){<span class="cstat-no" title="statement not covered" >this.#V.delete(t);<span class="cstat-no" title="statement not covered" >t</span>.unselect();<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSelectedEditor:this.hasSelection})}</span>else{<span class="cstat-no" title="statement not covered" >this.#V.add(t);<span class="cstat-no" title="statement not covered" >t</span>.select();<span class="cstat-no" title="statement not covered" >t</span>his.#ht(t.propertiesToUpdate);<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSelectedEditor:!0})}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tSelected(t){<span class="cstat-no" title="statement not covered" >for(const e of this.#V)<span class="cstat-no" title="statement not covered" >e!==t&amp;&amp;e.unselect();<span class="cstat-no" title="statement not covered" >t</span></span>his.#V.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#V.add(t);<span class="cstat-no" title="statement not covered" >t</span>.select();<span class="cstat-no" title="statement not covered" >t</span>his.#ht(t.propertiesToUpdate);<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSelectedEditor:!0})}<span class="fstat-no" title="function not covered" ></span>is</span>Selected(t){<span class="cstat-no" title="statement not covered" >return this.#V.has(t)}<span class="fstat-no" title="function not covered" ></span>un</span>select(t){<span class="cstat-no" title="statement not covered" >t.unselect();<span class="cstat-no" title="statement not covered" >t</span>his.#V.delete(t);<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSelectedEditor:this.hasSelection})}<span class="fstat-no" title="function not covered" ></span>ge</span>t hasSelection(){<span class="cstat-no" title="statement not covered" >return 0!==this.#V.size}<span class="fstat-no" title="function not covered" ></span>un</span>do(){<span class="cstat-no" title="statement not covered" >this.#N.undo();<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSomethingToUndo:this.#N.hasSomethingToUndo(),hasSomethingToRedo:!0,isEmpty:this.#dt()})}<span class="fstat-no" title="function not covered" ></span>re</span>do(){<span class="cstat-no" title="statement not covered" >this.#N.redo();<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSomethingToUndo:!0,hasSomethingToRedo:this.#N.hasSomethingToRedo(),isEmpty:this.#dt()})}<span class="fstat-no" title="function not covered" ></span>ad</span>dCommands(t){<span class="cstat-no" title="statement not covered" >this.#N.add(t);<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSomethingToUndo:!0,hasSomethingToRedo:!1,isEmpty:this.#dt()})}</span>#dt(){<span class="cstat-no" title="statement not covered" >if(0===this.#I.size)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(1===this.#I.size)<span class="cstat-no" title="statement not covered" >for(const t of this.#I.values())<span class="cstat-no" title="statement not covered" >return t.isEmpty();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="fstat-no" title="function not covered" ></span>de</span>lete(){<span class="cstat-no" title="statement not covered" >this.commitOrRemove();<span class="cstat-no" title="statement not covered" >i</span>f(!this.hasSelection)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >[...this.#V];<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.remove()}</span></span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >this.#ot(e)}</span></span>,mustExec:!0})}<span class="fstat-no" title="function not covered" ></span>co</span>mmitOrRemove(){<span class="cstat-no" title="statement not covered" >this.#D?.commitOrRemove()}</span>#lt(t){<span class="cstat-no" title="statement not covered" >this.#V.clear();<span class="cstat-no" title="statement not covered" >f</span>or(const e of t)<span class="cstat-no" title="statement not covered" >if(!e.isEmpty()){<span class="cstat-no" title="statement not covered" >this.#V.add(e);<span class="cstat-no" title="statement not covered" >e</span>.select()}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.#ct({hasSelectedEditor:!0})}<span class="fstat-no" title="function not covered" ></span>se</span>lectAll(){<span class="cstat-no" title="statement not covered" >for(const t of this.#V)<span class="cstat-no" title="statement not covered" >t.commit();<span class="cstat-no" title="statement not covered" >t</span></span>his.#lt(this.#I.values())}<span class="fstat-no" title="function not covered" ></span>un</span>selectAll(){<span class="cstat-no" title="statement not covered" >if(this.#D)<span class="cstat-no" title="statement not covered" >this.#D.commitOrRemove();e</span>lse <span class="cstat-no" title="statement not covered" >if(0!==this.#V.size){<span class="cstat-no" title="statement not covered" >for(const t of this.#V)<span class="cstat-no" title="statement not covered" >t.unselect();<span class="cstat-no" title="statement not covered" >t</span></span>his.#V.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#ct({hasSelectedEditor:!1})}</span>}<span class="fstat-no" title="function not covered" ></span></span>is</span>Active(t){<span class="cstat-no" title="statement not covered" >return this.#D===t}<span class="fstat-no" title="function not covered" ></span>ge</span>tActive(){<span class="cstat-no" title="statement not covered" >return this.#D}<span class="fstat-no" title="function not covered" ></span>ge</span>tMode(){<span class="cstat-no" title="statement not covered" >return this.#z}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationEditorUIManager=AnnotationEditorUIManager}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.StatTimer=e.RenderingCancelledException=e.PixelsPerInch=e.PageViewport=e.PDFDateString=e.DOMStandardFontDataFactory=e.DOMSVGFactory=e.DOMFilterFactory=e.DOMCanvasFactory=e.DOMCMapReaderFactory=e.AnnotationPrefix=void 0;<span class="cstat-no" title="statement not covered" >e</span>.deprecated=function <span class="fstat-no" title="function not covered" >deprecated(</span>t){<span class="cstat-no" title="statement not covered" >console.log("Deprecated API usage: "+t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getColorValues=function <span class="fstat-no" title="function not covered" >getColorValues(</span>t){const e=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>e.style.visibility="hidden";<span class="cstat-no" title="statement not covered" >d</span>ocument.body.append(e);<span class="cstat-no" title="statement not covered" >f</span>or(const s of t.keys()){<span class="cstat-no" title="statement not covered" >e.style.color=s;c</span>onst n=<span class="cstat-no" title="statement not covered" >window.getComputedStyle(e).color;<span class="cstat-no" title="statement not covered" ></span>t.set(s,getRGB(n))}<span class="cstat-no" title="statement not covered" ></span>e</span>.remove()}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getCurrentTransform=function <span class="fstat-no" title="function not covered" >getCurrentTransform(</span>t){const{a:e,b:s,c:n,d:i,e:a,f:r}=<span class="cstat-no" title="statement not covered" >t.getTransform();<span class="cstat-no" title="statement not covered" ></span>return[e,s,n,i,a,r]}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getCurrentTransformInverse=function <span class="fstat-no" title="function not covered" >getCurrentTransformInverse(</span>t){const{a:e,b:s,c:n,d:i,e:a,f:r}=<span class="cstat-no" title="statement not covered" >t.getTransform().invertSelf();<span class="cstat-no" title="statement not covered" ></span>return[e,s,n,i,a,r]}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getFilenameFromUrl=function <span class="fstat-no" title="function not covered" >getFilenameFromUrl(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >e||([t]=t.split(/[#?]/,1));<span class="cstat-no" title="statement not covered" >r</span>eturn t.substring(t.lastIndexOf("/")+1)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getPdfFilenameFromUrl=function <span class="fstat-no" title="function not covered" >getPdfFilenameFromUrl(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"document.pdf")</span>{<span class="cstat-no" title="statement not covered" >if("string"!=typeof t)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(isDataScheme(t)){<span class="cstat-no" title="statement not covered" >(0,i.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >/[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,</span>n=<span class="cstat-no" title="statement not covered" >/^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(t);</span>let a=<span class="cstat-no" title="statement not covered" >s.exec(n[1])||s.exec(n[2])||s.exec(n[3]);<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >a=a[0];<span class="cstat-no" title="statement not covered" >i</span>f(a.includes("%"))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >a=s.exec(decodeURIComponent(a))[0]}</span>catch{}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn a||e}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getRGB=getRGB;<span class="cstat-no" title="statement not covered" >e</span>.getXfaPageViewport=function <span class="fstat-no" title="function not covered" >getXfaPageViewport(</span>t,{scale:e=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>rotation:s=<span class="branch-0 cbranch-no" title="branch not covered" >0}</span>){const{width:n,height:i}=<span class="cstat-no" title="statement not covered" >t.attributes.style,</span>a=<span class="cstat-no" title="statement not covered" >[0,0,parseInt(n),parseInt(i)];<span class="cstat-no" title="statement not covered" ></span>return new PageViewport({viewBox:a,scale:e,rotation:s})}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isDataScheme=isDataScheme;<span class="cstat-no" title="statement not covered" >e</span>.isPdfFile=function <span class="fstat-no" title="function not covered" >isPdfFile(</span>t){<span class="cstat-no" title="statement not covered" >return"string"==typeof t&amp;&amp;/\.pdf$/i.test(t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isValidFetchUrl=isValidFetchUrl;<span class="cstat-no" title="statement not covered" >e</span>.loadScript=function <span class="fstat-no" title="function not covered" >loadScript(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >(s</span>,n)=&gt;{const i=<span class="cstat-no" title="statement not covered" >document.createElement("script");<span class="cstat-no" title="statement not covered" ></span>i.src=t;<span class="cstat-no" title="statement not covered" >i</span>.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e&amp;&amp;i.remove();<span class="cstat-no" title="statement not covered" >s</span>(t)}</span>;<span class="cstat-no" title="statement not covered" >i</span>.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n(new Error(`Cannot load script at: ${i.src}`))}</span>;<span class="cstat-no" title="statement not covered" >(</span>document.head||document.documentElement).append(i)}</span>))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.setLayerDimensions=function <span class="fstat-no" title="function not covered" >setLayerDimensions(</span>t,e,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e instanceof PageViewport){const{pageWidth:n,pageHeight:i}=<span class="cstat-no" title="statement not covered" >e.rawDims,</span>{style:a}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >`calc(var(--scale-factor) * ${n}px)`,</span>o=<span class="cstat-no" title="statement not covered" >`calc(var(--scale-factor) * ${i}px)`;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;e.rotation%180!=0){<span class="cstat-no" title="statement not covered" >a.width=o;<span class="cstat-no" title="statement not covered" >a</span>.height=r}</span>else{<span class="cstat-no" title="statement not covered" >a.width=r;<span class="cstat-no" title="statement not covered" >a</span>.height=o}</span>}<span class="cstat-no" title="statement not covered" ></span>n</span>&amp;&amp;t.setAttribute("data-main-rotation",e.rotation)}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(7),</span>i=<span class="cstat-no" title="statement not covered" >s(1);</span>const a=<span class="cstat-no" title="statement not covered" >"http://www.w3.org/2000/svg";<span class="cstat-no" title="statement not covered" ></span>e.AnnotationPrefix="pdfjs_internal_id_";c</span>lass PixelsPerInch{static CSS=<span class="cstat-no" title="statement not covered" >96;</span>static PDF=<span class="cstat-no" title="statement not covered" >72;</span>static PDF_TO_CSS_UNITS=<span class="cstat-no" title="statement not covered" >this.CSS/this.PDF}<span class="cstat-no" title="statement not covered" ></span>e.PixelsPerInch=PixelsPerInch;c</span>lass DOMFilterFactory extends n.BaseFilterFactory{#gt;#ft;#e;#mt;#bt;#At;#_t;#yt;#vt;#St;#T=<span class="cstat-no" title="statement not covered" >0;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({docId:t,ownerDocument:e=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.document}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.#e=t;<span class="cstat-no" title="statement not covered" >t</span>his.#mt=e}</span>get#Et(){<span class="cstat-no" title="statement not covered" >return this.#gt||=new Map}</span>get#xt(){<span class="cstat-no" title="statement not covered" >if(!this.#ft){const t=<span class="cstat-no" title="statement not covered" >this.#mt.createElement("div"),</span>{style:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>e.visibility="hidden";<span class="cstat-no" title="statement not covered" >e</span>.contain="strict";<span class="cstat-no" title="statement not covered" >e</span>.width=e.height=0;<span class="cstat-no" title="statement not covered" >e</span>.position="absolute";<span class="cstat-no" title="statement not covered" >e</span>.top=e.left=0;<span class="cstat-no" title="statement not covered" >e</span>.zIndex=-1;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.#mt.createElementNS(a,"svg");<span class="cstat-no" title="statement not covered" ></span>s.setAttribute("width",0);<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("height",0);<span class="cstat-no" title="statement not covered" >t</span>his.#ft=this.#mt.createElementNS(a,"defs");<span class="cstat-no" title="statement not covered" >t</span>.append(s);<span class="cstat-no" title="statement not covered" >s</span>.append(this.#ft);<span class="cstat-no" title="statement not covered" >t</span>his.#mt.body.append(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.#ft}<span class="fstat-no" title="function not covered" ></span>ad</span>dFilter(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return"none";l</span></span>et e,s,n,i,a=<span class="cstat-no" title="statement not covered" >this.#Et.get(t);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(1===t.length){const a=<span class="cstat-no" title="statement not covered" >t[0],</span>r=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;256;t++)<span class="cstat-no" title="statement not covered" >r[t]=a[t]/255;<span class="cstat-no" title="statement not covered" >i</span></span>=e=s=n=r.join(",")}</span>else{const[a,r,o]=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >new Array(256),</span>c=<span class="cstat-no" title="statement not covered" >new Array(256),</span>h=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;256;t++){<span class="cstat-no" title="statement not covered" >l[t]=a[t]/255;<span class="cstat-no" title="statement not covered" >c</span>[t]=r[t]/255;<span class="cstat-no" title="statement not covered" >h</span>[t]=o[t]/255}<span class="cstat-no" title="statement not covered" ></span>e</span>=l.join(",");<span class="cstat-no" title="statement not covered" >s</span>=c.join(",");<span class="cstat-no" title="statement not covered" >n</span>=h.join(",");<span class="cstat-no" title="statement not covered" >i</span>=`${e}${s}${n}`}<span class="cstat-no" title="statement not covered" ></span>a</span>=this.#Et.get(i);<span class="cstat-no" title="statement not covered" >i</span>f(a){<span class="cstat-no" title="statement not covered" >this.#Et.set(t,a);<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >`g_${this.#e}_transfer_map_${this.#T++}`,</span>o=<span class="cstat-no" title="statement not covered" >`url(#${r})`;<span class="cstat-no" title="statement not covered" ></span>this.#Et.set(t,o);<span class="cstat-no" title="statement not covered" >t</span>his.#Et.set(i,o);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.#Ct(r);<span class="cstat-no" title="statement not covered" ></span>this.#wt(e,s,n,l);<span class="cstat-no" title="statement not covered" >r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>ad</span>dHCMFilter(t,e){const s=<span class="cstat-no" title="statement not covered" >`${t}-${e}`;<span class="cstat-no" title="statement not covered" ></span>if(this.#At===s)<span class="cstat-no" title="statement not covered" >return this.#_t;<span class="cstat-no" title="statement not covered" >t</span></span>his.#At=s;<span class="cstat-no" title="statement not covered" >t</span>his.#_t="none";<span class="cstat-no" title="statement not covered" >t</span>his.#bt?.remove();<span class="cstat-no" title="statement not covered" >i</span>f(!t||!e)<span class="cstat-no" title="statement not covered" >return this.#_t;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.#Tt(t);<span class="cstat-no" title="statement not covered" ></span>t=i.Util.makeHexColor(...n);c</span>onst a=<span class="cstat-no" title="statement not covered" >this.#Tt(e);<span class="cstat-no" title="statement not covered" ></span>e=i.Util.makeHexColor(...a);<span class="cstat-no" title="statement not covered" >t</span>his.#xt.style.color="";<span class="cstat-no" title="statement not covered" >i</span>f("#000000"===t&amp;&amp;"#ffffff"===e||t===e)<span class="cstat-no" title="statement not covered" >return this.#_t;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;=255;t++){const e=<span class="cstat-no" title="statement not covered" >t/255;<span class="cstat-no" title="statement not covered" ></span>r[t]=e&lt;=.03928?e/12.92:((e+.055)/1.055)**2.4}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >r.join(","),</span>l=<span class="cstat-no" title="statement not covered" >`g_${this.#e}_hcm_filter`,</span>c=<span class="cstat-no" title="statement not covered" >this.#yt=this.#Ct(l);<span class="cstat-no" title="statement not covered" ></span>this.#wt(o,o,o,c);<span class="cstat-no" title="statement not covered" >t</span>his.#Pt(c);c</span>onst getSteps=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n[t]/255,</span>i=<span class="cstat-no" title="statement not covered" >a[t]/255,</span>r=<span class="cstat-no" title="statement not covered" >new Array(e+1);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;=e;t++)<span class="cstat-no" title="statement not covered" >r[t]=s+t/e*(i-s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.join(",")}</span>;<span class="cstat-no" title="statement not covered" ></span>this.#wt(getSteps(0,5),getSteps(1,5),getSteps(2,5),c);<span class="cstat-no" title="statement not covered" >t</span>his.#_t=`url(#${l})`;<span class="cstat-no" title="statement not covered" >r</span>eturn this.#_t}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightHCMFilter(t,e,s,n){const i=<span class="cstat-no" title="statement not covered" >`${t}-${e}-${s}-${n}`;<span class="cstat-no" title="statement not covered" ></span>if(this.#vt===i)<span class="cstat-no" title="statement not covered" >return this.#St;<span class="cstat-no" title="statement not covered" >t</span></span>his.#vt=i;<span class="cstat-no" title="statement not covered" >t</span>his.#St="none";<span class="cstat-no" title="statement not covered" >t</span>his.#yt?.remove();<span class="cstat-no" title="statement not covered" >i</span>f(!t||!e)<span class="cstat-no" title="statement not covered" >return this.#St;c</span></span>onst[a,r]=<span class="cstat-no" title="statement not covered" >[t,e].map(this.#Tt.bind(this));</span>let o=<span class="cstat-no" title="statement not covered" >Math.round(.2126*a[0]+.7152*a[1]+.0722*a[2]),</span>l=<span class="cstat-no" title="statement not covered" >Math.round(.2126*r[0]+.7152*r[1]+.0722*r[2]),</span>[c,h]=<span class="cstat-no" title="statement not covered" >[s,n].map(this.#Tt.bind(this));<span class="cstat-no" title="statement not covered" ></span>l&lt;o&amp;&amp;([o,l,c,h]=[l,o,h,c]);<span class="cstat-no" title="statement not covered" >t</span>his.#xt.style.color="";c</span>onst getSteps=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >new Array(256),</span>i=<span class="cstat-no" title="statement not covered" >(l-o)/s,</span>a=<span class="cstat-no" title="statement not covered" >t/255,</span>r=<span class="cstat-no" title="statement not covered" >(e-t)/(255*s);</span>let c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;=s;t++){const e=<span class="cstat-no" title="statement not covered" >Math.round(o+t*i),</span>s=<span class="cstat-no" title="statement not covered" >a+t*r;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >c;</span>t&lt;=e;t++)<span class="cstat-no" title="statement not covered" >n[t]=s;<span class="cstat-no" title="statement not covered" >c</span></span>=e+1}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let t=<span class="cstat-no" title="statement not covered" >c;</span>t&lt;256;t++)<span class="cstat-no" title="statement not covered" >n[t]=n[c-1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.join(",")}</span>,</span>d=<span class="cstat-no" title="statement not covered" >`g_${this.#e}_hcm_highlight_filter`,</span>u=<span class="cstat-no" title="statement not covered" >this.#yt=this.#Ct(d);<span class="cstat-no" title="statement not covered" ></span>this.#Pt(u);<span class="cstat-no" title="statement not covered" >t</span>his.#wt(getSteps(c[0],h[0],5),getSteps(c[1],h[1],5),getSteps(c[2],h[2],5),u);<span class="cstat-no" title="statement not covered" >t</span>his.#St=`url(#${d})`;<span class="cstat-no" title="statement not covered" >r</span>eturn this.#St}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!t||!this.#_t&amp;&amp;!this.#St){<span class="cstat-no" title="statement not covered" >if(this.#ft){<span class="cstat-no" title="statement not covered" >this.#ft.parentNode.parentNode.remove();<span class="cstat-no" title="statement not covered" >t</span>his.#ft=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#gt){<span class="cstat-no" title="statement not covered" >this.#gt.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#gt=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#T=0}</span>}</span>#Pt(t){const e=<span class="cstat-no" title="statement not covered" >this.#mt.createElementNS(a,"feColorMatrix");<span class="cstat-no" title="statement not covered" ></span>e.setAttribute("type","matrix");<span class="cstat-no" title="statement not covered" >e</span>.setAttribute("values","0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");<span class="cstat-no" title="statement not covered" >t</span>.append(e)}</span>#Ct(t){const e=<span class="cstat-no" title="statement not covered" >this.#mt.createElementNS(a,"filter");<span class="cstat-no" title="statement not covered" ></span>e.setAttribute("color-interpolation-filters","sRGB");<span class="cstat-no" title="statement not covered" >e</span>.setAttribute("id",t);<span class="cstat-no" title="statement not covered" >t</span>his.#xt.append(e);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>#Ft(t,e,s){const n=<span class="cstat-no" title="statement not covered" >this.#mt.createElementNS(a,e);<span class="cstat-no" title="statement not covered" ></span>n.setAttribute("type","discrete");<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("tableValues",s);<span class="cstat-no" title="statement not covered" >t</span>.append(n)}</span>#wt(t,e,s,n){const i=<span class="cstat-no" title="statement not covered" >this.#mt.createElementNS(a,"feComponentTransfer");<span class="cstat-no" title="statement not covered" ></span>n.append(i);<span class="cstat-no" title="statement not covered" >t</span>his.#Ft(i,"feFuncR",t);<span class="cstat-no" title="statement not covered" >t</span>his.#Ft(i,"feFuncG",e);<span class="cstat-no" title="statement not covered" >t</span>his.#Ft(i,"feFuncB",s)}</span>#Tt(t){<span class="cstat-no" title="statement not covered" >this.#xt.style.color=t;<span class="cstat-no" title="statement not covered" >r</span>eturn getRGB(getComputedStyle(this.#xt).getPropertyValue("color"))}</span>}<span class="cstat-no" title="statement not covered" >e.DOMFilterFactory=DOMFilterFactory;c</span>lass DOMCanvasFactory extends n.BaseCanvasFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor({ownerDocument:t=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.document}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._document=t}<span class="fstat-no" title="function not covered" ></span>_c</span>reateCanvas(t,e){const s=<span class="cstat-no" title="statement not covered" >this._document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>s.width=t;<span class="cstat-no" title="statement not covered" >s</span>.height=e;<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>}<span class="cstat-no" title="statement not covered" >e.DOMCanvasFactory=DOMCanvasFactory;a</span>sync function <span class="fstat-no" title="function not covered" >fetchData(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(isValidFetchUrl(t,document.baseURI)){const s=<span class="cstat-no" title="statement not covered" >await fetch(t);<span class="cstat-no" title="statement not covered" ></span>if(!s.ok)<span class="cstat-no" title="statement not covered" >throw new Error(s.statusText);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e?new Uint8Array(await s.arrayBuffer()):(0,i.stringToBytes)(await s.text())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Promise((<span class="fstat-no" title="function not covered" >(s</span>,n)=&gt;{const a=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>a.open("GET",t,!0);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(a.responseType="arraybuffer");<span class="cstat-no" title="statement not covered" >a</span>.onreadystatechange=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(a.readyState===XMLHttpRequest.DONE){<span class="cstat-no" title="statement not covered" >if(200===a.status||0===a.status){let t;<span class="cstat-no" title="statement not covered" >e&amp;&amp;a.response?t=new Uint8Array(a.response):!e&amp;&amp;a.responseText&amp;&amp;(t=(0,i.stringToBytes)(a.responseText));<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >s(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>n</span>(new Error(a.statusText))}</span>}</span>;<span class="cstat-no" title="statement not covered" >a</span>.send(null)}</span>))}</span>class DOMCMapReaderFactory extends n.BaseCMapReaderFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t,e){<span class="cstat-no" title="statement not covered" >return fetchData(t,this.isCompressed).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{cMapData:t,compressionType:e})</span>))}</span>}<span class="cstat-no" title="statement not covered" >e.DOMCMapReaderFactory=DOMCMapReaderFactory;c</span>lass DOMStandardFontDataFactory extends n.BaseStandardFontDataFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t){<span class="cstat-no" title="statement not covered" >return fetchData(t,!0)}</span>}<span class="cstat-no" title="statement not covered" >e.DOMStandardFontDataFactory=DOMStandardFontDataFactory;c</span>lass DOMSVGFactory extends n.BaseSVGFactory{<span class="fstat-no" title="function not covered" >_c</span>reateSVG(t){<span class="cstat-no" title="statement not covered" >return document.createElementNS(a,t)}</span>}<span class="cstat-no" title="statement not covered" >e.DOMSVGFactory=DOMSVGFactory;c</span>lass PageViewport{<span class="fstat-no" title="function not covered" >co</span>nstructor({viewBox:t,scale:e,rotation:s,offsetX:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>offsetY:i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dontFlip:a=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){<span class="cstat-no" title="statement not covered" >this.viewBox=t;<span class="cstat-no" title="statement not covered" >t</span>his.scale=e;<span class="cstat-no" title="statement not covered" >t</span>his.rotation=s;<span class="cstat-no" title="statement not covered" >t</span>his.offsetX=n;<span class="cstat-no" title="statement not covered" >t</span>his.offsetY=i;c</span>onst r=<span class="cstat-no" title="statement not covered" >(t[2]+t[0])/2,</span>o=<span class="cstat-no" title="statement not covered" >(t[3]+t[1])/2;</span>let l,c,h,d,u,p,g,f;<span class="cstat-no" title="statement not covered" >(s%=360)&lt;0&amp;&amp;(s+=360);<span class="cstat-no" title="statement not covered" >s</span>witch(s){case 180:<span class="cstat-no" title="statement not covered" >l=-1;<span class="cstat-no" title="statement not covered" >c</span>=0;<span class="cstat-no" title="statement not covered" >h</span>=0;<span class="cstat-no" title="statement not covered" >d</span>=1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >l=0;<span class="cstat-no" title="statement not covered" >c</span>=1;<span class="cstat-no" title="statement not covered" >h</span>=1;<span class="cstat-no" title="statement not covered" >d</span>=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >l=0;<span class="cstat-no" title="statement not covered" >c</span>=-1;<span class="cstat-no" title="statement not covered" >h</span>=-1;<span class="cstat-no" title="statement not covered" >d</span>=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 0:<span class="cstat-no" title="statement not covered" >l=1;<span class="cstat-no" title="statement not covered" >c</span>=0;<span class="cstat-no" title="statement not covered" >h</span>=0;<span class="cstat-no" title="statement not covered" >d</span>=-1;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a){<span class="cstat-no" title="statement not covered" >h=-h;<span class="cstat-no" title="statement not covered" >d</span>=-d}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===l){<span class="cstat-no" title="statement not covered" >u=Math.abs(o-t[1])*e+n;<span class="cstat-no" title="statement not covered" >p</span>=Math.abs(r-t[0])*e+i;<span class="cstat-no" title="statement not covered" >g</span>=(t[3]-t[1])*e;<span class="cstat-no" title="statement not covered" >f</span>=(t[2]-t[0])*e}</span>else{<span class="cstat-no" title="statement not covered" >u=Math.abs(r-t[0])*e+n;<span class="cstat-no" title="statement not covered" >p</span>=Math.abs(o-t[1])*e+i;<span class="cstat-no" title="statement not covered" >g</span>=(t[2]-t[0])*e;<span class="cstat-no" title="statement not covered" >f</span>=(t[3]-t[1])*e}<span class="cstat-no" title="statement not covered" ></span>t</span>his.transform=[l*e,c*e,h*e,d*e,u-l*e*r-h*e*o,p-c*e*r-d*e*o];<span class="cstat-no" title="statement not covered" >t</span>his.width=g;<span class="cstat-no" title="statement not covered" >t</span>his.height=f}<span class="fstat-no" title="function not covered" ></span>ge</span>t rawDims(){const{viewBox:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return(0,i.shadow)(this,"rawDims",{pageWidth:t[2]-t[0],pageHeight:t[3]-t[1],pageX:t[0],pageY:t[1]})}<span class="fstat-no" title="function not covered" ></span>cl</span>one({scale:t=<span class="branch-0 cbranch-no" title="branch not covered" >this.scale,</span>rotation:e=<span class="branch-0 cbranch-no" title="branch not covered" >this.rotation,</span>offsetX:s=<span class="branch-0 cbranch-no" title="branch not covered" >this.offsetX,</span>offsetY:n=<span class="branch-0 cbranch-no" title="branch not covered" >this.offsetY,</span>dontFlip:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new PageViewport({viewBox:this.viewBox.slice(),scale:t,rotation:e,offsetX:s,offsetY:n,dontFlip:i})}<span class="fstat-no" title="function not covered" ></span>co</span>nvertToViewportPoint(t,e){<span class="cstat-no" title="statement not covered" >return i.Util.applyTransform([t,e],this.transform)}<span class="fstat-no" title="function not covered" ></span>co</span>nvertToViewportRectangle(t){const e=<span class="cstat-no" title="statement not covered" >i.Util.applyTransform([t[0],t[1]],this.transform),</span>s=<span class="cstat-no" title="statement not covered" >i.Util.applyTransform([t[2],t[3]],this.transform);<span class="cstat-no" title="statement not covered" ></span>return[e[0],e[1],s[0],s[1]]}<span class="fstat-no" title="function not covered" ></span>co</span>nvertToPdfPoint(t,e){<span class="cstat-no" title="statement not covered" >return i.Util.applyInverseTransform([t,e],this.transform)}</span>}<span class="cstat-no" title="statement not covered" >e.PageViewport=PageViewport;c</span>lass RenderingCancelledException extends i.BaseException{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >super(t,"RenderingCancelledException");<span class="cstat-no" title="statement not covered" >t</span>his.extraDelay=e}</span>}<span class="cstat-no" title="statement not covered" >e.RenderingCancelledException=RenderingCancelledException;f</span>unction <span class="fstat-no" title="function not covered" >isDataScheme(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.length;</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;s&lt;e&amp;&amp;""===t[s].trim();)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn"data:"===t.substring(s,s+5).toLowerCase()}<span class="cstat-no" title="statement not covered" ></span>e.StatTimer=class StatTimer{started=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>times=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>ti</span>me(t){<span class="cstat-no" title="statement not covered" >t in this.started&amp;&amp;(0,i.warn)(`Timer is already running for ${t}`);<span class="cstat-no" title="statement not covered" >t</span>his.started[t]=Date.now()}<span class="fstat-no" title="function not covered" ></span>ti</span>meEnd(t){<span class="cstat-no" title="statement not covered" >t in this.started||(0,i.warn)(`Timer has not been started for ${t}`);<span class="cstat-no" title="statement not covered" >t</span>his.times.push({name:t,start:this.started[t],end:Date.now()});<span class="cstat-no" title="statement not covered" >d</span>elete this.started[t]}<span class="fstat-no" title="function not covered" ></span>to</span>String(){const t=<span class="cstat-no" title="statement not covered" >[];</span>let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const{name:t}of this.times)<span class="cstat-no" title="statement not covered" >e=Math.max(t.length,e);<span class="cstat-no" title="statement not covered" >f</span></span>or(const{name:s,start:n,end:i}of this.times)<span class="cstat-no" title="statement not covered" >t.push(`${s.padEnd(e)} ${i-n}ms\n`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.join("")}</span>};f</span>unction <span class="fstat-no" title="function not covered" >isValidFetchUrl(</span>t,e){<span class="cstat-no" title="statement not covered" >try{const{protocol:s}=<span class="cstat-no" title="statement not covered" >e?new URL(t,e):new URL(t);<span class="cstat-no" title="statement not covered" ></span>return"http:"===s||"https:"===s}</span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>let r;<span class="cstat-no" title="statement not covered" >e.PDFDateString=class PDFDateString{<span class="fstat-no" title="function not covered" >st</span>atic toDateObject(t){<span class="cstat-no" title="statement not covered" >if(!t||"string"!=typeof t)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>||=new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");c</span>onst e=<span class="cstat-no" title="statement not covered" >r.exec(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >parseInt(e[1],10);</span>let n=<span class="cstat-no" title="statement not covered" >parseInt(e[2],10);<span class="cstat-no" title="statement not covered" ></span>n=n&gt;=1&amp;&amp;n&lt;=12?n-1:0;l</span>et i=<span class="cstat-no" title="statement not covered" >parseInt(e[3],10);<span class="cstat-no" title="statement not covered" ></span>i=i&gt;=1&amp;&amp;i&lt;=31?i:1;l</span>et a=<span class="cstat-no" title="statement not covered" >parseInt(e[4],10);<span class="cstat-no" title="statement not covered" ></span>a=a&gt;=0&amp;&amp;a&lt;=23?a:0;l</span>et o=<span class="cstat-no" title="statement not covered" >parseInt(e[5],10);<span class="cstat-no" title="statement not covered" ></span>o=o&gt;=0&amp;&amp;o&lt;=59?o:0;l</span>et l=<span class="cstat-no" title="statement not covered" >parseInt(e[6],10);<span class="cstat-no" title="statement not covered" ></span>l=l&gt;=0&amp;&amp;l&lt;=59?l:0;c</span>onst c=<span class="cstat-no" title="statement not covered" >e[7]||"Z";</span>let h=<span class="cstat-no" title="statement not covered" >parseInt(e[8],10);<span class="cstat-no" title="statement not covered" ></span>h=h&gt;=0&amp;&amp;h&lt;=23?h:0;l</span>et d=<span class="cstat-no" title="statement not covered" >parseInt(e[9],10)||0;<span class="cstat-no" title="statement not covered" ></span>d=d&gt;=0&amp;&amp;d&lt;=59?d:0;<span class="cstat-no" title="statement not covered" >i</span>f("-"===c){<span class="cstat-no" title="statement not covered" >a+=h;<span class="cstat-no" title="statement not covered" >o</span>+=d}</span>else <span class="cstat-no" title="statement not covered" >if("+"===c){<span class="cstat-no" title="statement not covered" >a-=h;<span class="cstat-no" title="statement not covered" >o</span>-=d}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn new Date(Date.UTC(s,n,i,a,o,l))}</span>};f</span>unction <span class="fstat-no" title="function not covered" >getRGB(</span>t){<span class="cstat-no" title="statement not covered" >if(t.startsWith("#")){const e=<span class="cstat-no" title="statement not covered" >parseInt(t.slice(1),16);<span class="cstat-no" title="statement not covered" ></span>return[(16711680&amp;e)&gt;&gt;16,(65280&amp;e)&gt;&gt;8,255&amp;e]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.startsWith("rgb("))<span class="cstat-no" title="statement not covered" >return t.slice(4,-1).split(",").map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >parseInt(t))</span>);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.startsWith("rgba("))<span class="cstat-no" title="statement not covered" >return t.slice(5,-1).split(",").map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >parseInt(t))</span>).slice(0,3);<span class="cstat-no" title="statement not covered" >(</span></span>0,i.warn)(`Not a valid color format: "${t}"`);<span class="cstat-no" title="statement not covered" >r</span>eturn[0,0,0]}</span>},<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.BaseStandardFontDataFactory=e.BaseSVGFactory=e.BaseFilterFactory=e.BaseCanvasFactory=e.BaseCMapReaderFactory=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1);</span>class BaseFilterFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseFilterFactory&amp;&amp;(0,n.unreachable)("Cannot initialize BaseFilterFactory.")}<span class="fstat-no" title="function not covered" ></span>ad</span>dFilter(t){<span class="cstat-no" title="statement not covered" >return"none"}<span class="fstat-no" title="function not covered" ></span>ad</span>dHCMFilter(t,e){<span class="cstat-no" title="statement not covered" >return"none"}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightHCMFilter(t,e,s,n){<span class="cstat-no" title="statement not covered" >return"none"}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{}}<span class="cstat-no" title="statement not covered" >e.BaseFilterFactory=BaseFilterFactory;c</span>lass BaseCanvasFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseCanvasFactory&amp;&amp;(0,n.unreachable)("Cannot initialize BaseCanvasFactory.")}<span class="fstat-no" title="function not covered" ></span>cr</span>eate(t,e){<span class="cstat-no" title="statement not covered" >if(t&lt;=0||e&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid canvas size");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this._createCanvas(t,e);<span class="cstat-no" title="statement not covered" ></span>return{canvas:s,context:s.getContext("2d")}}<span class="fstat-no" title="function not covered" ></span>re</span>set(t,e,s){<span class="cstat-no" title="statement not covered" >if(!t.canvas)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is not specified");<span class="cstat-no" title="statement not covered" >i</span></span>f(e&lt;=0||s&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid canvas size");<span class="cstat-no" title="statement not covered" >t</span></span>.canvas.width=e;<span class="cstat-no" title="statement not covered" >t</span>.canvas.height=s}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(t){<span class="cstat-no" title="statement not covered" >if(!t.canvas)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is not specified");<span class="cstat-no" title="statement not covered" >t</span></span>.canvas.width=0;<span class="cstat-no" title="statement not covered" >t</span>.canvas.height=0;<span class="cstat-no" title="statement not covered" >t</span>.canvas=null;<span class="cstat-no" title="statement not covered" >t</span>.context=null}<span class="fstat-no" title="function not covered" ></span>_c</span>reateCanvas(t,e){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Abstract method `_createCanvas` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseCanvasFactory=BaseCanvasFactory;c</span>lass BaseCMapReaderFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor({baseUrl:t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>isCompressed:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>){<span class="cstat-no" title="statement not covered" >this.constructor===BaseCMapReaderFactory&amp;&amp;(0,n.unreachable)("Cannot initialize BaseCMapReaderFactory.");<span class="cstat-no" title="statement not covered" >t</span>his.baseUrl=t;<span class="cstat-no" title="statement not covered" >t</span>his.isCompressed=e}<span class="fstat-no" title="function not covered" ></span>as</span>ync fetch({name:t}){<span class="cstat-no" title="statement not covered" >if(!this.baseUrl)<span class="cstat-no" title="statement not covered" >throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >throw new Error("CMap name must be specified.");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.baseUrl+t+(this.isCompressed?".bcmap":""),</span>s=<span class="cstat-no" title="statement not covered" >this.isCompressed?n.CMapCompressionType.BINARY:n.CMapCompressionType.NONE;<span class="cstat-no" title="statement not covered" ></span>return this._fetchData(e,s).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >throw new Error(`Unable to load ${this.isCompressed?"binary ":""}CMap at: ${e}`)}</span>))}<span class="fstat-no" title="function not covered" ></span>_f</span>etchData(t,e){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Abstract method `_fetchData` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseCMapReaderFactory=BaseCMapReaderFactory;c</span>lass BaseStandardFontDataFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor({baseUrl:t=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this.constructor===BaseStandardFontDataFactory&amp;&amp;(0,n.unreachable)("Cannot initialize BaseStandardFontDataFactory.");<span class="cstat-no" title="statement not covered" >t</span>his.baseUrl=t}<span class="fstat-no" title="function not covered" ></span>as</span>ync fetch({filename:t}){<span class="cstat-no" title="statement not covered" >if(!this.baseUrl)<span class="cstat-no" title="statement not covered" >throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >throw new Error("Font filename must be specified.");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >`${this.baseUrl}${t}`;<span class="cstat-no" title="statement not covered" ></span>return this._fetchData(e).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >throw new Error(`Unable to load font data at: ${e}`)}</span>))}<span class="fstat-no" title="function not covered" ></span>_f</span>etchData(t){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Abstract method `_fetchData` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseStandardFontDataFactory=BaseStandardFontDataFactory;c</span>lass BaseSVGFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseSVGFactory&amp;&amp;(0,n.unreachable)("Cannot initialize BaseSVGFactory.")}<span class="fstat-no" title="function not covered" ></span>cr</span>eate(t,e,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(t&lt;=0||e&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid SVG dimensions");c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._createSVG("svg:svg");<span class="cstat-no" title="statement not covered" ></span>n.setAttribute("version","1.1");<span class="cstat-no" title="statement not covered" >i</span>f(!s){<span class="cstat-no" title="statement not covered" >n.setAttribute("width",`${t}px`);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("height",`${e}px`)}<span class="cstat-no" title="statement not covered" ></span>n</span>.setAttribute("preserveAspectRatio","none");<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("viewBox",`0 0 ${t} ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>cr</span>eateElement(t){<span class="cstat-no" title="statement not covered" >if("string"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid SVG element type");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createSVG(t)}<span class="fstat-no" title="function not covered" ></span>_c</span>reateSVG(t){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Abstract method `_createSVG` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseSVGFactory=BaseSVGFactory}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.MurmurHash3_64=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1);</span>const i=<span class="cstat-no" title="statement not covered" >3285377520,</span>a=<span class="cstat-no" title="statement not covered" >4294901760,</span>r=<span class="cstat-no" title="statement not covered" >65535;<span class="cstat-no" title="statement not covered" ></span>e.MurmurHash3_64=class MurmurHash3_64{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.h1=t?4294967295&amp;t:i;<span class="cstat-no" title="statement not covered" >t</span>his.h2=t?4294967295&amp;t:i}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){let e,s;<span class="cstat-no" title="statement not covered" >if("string"==typeof t){<span class="cstat-no" title="statement not covered" >e=new Uint8Array(2*t.length);<span class="cstat-no" title="statement not covered" >s</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>n&lt;i;n++){const i=<span class="cstat-no" title="statement not covered" >t.charCodeAt(n);<span class="cstat-no" title="statement not covered" ></span>if(i&lt;=255)<span class="cstat-no" title="statement not covered" >e[s++]=i;e</span>lse{<span class="cstat-no" title="statement not covered" >e[s++]=i&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >e</span>[s++]=255&amp;i}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!(0,n.isArrayBuffer)(t))<span class="cstat-no" title="statement not covered" >throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");<span class="cstat-no" title="statement not covered" >e</span></span>=t.slice();<span class="cstat-no" title="statement not covered" >s</span>=e.byteLength}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >s&gt;&gt;2,</span>o=<span class="cstat-no" title="statement not covered" >s-4*i,</span>l=<span class="cstat-no" title="statement not covered" >new Uint32Array(e.buffer,0,i);</span>let c=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >this.h1,</span>u=<span class="cstat-no" title="statement not covered" >this.h2;</span>const p=<span class="cstat-no" title="statement not covered" >3432918353,</span>g=<span class="cstat-no" title="statement not covered" >461845907,</span>f=<span class="cstat-no" title="statement not covered" >11601,</span>m=<span class="cstat-no" title="statement not covered" >13715;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i;t++)<span class="cstat-no" title="statement not covered" >if(1&amp;t){<span class="cstat-no" title="statement not covered" >c=l[t];<span class="cstat-no" title="statement not covered" >c</span>=c*p&amp;a|c*f&amp;r;<span class="cstat-no" title="statement not covered" >c</span>=c&lt;&lt;15|c&gt;&gt;&gt;17;<span class="cstat-no" title="statement not covered" >c</span>=c*g&amp;a|c*m&amp;r;<span class="cstat-no" title="statement not covered" >d</span>^=c;<span class="cstat-no" title="statement not covered" >d</span>=d&lt;&lt;13|d&gt;&gt;&gt;19;<span class="cstat-no" title="statement not covered" >d</span>=5*d+3864292196}</span>else{<span class="cstat-no" title="statement not covered" >h=l[t];<span class="cstat-no" title="statement not covered" >h</span>=h*p&amp;a|h*f&amp;r;<span class="cstat-no" title="statement not covered" >h</span>=h&lt;&lt;15|h&gt;&gt;&gt;17;<span class="cstat-no" title="statement not covered" >h</span>=h*g&amp;a|h*m&amp;r;<span class="cstat-no" title="statement not covered" >u</span>^=h;<span class="cstat-no" title="statement not covered" >u</span>=u&lt;&lt;13|u&gt;&gt;&gt;19;<span class="cstat-no" title="statement not covered" >u</span>=5*u+3864292196}<span class="cstat-no" title="statement not covered" ></span>c</span></span>=0;<span class="cstat-no" title="statement not covered" >s</span>witch(o){case 3:<span class="cstat-no" title="statement not covered" >c^=e[4*i+2]&lt;&lt;16;c</span>ase 2:<span class="cstat-no" title="statement not covered" >c^=e[4*i+1]&lt;&lt;8;c</span>ase 1:<span class="cstat-no" title="statement not covered" >c^=e[4*i];<span class="cstat-no" title="statement not covered" >c</span>=c*p&amp;a|c*f&amp;r;<span class="cstat-no" title="statement not covered" >c</span>=c&lt;&lt;15|c&gt;&gt;&gt;17;<span class="cstat-no" title="statement not covered" >c</span>=c*g&amp;a|c*m&amp;r;<span class="cstat-no" title="statement not covered" >1</span>&amp;i?d^=c:u^=c}<span class="cstat-no" title="statement not covered" ></span>t</span>his.h1=d;<span class="cstat-no" title="statement not covered" >t</span>his.h2=u}<span class="fstat-no" title="function not covered" ></span>he</span>xdigest(){let t=<span class="cstat-no" title="statement not covered" >this.h1,</span>e=<span class="cstat-no" title="statement not covered" >this.h2;<span class="cstat-no" title="statement not covered" ></span>t^=e&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >t</span>=3981806797*t&amp;a|36045*t&amp;r;<span class="cstat-no" title="statement not covered" >e</span>=4283543511*e&amp;a|(2950163797*(e&lt;&lt;16|t&gt;&gt;&gt;16)&amp;a)&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>^=e&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >t</span>=444984403*t&amp;a|60499*t&amp;r;<span class="cstat-no" title="statement not covered" >e</span>=3301882366*e&amp;a|(3120437893*(e&lt;&lt;16|t&gt;&gt;&gt;16)&amp;a)&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>^=e&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >r</span>eturn(t&gt;&gt;&gt;0).toString(16).padStart(8,"0")+(e&gt;&gt;&gt;0).toString(16).padStart(8,"0")}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.FontLoader=e.FontFaceObject=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(10);<span class="cstat-no" title="statement not covered" ></span>e.FontLoader=class FontLoader{#kt=<span class="cstat-no" title="statement not covered" >new Set;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({ownerDocument:t=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.document,</span>styleElement:e=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this._document=t;<span class="cstat-no" title="statement not covered" >t</span>his.nativeFontFaces=new Set;<span class="cstat-no" title="statement not covered" >t</span>his.styleElement=null;<span class="cstat-no" title="statement not covered" >t</span>his.loadingRequests=[];<span class="cstat-no" title="statement not covered" >t</span>his.loadTestFontId=0}<span class="fstat-no" title="function not covered" ></span>ad</span>dNativeFontFace(t){<span class="cstat-no" title="statement not covered" >this.nativeFontFaces.add(t);<span class="cstat-no" title="statement not covered" >t</span>his._document.fonts.add(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveNativeFontFace(t){<span class="cstat-no" title="statement not covered" >this.nativeFontFaces.delete(t);<span class="cstat-no" title="statement not covered" >t</span>his._document.fonts.delete(t)}<span class="fstat-no" title="function not covered" ></span>in</span>sertRule(t){<span class="cstat-no" title="statement not covered" >if(!this.styleElement){<span class="cstat-no" title="statement not covered" >this.styleElement=this._document.createElement("style");<span class="cstat-no" title="statement not covered" >t</span>his._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement)}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >this.styleElement.sheet;<span class="cstat-no" title="statement not covered" ></span>e.insertRule(t,e.cssRules.length)}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >for(const t of this.nativeFontFaces)<span class="cstat-no" title="statement not covered" >this._document.fonts.delete(t);<span class="cstat-no" title="statement not covered" >t</span></span>his.nativeFontFaces.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#kt.clear();<span class="cstat-no" title="statement not covered" >i</span>f(this.styleElement){<span class="cstat-no" title="statement not covered" >this.styleElement.remove();<span class="cstat-no" title="statement not covered" >t</span>his.styleElement=null}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync loadSystemFont(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;!this.#kt.has(t.loadedName)){<span class="cstat-no" title="statement not covered" >(0,n.assert)(!this.disableFontFace,"loadSystemFont shouldn't be called when `disableFontFace` is set.");<span class="cstat-no" title="statement not covered" >i</span>f(this.isFontLoadingAPISupported){const{loadedName:e,src:s,style:i}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >new FontFace(e,s,i);<span class="cstat-no" title="statement not covered" ></span>this.addNativeFontFace(a);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >await a.load();<span class="cstat-no" title="statement not covered" >t</span>his.#kt.add(e)}</span>catch{<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`);<span class="cstat-no" title="statement not covered" >t</span>his.removeNativeFontFace(a)}</span>}</span>else<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Not implemented: loadSystemFont without the Font Loading API.")}</span></span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync bind(t){<span class="cstat-no" title="statement not covered" >if(t.attached||t.missingFile&amp;&amp;!t.systemFontInfo)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.attached=!0;<span class="cstat-no" title="statement not covered" >i</span>f(t.systemFontInfo){<span class="cstat-no" title="statement not covered" >await this.loadSystemFont(t.systemFontInfo);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.isFontLoadingAPISupported){const e=<span class="cstat-no" title="statement not covered" >t.createNativeFontFace();<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >this.addNativeFontFace(e);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >await e.loaded}</span>catch(s){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Failed to load font '${e.family}': '${s}'.`);<span class="cstat-no" title="statement not covered" >t</span>.disableFontFace=!0;<span class="cstat-no" title="statement not covered" >t</span>hrow s}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >t.createFontFaceRule();<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >this.insertRule(e);<span class="cstat-no" title="statement not covered" >i</span>f(this.isSyncFontLoadingSupported)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >a</span></span>wait new Promise((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >this._queueLoadingCallback(e);<span class="cstat-no" title="statement not covered" ></span>this._prepareFontLoadEvent(t,s)}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isFontLoadingAPISupported(){const t=<span class="cstat-no" title="statement not covered" >!!this._document?.fonts;<span class="cstat-no" title="statement not covered" ></span>return(0,n.shadow)(this,"isFontLoadingAPISupported",t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isSyncFontLoadingSupported(){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>(i.isNodeJS||"undefined"!=typeof navigator&amp;&amp;/Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent))&amp;&amp;(t=!0);<span class="cstat-no" title="statement not covered" >r</span>eturn(0,n.shadow)(this,"isSyncFontLoadingSupported",t)}<span class="fstat-no" title="function not covered" ></span>_q</span>ueueLoadingCallback(t){const{loadingRequests:e}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >{done:!1,complete:function <span class="fstat-no" title="function not covered" >completeRequest(</span>){<span class="cstat-no" title="statement not covered" >(0,n.assert)(!s.done,"completeRequest() cannot be called twice.");<span class="cstat-no" title="statement not covered" >s</span>.done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(;e.length&gt;0&amp;&amp;e[0].done;){const t=<span class="cstat-no" title="statement not covered" >e.shift();<span class="cstat-no" title="statement not covered" ></span>setTimeout(t.callback,0)}</span>}</span>,callback:t};<span class="cstat-no" title="statement not covered" ></span>e.push(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>t _loadTestFont(){const t=<span class="cstat-no" title="statement not covered" >atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");<span class="cstat-no" title="statement not covered" ></span>return(0,n.shadow)(this,"_loadTestFont",t)}<span class="fstat-no" title="function not covered" ></span>_p</span>repareFontLoadEvent(t,e){function <span class="fstat-no" title="function not covered" >int32(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.charCodeAt(e)&lt;&lt;24|t.charCodeAt(e+1)&lt;&lt;16|t.charCodeAt(e+2)&lt;&lt;8|255&amp;t.charCodeAt(e+3)}</span>function <span class="fstat-no" title="function not covered" >spliceString(</span>t,e,s,n){<span class="cstat-no" title="statement not covered" >return t.substring(0,e)+n+t.substring(e+s)}</span>let s,i;const a=<span class="cstat-no" title="statement not covered" >this._document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>a.width=1;<span class="cstat-no" title="statement not covered" >a</span>.height=1;c</span>onst r=<span class="cstat-no" title="statement not covered" >a.getContext("2d");</span>let o=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >`lt${Date.now()}${this.loadTestFontId++}`;</span>let c=<span class="cstat-no" title="statement not covered" >this._loadTestFont;<span class="cstat-no" title="statement not covered" ></span>c=spliceString(c,976,l.length,l);c</span>onst h=<span class="cstat-no" title="statement not covered" >1482184792;</span>let d=<span class="cstat-no" title="statement not covered" >int32(c,16);<span class="cstat-no" title="statement not covered" ></span>for(s=0,i=l.length-3;s&lt;i;s+=4)<span class="cstat-no" title="statement not covered" >d=d-h+int32(l,s)|0;<span class="cstat-no" title="statement not covered" >s</span></span>&lt;l.length&amp;&amp;(d=d-h+int32(l+"XXX",s)|0);<span class="cstat-no" title="statement not covered" >c</span>=spliceString(c,16,4,(0,n.string32)(d));c</span>onst u=<span class="cstat-no" title="statement not covered" >`@font-face {font-family:"${l}";src:${`url(data:font/opentype;base64,${btoa(c)});`}}`;<span class="cstat-no" title="statement not covered" ></span>this.insertRule(u);c</span>onst p=<span class="cstat-no" title="statement not covered" >this._document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>p.style.visibility="hidden";<span class="cstat-no" title="statement not covered" >p</span>.style.width=p.style.height="10px";<span class="cstat-no" title="statement not covered" >p</span>.style.position="absolute";<span class="cstat-no" title="statement not covered" >p</span>.style.top=p.style.left="0px";<span class="cstat-no" title="statement not covered" >f</span>or(const e of[t.loadedName,l]){const t=<span class="cstat-no" title="statement not covered" >this._document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>t.textContent="Hi";<span class="cstat-no" title="statement not covered" >t</span>.style.fontFamily=e;<span class="cstat-no" title="statement not covered" >p</span>.append(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._document.body.append(p);<span class="cstat-no" title="statement not covered" >!</span>function <span class="fstat-no" title="function not covered" >isFontReady(</span>t,e){<span class="cstat-no" title="statement not covered" >if(++o&gt;30){<span class="cstat-no" title="statement not covered" >(0,n.warn)("Load test font never loaded.");<span class="cstat-no" title="statement not covered" >e</span>();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>.font="30px "+t;<span class="cstat-no" title="statement not covered" >r</span>.fillText(".",0,20);<span class="cstat-no" title="statement not covered" >r</span>.getImageData(0,0,1,1).data[3]&gt;0?e():setTimeout(isFontReady.bind(null,t,e))}</span>(l,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >p.remove();<span class="cstat-no" title="statement not covered" >e</span>.complete()}</span>))}</span>};<span class="cstat-no" title="statement not covered" >e</span>.FontFaceObject=class FontFaceObject{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{isEvalSupported:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>disableFontFace:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>ignoreErrors:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>inspectFont:i=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this.compiledGlyphs=Object.create(null);<span class="cstat-no" title="statement not covered" >f</span>or(const e in t)<span class="cstat-no" title="statement not covered" >this[e]=t[e];<span class="cstat-no" title="statement not covered" >t</span></span>his.isEvalSupported=!1!==e;<span class="cstat-no" title="statement not covered" >t</span>his.disableFontFace=!0===s;<span class="cstat-no" title="statement not covered" >t</span>his.ignoreErrors=!0===n;<span class="cstat-no" title="statement not covered" >t</span>his._inspectFont=i}<span class="fstat-no" title="function not covered" ></span>cr</span>eateNativeFontFace(){<span class="cstat-no" title="statement not covered" >if(!this.data||this.disableFontFace)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et t;<span class="cstat-no" title="statement not covered" >if(this.cssFontInfo){const e=<span class="cstat-no" title="statement not covered" >{weight:this.cssFontInfo.fontWeight};<span class="cstat-no" title="statement not covered" ></span>this.cssFontInfo.italicAngle&amp;&amp;(e.style=`oblique ${this.cssFontInfo.italicAngle}deg`);<span class="cstat-no" title="statement not covered" >t</span>=new FontFace(this.cssFontInfo.fontFamily,this.data,e)}</span>else <span class="cstat-no" title="statement not covered" >t=new FontFace(this.loadedName,this.data,{});<span class="cstat-no" title="statement not covered" >t</span></span>his._inspectFont?.(this);<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>cr</span>eateFontFaceRule(){<span class="cstat-no" title="statement not covered" >if(!this.data||this.disableFontFace)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >(0,n.bytesToString)(this.data),</span>e=<span class="cstat-no" title="statement not covered" >`url(data:${this.mimetype};base64,${btoa(t)});`;</span>let s;<span class="cstat-no" title="statement not covered" >if(this.cssFontInfo){let t=<span class="cstat-no" title="statement not covered" >`font-weight: ${this.cssFontInfo.fontWeight};`;<span class="cstat-no" title="statement not covered" ></span>this.cssFontInfo.italicAngle&amp;&amp;(t+=`font-style: oblique ${this.cssFontInfo.italicAngle}deg;`);<span class="cstat-no" title="statement not covered" >s</span>=`@font-face {font-family:"${this.cssFontInfo.fontFamily}";${t}src:${e}}`}</span>else <span class="cstat-no" title="statement not covered" >s=`@font-face {font-family:"${this.loadedName}";src:${e}}`;<span class="cstat-no" title="statement not covered" >t</span></span>his._inspectFont?.(this,e);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tPathGenerator(t,e){<span class="cstat-no" title="statement not covered" >if(void 0!==this.compiledGlyphs[e])<span class="cstat-no" title="statement not covered" >return this.compiledGlyphs[e];l</span></span>et s;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >s=t.get(this.loadedName+"_path_"+e)}</span>catch(t){<span class="cstat-no" title="statement not covered" >if(!this.ignoreErrors)<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >(</span></span>0,n.warn)(`getPathGenerator - ignoring character: "${t}".`);<span class="cstat-no" title="statement not covered" >r</span>eturn this.compiledGlyphs[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.isEvalSupported&amp;&amp;n.FeatureTest.isEvalSupported){const t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of s){const s=<span class="cstat-no" title="statement not covered" >void 0!==e.args?e.args.join(","):"";<span class="cstat-no" title="statement not covered" ></span>t.push("c.",e.cmd,"(",s,");\n")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.compiledGlyphs[e]=new Function("c","size",t.join(""))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.compiledGlyphs[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(const n of s){<span class="cstat-no" title="statement not covered" >"scale"===n.cmd&amp;&amp;(n.args=[e,-e]);<span class="cstat-no" title="statement not covered" >t</span>[n.cmd].apply(t,n.args)}</span>}</span>}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.isNodeJS=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >!("object"!=typeof process||process+""!="[object process]"||process.versions.nw||process.versions.electron&amp;&amp;process.type&amp;&amp;"browser"!==process.type);<span class="cstat-no" title="statement not covered" ></span>e.isNodeJS=s}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.CanvasGraphics=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(6),</span>a=<span class="cstat-no" title="statement not covered" >s(12),</span>r=<span class="cstat-no" title="statement not covered" >s(13),</span>o=<span class="cstat-no" title="statement not covered" >s(10);</span>const l=<span class="cstat-no" title="statement not covered" >4096,</span>c=<span class="cstat-no" title="statement not covered" >16;</span>class CachedCanvases{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.canvasFactory=t;<span class="cstat-no" title="statement not covered" >t</span>his.cache=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCanvas(t,e,s){let n;<span class="cstat-no" title="statement not covered" >if(void 0!==this.cache[t]){<span class="cstat-no" title="statement not covered" >n=this.cache[t];<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory.reset(n,e,s)}</span>else{<span class="cstat-no" title="statement not covered" >n=this.canvasFactory.create(e,s);<span class="cstat-no" title="statement not covered" >t</span>his.cache[t]=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>de</span>lete(t){<span class="cstat-no" title="statement not covered" >delete this.cache[t]}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >for(const t in this.cache){const e=<span class="cstat-no" title="statement not covered" >this.cache[t];<span class="cstat-no" title="statement not covered" ></span>this.canvasFactory.destroy(e);<span class="cstat-no" title="statement not covered" >d</span>elete this.cache[t]}</span>}</span>}function <span class="fstat-no" title="function not covered" >drawImageAtIntegerCoords(</span>t,e,s,n,a,r,o,l,c,h){const[d,u,p,g,f,m]=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(t);<span class="cstat-no" title="statement not covered" ></span>if(0===u&amp;&amp;0===p){const i=<span class="cstat-no" title="statement not covered" >o*d+f,</span>b=<span class="cstat-no" title="statement not covered" >Math.round(i),</span>A=<span class="cstat-no" title="statement not covered" >l*g+m,</span>_=<span class="cstat-no" title="statement not covered" >Math.round(A),</span>y=<span class="cstat-no" title="statement not covered" >(o+c)*d+f,</span>v=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(y)-b)||1,</span>S=<span class="cstat-no" title="statement not covered" >(l+h)*g+m,</span>E=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(S)-_)||1;<span class="cstat-no" title="statement not covered" ></span>t.setTransform(Math.sign(d),0,0,Math.sign(g),b,_);<span class="cstat-no" title="statement not covered" >t</span>.drawImage(e,s,n,a,r,0,0,v,E);<span class="cstat-no" title="statement not covered" >t</span>.setTransform(d,u,p,g,f,m);<span class="cstat-no" title="statement not covered" >r</span>eturn[v,E]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===d&amp;&amp;0===g){const i=<span class="cstat-no" title="statement not covered" >l*p+f,</span>b=<span class="cstat-no" title="statement not covered" >Math.round(i),</span>A=<span class="cstat-no" title="statement not covered" >o*u+m,</span>_=<span class="cstat-no" title="statement not covered" >Math.round(A),</span>y=<span class="cstat-no" title="statement not covered" >(l+h)*p+f,</span>v=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(y)-b)||1,</span>S=<span class="cstat-no" title="statement not covered" >(o+c)*u+m,</span>E=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(S)-_)||1;<span class="cstat-no" title="statement not covered" ></span>t.setTransform(0,Math.sign(u),Math.sign(p),0,b,_);<span class="cstat-no" title="statement not covered" >t</span>.drawImage(e,s,n,a,r,0,0,E,v);<span class="cstat-no" title="statement not covered" >t</span>.setTransform(d,u,p,g,f,m);<span class="cstat-no" title="statement not covered" >r</span>eturn[E,v]}<span class="cstat-no" title="statement not covered" ></span>t</span>.drawImage(e,s,n,a,r,o,l,c,h);<span class="cstat-no" title="statement not covered" >r</span>eturn[Math.hypot(d,u)*c,Math.hypot(p,g)*h]}</span>class CanvasExtraState{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.alphaIsShape=!1;<span class="cstat-no" title="statement not covered" >t</span>his.fontSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.fontSizeScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.fontMatrix=n.FONT_IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.leading=0;<span class="cstat-no" title="statement not covered" >t</span>his.x=0;<span class="cstat-no" title="statement not covered" >t</span>his.y=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineY=0;<span class="cstat-no" title="statement not covered" >t</span>his.charSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.wordSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.textHScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.textRenderingMode=n.TextRenderingMode.FILL;<span class="cstat-no" title="statement not covered" >t</span>his.textRise=0;<span class="cstat-no" title="statement not covered" >t</span>his.fillColor="#000000";<span class="cstat-no" title="statement not covered" >t</span>his.strokeColor="#000000";<span class="cstat-no" title="statement not covered" >t</span>his.patternFill=!1;<span class="cstat-no" title="statement not covered" >t</span>his.fillAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.strokeAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>his.activeSMask=null;<span class="cstat-no" title="statement not covered" >t</span>his.transferMaps="none";<span class="cstat-no" title="statement not covered" >t</span>his.startNewPathAndClipBox([0,0,t,e])}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){const t=<span class="cstat-no" title="statement not covered" >Object.create(this);<span class="cstat-no" title="statement not covered" ></span>t.clipBox=this.clipBox.slice();<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>se</span>tCurrentPoint(t,e){<span class="cstat-no" title="statement not covered" >this.x=t;<span class="cstat-no" title="statement not covered" >t</span>his.y=e}<span class="fstat-no" title="function not covered" ></span>up</span>datePathMinMax(t,e,s){<span class="cstat-no" title="statement not covered" >[e,s]=n.Util.applyTransform([e,s],t);<span class="cstat-no" title="statement not covered" >t</span>his.minX=Math.min(this.minX,e);<span class="cstat-no" title="statement not covered" >t</span>his.minY=Math.min(this.minY,s);<span class="cstat-no" title="statement not covered" >t</span>his.maxX=Math.max(this.maxX,e);<span class="cstat-no" title="statement not covered" >t</span>his.maxY=Math.max(this.maxY,s)}<span class="fstat-no" title="function not covered" ></span>up</span>dateRectMinMax(t,e){const s=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform(e,t),</span>i=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform(e.slice(2),t);<span class="cstat-no" title="statement not covered" ></span>this.minX=Math.min(this.minX,s[0],i[0]);<span class="cstat-no" title="statement not covered" >t</span>his.minY=Math.min(this.minY,s[1],i[1]);<span class="cstat-no" title="statement not covered" >t</span>his.maxX=Math.max(this.maxX,s[0],i[0]);<span class="cstat-no" title="statement not covered" >t</span>his.maxY=Math.max(this.maxY,s[1],i[1])}<span class="fstat-no" title="function not covered" ></span>up</span>dateScalingPathMinMax(t,e){<span class="cstat-no" title="statement not covered" >n.Util.scaleMinMax(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.minX=Math.min(this.minX,e[0]);<span class="cstat-no" title="statement not covered" >t</span>his.maxX=Math.max(this.maxX,e[1]);<span class="cstat-no" title="statement not covered" >t</span>his.minY=Math.min(this.minY,e[2]);<span class="cstat-no" title="statement not covered" >t</span>his.maxY=Math.max(this.maxY,e[3])}<span class="fstat-no" title="function not covered" ></span>up</span>dateCurvePathMinMax(t,e,s,i,a,r,o,l,c,h){const d=<span class="cstat-no" title="statement not covered" >n.Util.bezierBoundingBox(e,s,i,a,r,o,l,c);<span class="cstat-no" title="statement not covered" ></span>if(h){<span class="cstat-no" title="statement not covered" >h[0]=Math.min(h[0],d[0],d[2]);<span class="cstat-no" title="statement not covered" >h</span>[1]=Math.max(h[1],d[0],d[2]);<span class="cstat-no" title="statement not covered" >h</span>[2]=Math.min(h[2],d[1],d[3]);<span class="cstat-no" title="statement not covered" >h</span>[3]=Math.max(h[3],d[1],d[3])}</span>else <span class="cstat-no" title="statement not covered" >this.updateRectMinMax(t,d)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tPathBoundingBox(t=<span class="branch-0 cbranch-no" title="branch not covered" >a.PathType.FILL,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const s=<span class="cstat-no" title="statement not covered" >[this.minX,this.minY,this.maxX,this.maxY];<span class="cstat-no" title="statement not covered" ></span>if(t===a.PathType.STROKE){<span class="cstat-no" title="statement not covered" >e||(0,n.unreachable)("Stroke bounding box must include transform.");c</span>onst t=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale(e),</span>i=<span class="cstat-no" title="statement not covered" >t[0]*this.lineWidth/2,</span>a=<span class="cstat-no" title="statement not covered" >t[1]*this.lineWidth/2;<span class="cstat-no" title="statement not covered" ></span>s[0]-=i;<span class="cstat-no" title="statement not covered" >s</span>[1]-=a;<span class="cstat-no" title="statement not covered" >s</span>[2]+=i;<span class="cstat-no" title="statement not covered" >s</span>[3]+=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>up</span>dateClipFromPath(){const t=<span class="cstat-no" title="statement not covered" >n.Util.intersect(this.clipBox,this.getPathBoundingBox());<span class="cstat-no" title="statement not covered" ></span>this.startNewPathAndClipBox(t||[0,0,0,0])}<span class="fstat-no" title="function not covered" ></span>is</span>EmptyClip(){<span class="cstat-no" title="statement not covered" >return this.minX===1/0}<span class="fstat-no" title="function not covered" ></span>st</span>artNewPathAndClipBox(t){<span class="cstat-no" title="statement not covered" >this.clipBox=t;<span class="cstat-no" title="statement not covered" >t</span>his.minX=1/0;<span class="cstat-no" title="statement not covered" >t</span>his.minY=1/0;<span class="cstat-no" title="statement not covered" >t</span>his.maxX=0;<span class="cstat-no" title="statement not covered" >t</span>his.maxY=0}<span class="fstat-no" title="function not covered" ></span>ge</span>tClippedPathBoundingBox(t=<span class="branch-0 cbranch-no" title="branch not covered" >a.PathType.FILL,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return n.Util.intersect(this.clipBox,this.getPathBoundingBox(t,e))}</span>}function <span class="fstat-no" title="function not covered" >putBinaryImageData(</span>t,e){<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof ImageData&amp;&amp;e instanceof ImageData){<span class="cstat-no" title="statement not covered" >t.putImageData(e,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >e.height,</span>i=<span class="cstat-no" title="statement not covered" >e.width,</span>a=<span class="cstat-no" title="statement not covered" >s%c,</span>r=<span class="cstat-no" title="statement not covered" >(s-a)/c,</span>o=<span class="cstat-no" title="statement not covered" >0===a?r:r+1,</span>l=<span class="cstat-no" title="statement not covered" >t.createImageData(i,c);</span>let h,d=<span class="cstat-no" title="statement not covered" >0;</span>const u=<span class="cstat-no" title="statement not covered" >e.data,</span>p=<span class="cstat-no" title="statement not covered" >l.data;</span>let g,f,m,b;<span class="cstat-no" title="statement not covered" >if(e.kind===n.ImageKind.GRAYSCALE_1BPP){const e=<span class="cstat-no" title="statement not covered" >u.byteLength,</span>s=<span class="cstat-no" title="statement not covered" >new Uint32Array(p.buffer,0,p.byteLength&gt;&gt;2),</span>b=<span class="cstat-no" title="statement not covered" >s.length,</span>A=<span class="cstat-no" title="statement not covered" >i+7&gt;&gt;3,</span>_=<span class="cstat-no" title="statement not covered" >4294967295,</span>y=<span class="cstat-no" title="statement not covered" >n.FeatureTest.isLittleEndian?4278190080:255;<span class="cstat-no" title="statement not covered" ></span>for(g=0;g&lt;o;g++){<span class="cstat-no" title="statement not covered" >m=g&lt;r?c:a;<span class="cstat-no" title="statement not covered" >h</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(f=0;f&lt;m;f++){const t=<span class="cstat-no" title="statement not covered" >e-d;</span>let n=<span class="cstat-no" title="statement not covered" >0;</span>const a=<span class="cstat-no" title="statement not covered" >t&gt;A?i:8*t-7,</span>r=<span class="cstat-no" title="statement not covered" >-8&amp;a;</span>let o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;r;n+=8){<span class="cstat-no" title="statement not covered" >l=u[d++];<span class="cstat-no" title="statement not covered" >s</span>[h++]=128&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=64&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=32&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=16&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=8&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=4&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=2&amp;l?_:y;<span class="cstat-no" title="statement not covered" >s</span>[h++]=1&amp;l?_:y}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;n&lt;a;n++){<span class="cstat-no" title="statement not covered" >if(0===o){<span class="cstat-no" title="statement not covered" >l=u[d++];<span class="cstat-no" title="statement not covered" >o</span>=128}<span class="cstat-no" title="statement not covered" ></span>s</span>[h++]=l&amp;o?_:y;<span class="cstat-no" title="statement not covered" >o</span>&gt;&gt;=1}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;h&lt;b;)<span class="cstat-no" title="statement not covered" >s[h++]=0;<span class="cstat-no" title="statement not covered" >t</span></span>.putImageData(l,0,g*c)}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(e.kind===n.ImageKind.RGBA_32BPP){<span class="cstat-no" title="statement not covered" >f=0;<span class="cstat-no" title="statement not covered" >b</span>=i*c*4;<span class="cstat-no" title="statement not covered" >f</span>or(g=0;g&lt;r;g++){<span class="cstat-no" title="statement not covered" >p.set(u.subarray(d,d+b));<span class="cstat-no" title="statement not covered" >d</span>+=b;<span class="cstat-no" title="statement not covered" >t</span>.putImageData(l,0,f);<span class="cstat-no" title="statement not covered" >f</span>+=c}<span class="cstat-no" title="statement not covered" ></span>i</span>f(g&lt;o){<span class="cstat-no" title="statement not covered" >b=i*a*4;<span class="cstat-no" title="statement not covered" >p</span>.set(u.subarray(d,d+b));<span class="cstat-no" title="statement not covered" >t</span>.putImageData(l,0,f)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(e.kind!==n.ImageKind.RGB_24BPP)<span class="cstat-no" title="statement not covered" >throw new Error(`bad image kind: ${e.kind}`);<span class="cstat-no" title="statement not covered" >m</span></span>=c;<span class="cstat-no" title="statement not covered" >b</span>=i*m;<span class="cstat-no" title="statement not covered" >f</span>or(g=0;g&lt;o;g++){<span class="cstat-no" title="statement not covered" >if(g&gt;=r){<span class="cstat-no" title="statement not covered" >m=a;<span class="cstat-no" title="statement not covered" >b</span>=i*m}<span class="cstat-no" title="statement not covered" ></span>h</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(f=b;f--;){<span class="cstat-no" title="statement not covered" >p[h++]=u[d++];<span class="cstat-no" title="statement not covered" >p</span>[h++]=u[d++];<span class="cstat-no" title="statement not covered" >p</span>[h++]=u[d++];<span class="cstat-no" title="statement not covered" >p</span>[h++]=255}<span class="cstat-no" title="statement not covered" ></span>t</span>.putImageData(l,0,g*c)}</span>}</span>}</span></span>function <span class="fstat-no" title="function not covered" >putBinaryImageMask(</span>t,e){<span class="cstat-no" title="statement not covered" >if(e.bitmap){<span class="cstat-no" title="statement not covered" >t.drawImage(e.bitmap,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >e.height,</span>n=<span class="cstat-no" title="statement not covered" >e.width,</span>i=<span class="cstat-no" title="statement not covered" >s%c,</span>a=<span class="cstat-no" title="statement not covered" >(s-i)/c,</span>o=<span class="cstat-no" title="statement not covered" >0===i?a:a+1,</span>l=<span class="cstat-no" title="statement not covered" >t.createImageData(n,c);</span>let h=<span class="cstat-no" title="statement not covered" >0;</span>const d=<span class="cstat-no" title="statement not covered" >e.data,</span>u=<span class="cstat-no" title="statement not covered" >l.data;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;e++){const s=<span class="cstat-no" title="statement not covered" >e&lt;a?c:i;<span class="cstat-no" title="statement not covered" ></span>({srcPos:h}=(0,r.convertBlackAndWhiteToRGBA)({src:d,srcPos:h,dest:u,width:n,height:s,nonBlackColor:0}));<span class="cstat-no" title="statement not covered" >t</span>.putImageData(l,0,e*c)}</span>}</span>function <span class="fstat-no" title="function not covered" >copyCtxState(</span>t,e){const s=<span class="cstat-no" title="statement not covered" >["strokeStyle","fillStyle","fillRule","globalAlpha","lineWidth","lineCap","lineJoin","miterLimit","globalCompositeOperation","font","filter"];<span class="cstat-no" title="statement not covered" ></span>for(const n of s)<span class="cstat-no" title="statement not covered" >void 0!==t[n]&amp;&amp;(e[n]=t[n]);<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==t.setLineDash){<span class="cstat-no" title="statement not covered" >e.setLineDash(t.getLineDash());<span class="cstat-no" title="statement not covered" >e</span>.lineDashOffset=t.lineDashOffset}</span>}</span>function <span class="fstat-no" title="function not covered" >resetCtxToDefault(</span>t){<span class="cstat-no" title="statement not covered" >t.strokeStyle=t.fillStyle="#000000";<span class="cstat-no" title="statement not covered" >t</span>.fillRule="nonzero";<span class="cstat-no" title="statement not covered" >t</span>.globalAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>.lineCap="butt";<span class="cstat-no" title="statement not covered" >t</span>.lineJoin="miter";<span class="cstat-no" title="statement not covered" >t</span>.miterLimit=10;<span class="cstat-no" title="statement not covered" >t</span>.globalCompositeOperation="source-over";<span class="cstat-no" title="statement not covered" >t</span>.font="10px sans-serif";<span class="cstat-no" title="statement not covered" >i</span>f(void 0!==t.setLineDash){<span class="cstat-no" title="statement not covered" >t.setLineDash([]);<span class="cstat-no" title="statement not covered" >t</span>.lineDashOffset=0}<span class="cstat-no" title="statement not covered" ></span>o</span>.isNodeJS||(t.filter="none")}</span>function <span class="fstat-no" title="function not covered" >composeSMaskBackdrop(</span>t,e,s,n){const i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >3;</span>a&lt;i;a+=4){const i=<span class="cstat-no" title="statement not covered" >t[a];<span class="cstat-no" title="statement not covered" ></span>if(0===i){<span class="cstat-no" title="statement not covered" >t[a-3]=e;<span class="cstat-no" title="statement not covered" >t</span>[a-2]=s;<span class="cstat-no" title="statement not covered" >t</span>[a-1]=n}</span>else <span class="cstat-no" title="statement not covered" >if(i&lt;255){const r=<span class="cstat-no" title="statement not covered" >255-i;<span class="cstat-no" title="statement not covered" ></span>t[a-3]=t[a-3]*i+e*r&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>[a-2]=t[a-2]*i+s*r&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>[a-1]=t[a-1]*i+n*r&gt;&gt;8}</span>}</span></span>}</span>function <span class="fstat-no" title="function not covered" >composeSMaskAlpha(</span>t,e,s){const n=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >3;</span>i&lt;n;i+=4){const n=<span class="cstat-no" title="statement not covered" >s?s[t[i]]:t[i];<span class="cstat-no" title="statement not covered" ></span>e[i]=e[i]*n*.00392156862745098|0}</span>}</span>function <span class="fstat-no" title="function not covered" >composeSMaskLuminosity(</span>t,e,s){const n=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >3;</span>i&lt;n;i+=4){const n=<span class="cstat-no" title="statement not covered" >77*t[i-3]+152*t[i-2]+28*t[i-1];<span class="cstat-no" title="statement not covered" ></span>e[i]=s?e[i]*s[n&gt;&gt;8]&gt;&gt;8:e[i]*n&gt;&gt;16}</span>}</span>function <span class="fstat-no" title="function not covered" >composeSMask(</span>t,e,s,n){const i=<span class="cstat-no" title="statement not covered" >n[0],</span>a=<span class="cstat-no" title="statement not covered" >n[1],</span>r=<span class="cstat-no" title="statement not covered" >n[2]-i,</span>o=<span class="cstat-no" title="statement not covered" >n[3]-a;<span class="cstat-no" title="statement not covered" ></span>if(0!==r&amp;&amp;0!==o){<span class="cstat-no" title="statement not covered" >!function <span class="fstat-no" title="function not covered" >genericComposeSMask(</span>t,e,s,n,i,a,r,o,l,c,h){const d=<span class="cstat-no" title="statement not covered" >!!a,</span>u=<span class="cstat-no" title="statement not covered" >d?a[0]:0,</span>p=<span class="cstat-no" title="statement not covered" >d?a[1]:0,</span>g=<span class="cstat-no" title="statement not covered" >d?a[2]:0;</span>let f;<span class="cstat-no" title="statement not covered" >f="Luminosity"===i?composeSMaskLuminosity:composeSMaskAlpha;c</span>onst m=<span class="cstat-no" title="statement not covered" >Math.min(n,Math.ceil(1048576/s));<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n;i+=m){const a=<span class="cstat-no" title="statement not covered" >Math.min(m,n-i),</span>b=<span class="cstat-no" title="statement not covered" >t.getImageData(o-c,i+(l-h),s,a),</span>A=<span class="cstat-no" title="statement not covered" >e.getImageData(o,i+l,s,a);<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;composeSMaskBackdrop(b.data,u,p,g);<span class="cstat-no" title="statement not covered" >f</span>(b.data,A.data,r);<span class="cstat-no" title="statement not covered" >e</span>.putImageData(A,o,i+l)}</span>}</span>(e.context,s,r,o,e.subtype,e.backdrop,e.transferMap,i,a,e.offsetX,e.offsetY);<span class="cstat-no" title="statement not covered" >t</span>.save();<span class="cstat-no" title="statement not covered" >t</span>.globalAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>.globalCompositeOperation="source-over";<span class="cstat-no" title="statement not covered" >t</span>.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >t</span>.drawImage(s.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>.restore()}</span>}</span>function <span class="fstat-no" title="function not covered" >getImageSmoothingEnabled(</span>t,e){const s=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale(t);<span class="cstat-no" title="statement not covered" ></span>s[0]=Math.fround(s[0]);<span class="cstat-no" title="statement not covered" >s</span>[1]=Math.fround(s[1]);c</span>onst a=<span class="cstat-no" title="statement not covered" >Math.fround((globalThis.devicePixelRatio||1)*i.PixelsPerInch.PDF_TO_CSS_UNITS);<span class="cstat-no" title="statement not covered" ></span>return void 0!==e?e:s[0]&lt;=a||s[1]&lt;=a}</span>const h=<span class="cstat-no" title="statement not covered" >["butt","round","square"],</span>d=<span class="cstat-no" title="statement not covered" >["miter","round","bevel"],</span>u=<span class="cstat-no" title="statement not covered" >{},</span>p=<span class="cstat-no" title="statement not covered" >{};</span>class CanvasGraphics{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s,n,i,{optionalContentConfig:a,markedContentStack:r=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>,o,l){<span class="cstat-no" title="statement not covered" >this.ctx=t;<span class="cstat-no" title="statement not covered" >t</span>his.current=new CanvasExtraState(this.ctx.canvas.width,this.ctx.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.stateStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his.pendingEOFill=!1;<span class="cstat-no" title="statement not covered" >t</span>his.res=null;<span class="cstat-no" title="statement not covered" >t</span>his.xobjs=null;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=e;<span class="cstat-no" title="statement not covered" >t</span>his.objs=s;<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory=n;<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory=i;<span class="cstat-no" title="statement not covered" >t</span>his.groupStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.processingType3=null;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=null;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransformStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.groupLevel=0;<span class="cstat-no" title="statement not covered" >t</span>his.smaskStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.smaskCounter=0;<span class="cstat-no" title="statement not covered" >t</span>his.tempSMask=null;<span class="cstat-no" title="statement not covered" >t</span>his.suspendedCtx=null;<span class="cstat-no" title="statement not covered" >t</span>his.contentVisible=!0;<span class="cstat-no" title="statement not covered" >t</span>his.markedContentStack=r||[];<span class="cstat-no" title="statement not covered" >t</span>his.optionalContentConfig=a;<span class="cstat-no" title="statement not covered" >t</span>his.cachedCanvases=new CachedCanvases(this.canvasFactory);<span class="cstat-no" title="statement not covered" >t</span>his.cachedPatterns=new Map;<span class="cstat-no" title="statement not covered" >t</span>his.annotationCanvasMap=o;<span class="cstat-no" title="statement not covered" >t</span>his.viewportScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleX=1;<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleY=1;<span class="cstat-no" title="statement not covered" >t</span>his.pageColors=l;<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking=[-1,0];<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null;<span class="cstat-no" title="statement not covered" >t</span>his._cachedBitmapsMap=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>tObject(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return"string"==typeof t?t.startsWith("g_")?this.commonObjs.get(t):this.objs.get(t):e}<span class="fstat-no" title="function not covered" ></span>be</span>ginDrawing({transform:t,viewport:e,transparency:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>background:n=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){const a=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.width,</span>r=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.height,</span>o=<span class="cstat-no" title="statement not covered" >this.ctx.fillStyle;<span class="cstat-no" title="statement not covered" ></span>this.ctx.fillStyle=n||"#ffffff";<span class="cstat-no" title="statement not covered" >t</span>his.ctx.fillRect(0,0,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.fillStyle=o;<span class="cstat-no" title="statement not covered" >i</span>f(s){const t=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("transparent",a,r);<span class="cstat-no" title="statement not covered" ></span>this.compositeCtx=this.ctx;<span class="cstat-no" title="statement not covered" >t</span>his.transparentCanvas=t.canvas;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=t.context;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.transform(...(0,i.getCurrentTransform)(this.compositeCtx))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >r</span>esetCtxToDefault(this.ctx);<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >this.ctx.transform(...t);<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleX=t[0];<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleY=t[0]}<span class="cstat-no" title="statement not covered" ></span>t</span>his.ctx.transform(...e.transform);<span class="cstat-no" title="statement not covered" >t</span>his.viewportScale=e.scale;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=(0,i.getCurrentTransform)(this.ctx)}<span class="fstat-no" title="function not covered" ></span>ex</span>ecuteOperatorList(t,e,s,i){const a=<span class="cstat-no" title="statement not covered" >t.argsArray,</span>r=<span class="cstat-no" title="statement not covered" >t.fnArray;</span>let o=<span class="cstat-no" title="statement not covered" >e||0;</span>const l=<span class="cstat-no" title="statement not covered" >a.length;<span class="cstat-no" title="statement not covered" ></span>if(l===o)<span class="cstat-no" title="statement not covered" >return o;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >l-o&gt;10&amp;&amp;"function"==typeof s,</span>h=<span class="cstat-no" title="statement not covered" >c?Date.now()+15:0;</span>let d=<span class="cstat-no" title="statement not covered" >0;</span>const u=<span class="cstat-no" title="statement not covered" >this.commonObjs,</span>p=<span class="cstat-no" title="statement not covered" >this.objs;</span>let g;<span class="cstat-no" title="statement not covered" >for(;;){<span class="cstat-no" title="statement not covered" >if(void 0!==i&amp;&amp;o===i.nextBreakPoint){<span class="cstat-no" title="statement not covered" >i.breakIt(o,s);<span class="cstat-no" title="statement not covered" >r</span>eturn o}<span class="cstat-no" title="statement not covered" ></span>g</span>=r[o];<span class="cstat-no" title="statement not covered" >i</span>f(g!==n.OPS.dependency)<span class="cstat-no" title="statement not covered" >this[g].apply(this,a[o]);e</span>lse <span class="cstat-no" title="statement not covered" >for(const t of a[o]){const e=<span class="cstat-no" title="statement not covered" >t.startsWith("g_")?u:p;<span class="cstat-no" title="statement not covered" ></span>if(!e.has(t)){<span class="cstat-no" title="statement not covered" >e.get(t,s);<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>}<span class="cstat-no" title="statement not covered" ></span>o</span></span>++;<span class="cstat-no" title="statement not covered" >i</span>f(o===l)<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >i</span></span>f(c&amp;&amp;++d&gt;10){<span class="cstat-no" title="statement not covered" >if(Date.now()&gt;h){<span class="cstat-no" title="statement not covered" >s();<span class="cstat-no" title="statement not covered" >r</span>eturn o}<span class="cstat-no" title="statement not covered" ></span>d</span>=0}</span>}</span>}</span>#Mt(){<span class="cstat-no" title="statement not covered" >for(;this.stateStack.length||this.inSMaskMode;)<span class="cstat-no" title="statement not covered" >this.restore();<span class="cstat-no" title="statement not covered" >t</span></span>his.ctx.restore();<span class="cstat-no" title="statement not covered" >i</span>f(this.transparentCanvas){<span class="cstat-no" title="statement not covered" >this.ctx=this.compositeCtx;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.drawImage(this.transparentCanvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span>his.transparentCanvas=null}</span>}<span class="fstat-no" title="function not covered" ></span>en</span>dDrawing(){<span class="cstat-no" title="statement not covered" >this.#Mt();<span class="cstat-no" title="statement not covered" >t</span>his.cachedCanvases.clear();<span class="cstat-no" title="statement not covered" >t</span>his.cachedPatterns.clear();<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._cachedBitmapsMap.values()){<span class="cstat-no" title="statement not covered" >for(const e of t.values())<span class="cstat-no" title="statement not covered" >"undefined"!=typeof HTMLCanvasElement&amp;&amp;e instanceof HTMLCanvasElement&amp;&amp;(e.width=e.height=0);<span class="cstat-no" title="statement not covered" >t</span></span>.clear()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._cachedBitmapsMap.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#Rt()}</span>#Rt(){<span class="cstat-no" title="statement not covered" >if(this.pageColors){const t=<span class="cstat-no" title="statement not covered" >this.filterFactory.addHCMFilter(this.pageColors.foreground,this.pageColors.background);<span class="cstat-no" title="statement not covered" ></span>if("none"!==t){const e=<span class="cstat-no" title="statement not covered" >this.ctx.filter;<span class="cstat-no" title="statement not covered" ></span>this.ctx.filter=t;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.drawImage(this.ctx.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.filter=e}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>caleImage(t,e){const s=<span class="cstat-no" title="statement not covered" >t.width,</span>n=<span class="cstat-no" title="statement not covered" >t.height;</span>let i,a,r=<span class="cstat-no" title="statement not covered" >Math.max(Math.hypot(e[0],e[1]),1),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(Math.hypot(e[2],e[3]),1),</span>l=<span class="cstat-no" title="statement not covered" >s,</span>c=<span class="cstat-no" title="statement not covered" >n,</span>h=<span class="cstat-no" title="statement not covered" >"prescale1";<span class="cstat-no" title="statement not covered" ></span>for(;r&gt;2&amp;&amp;l&gt;1||o&gt;2&amp;&amp;c&gt;1;){let e=<span class="cstat-no" title="statement not covered" >l,</span>s=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>if(r&gt;2&amp;&amp;l&gt;1){<span class="cstat-no" title="statement not covered" >e=l&gt;=16384?Math.floor(l/2)-1||1:Math.ceil(l/2);<span class="cstat-no" title="statement not covered" >r</span>/=l/e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o&gt;2&amp;&amp;c&gt;1){<span class="cstat-no" title="statement not covered" >s=c&gt;=16384?Math.floor(c/2)-1||1:Math.ceil(c)/2;<span class="cstat-no" title="statement not covered" >o</span>/=c/s}<span class="cstat-no" title="statement not covered" ></span>i</span>=this.cachedCanvases.getCanvas(h,e,s);<span class="cstat-no" title="statement not covered" >a</span>=i.context;<span class="cstat-no" title="statement not covered" >a</span>.clearRect(0,0,e,s);<span class="cstat-no" title="statement not covered" >a</span>.drawImage(t,0,0,l,c,0,0,e,s);<span class="cstat-no" title="statement not covered" >t</span>=i.canvas;<span class="cstat-no" title="statement not covered" >l</span>=e;<span class="cstat-no" title="statement not covered" >c</span>=s;<span class="cstat-no" title="statement not covered" >h</span>="prescale1"===h?"prescale2":"prescale1"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{img:t,paintWidth:l,paintHeight:c}}<span class="fstat-no" title="function not covered" ></span>_c</span>reateMaskCanvas(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>{width:s,height:r}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >this.current.fillColor,</span>l=<span class="cstat-no" title="statement not covered" >this.current.patternFill,</span>c=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(e);</span>let h,d,u,p;<span class="cstat-no" title="statement not covered" >if((t.bitmap||t.data)&amp;&amp;t.count&gt;1){const e=<span class="cstat-no" title="statement not covered" >t.bitmap||t.data.buffer;<span class="cstat-no" title="statement not covered" ></span>d=JSON.stringify(l?c:[c.slice(0,4),o]);<span class="cstat-no" title="statement not covered" >h</span>=this._cachedBitmapsMap.get(e);<span class="cstat-no" title="statement not covered" >i</span>f(!h){<span class="cstat-no" title="statement not covered" >h=new Map;<span class="cstat-no" title="statement not covered" >t</span>his._cachedBitmapsMap.set(e,h)}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >h.get(d);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!l){<span class="cstat-no" title="statement not covered" >return{canvas:s,offsetX:Math.round(Math.min(c[0],c[2])+c[4]),offsetY:Math.round(Math.min(c[1],c[3])+c[5])}}<span class="cstat-no" title="statement not covered" ></span>u</span>=s}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!u){<span class="cstat-no" title="statement not covered" >p=this.cachedCanvases.getCanvas("maskCanvas",s,r);<span class="cstat-no" title="statement not covered" >p</span>utBinaryImageMask(p.context,t)}</span>l</span>et g=<span class="cstat-no" title="statement not covered" >n.Util.transform(c,[1/s,0,0,-1/r,0,0]);<span class="cstat-no" title="statement not covered" ></span>g=n.Util.transform(g,[1,0,0,1,0,-r]);c</span>onst f=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform([0,0],g),</span>m=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform([s,r],g),</span>b=<span class="cstat-no" title="statement not covered" >n.Util.normalizeRect([f[0],f[1],m[0],m[1]]),</span>A=<span class="cstat-no" title="statement not covered" >Math.round(b[2]-b[0])||1,</span>_=<span class="cstat-no" title="statement not covered" >Math.round(b[3]-b[1])||1,</span>y=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("fillCanvas",A,_),</span>v=<span class="cstat-no" title="statement not covered" >y.context,</span>S=<span class="cstat-no" title="statement not covered" >Math.min(f[0],m[0]),</span>E=<span class="cstat-no" title="statement not covered" >Math.min(f[1],m[1]);<span class="cstat-no" title="statement not covered" ></span>v.translate(-S,-E);<span class="cstat-no" title="statement not covered" >v</span>.transform(...g);<span class="cstat-no" title="statement not covered" >i</span>f(!u){<span class="cstat-no" title="statement not covered" >u=this._scaleImage(p.canvas,(0,i.getCurrentTransformInverse)(v));<span class="cstat-no" title="statement not covered" >u</span>=u.img;<span class="cstat-no" title="statement not covered" >h</span>&amp;&amp;l&amp;&amp;h.set(d,u)}<span class="cstat-no" title="statement not covered" ></span>v</span>.imageSmoothingEnabled=getImageSmoothingEnabled((0,i.getCurrentTransform)(v),t.interpolate);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(v,u,0,0,u.width,u.height,0,0,s,r);<span class="cstat-no" title="statement not covered" >v</span>.globalCompositeOperation="source-in";c</span>onst x=<span class="cstat-no" title="statement not covered" >n.Util.transform((0,i.getCurrentTransformInverse)(v),[1,0,0,1,-S,-E]);<span class="cstat-no" title="statement not covered" ></span>v.fillStyle=l?o.getPattern(e,this,x,a.PathType.FILL):o;<span class="cstat-no" title="statement not covered" >v</span>.fillRect(0,0,s,r);<span class="cstat-no" title="statement not covered" >i</span>f(h&amp;&amp;!l){<span class="cstat-no" title="statement not covered" >this.cachedCanvases.delete("fillCanvas");<span class="cstat-no" title="statement not covered" >h</span>.set(d,y.canvas)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{canvas:y.canvas,offsetX:Math.round(S),offsetY:Math.round(E)}}<span class="fstat-no" title="function not covered" ></span>se</span>tLineWidth(t){<span class="cstat-no" title="statement not covered" >t!==this.current.lineWidth&amp;&amp;(this._cachedScaleForStroking[0]=-1);<span class="cstat-no" title="statement not covered" >t</span>his.current.lineWidth=t;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.lineWidth=t}<span class="fstat-no" title="function not covered" ></span>se</span>tLineCap(t){<span class="cstat-no" title="statement not covered" >this.ctx.lineCap=h[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tLineJoin(t){<span class="cstat-no" title="statement not covered" >this.ctx.lineJoin=d[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tMiterLimit(t){<span class="cstat-no" title="statement not covered" >this.ctx.miterLimit=t}<span class="fstat-no" title="function not covered" ></span>se</span>tDash(t,e){const s=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==s.setLineDash){<span class="cstat-no" title="statement not covered" >s.setLineDash(t);<span class="cstat-no" title="statement not covered" >s</span>.lineDashOffset=e}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tRenderingIntent(t){}<span class="fstat-no" title="function not covered" >se</span>tFlatness(t){}<span class="fstat-no" title="function not covered" >se</span>tGState(t){<span class="cstat-no" title="statement not covered" >for(const[e,s]of t)<span class="cstat-no" title="statement not covered" >switch(e){case"LW":<span class="cstat-no" title="statement not covered" >this.setLineWidth(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LC":<span class="cstat-no" title="statement not covered" >this.setLineCap(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LJ":<span class="cstat-no" title="statement not covered" >this.setLineJoin(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ML":<span class="cstat-no" title="statement not covered" >this.setMiterLimit(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"D":<span class="cstat-no" title="statement not covered" >this.setDash(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RI":<span class="cstat-no" title="statement not covered" >this.setRenderingIntent(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"FL":<span class="cstat-no" title="statement not covered" >this.setFlatness(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Font":<span class="cstat-no" title="statement not covered" >this.setFont(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CA":<span class="cstat-no" title="statement not covered" >this.current.strokeAlpha=s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ca":<span class="cstat-no" title="statement not covered" >this.current.fillAlpha=s;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.globalAlpha=s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"BM":<span class="cstat-no" title="statement not covered" >this.ctx.globalCompositeOperation=s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SMask":<span class="cstat-no" title="statement not covered" >this.current.activeSMask=s?this.tempSMask:null;<span class="cstat-no" title="statement not covered" >t</span>his.tempSMask=null;<span class="cstat-no" title="statement not covered" >t</span>his.checkSMaskState();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"TR":<span class="cstat-no" title="statement not covered" >this.ctx.filter=this.current.transferMaps=this.filterFactory.addFilter(s)}</span>}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t inSMaskMode(){<span class="cstat-no" title="statement not covered" >return!!this.suspendedCtx}<span class="fstat-no" title="function not covered" ></span>ch</span>eckSMaskState(){const t=<span class="cstat-no" title="statement not covered" >this.inSMaskMode;<span class="cstat-no" title="statement not covered" ></span>this.current.activeSMask&amp;&amp;!t?this.beginSMaskMode():!this.current.activeSMask&amp;&amp;t&amp;&amp;this.endSMaskMode()}<span class="fstat-no" title="function not covered" ></span>be</span>ginSMaskMode(){<span class="cstat-no" title="statement not covered" >if(this.inSMaskMode)<span class="cstat-no" title="statement not covered" >throw new Error("beginSMaskMode called while already in smask mode");c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.width,</span>e=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.height,</span>s=<span class="cstat-no" title="statement not covered" >"smaskGroupAt"+this.groupLevel,</span>n=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas(s,t,e);<span class="cstat-no" title="statement not covered" ></span>this.suspendedCtx=this.ctx;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=n.context;c</span>onst a=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>a.setTransform(...(0,i.getCurrentTransform)(this.suspendedCtx));<span class="cstat-no" title="statement not covered" >c</span>opyCtxState(this.suspendedCtx,a);<span class="cstat-no" title="statement not covered" >!</span>function <span class="fstat-no" title="function not covered" >mirrorContextOperations(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t._removeMirroring)<span class="cstat-no" title="statement not covered" >throw new Error("Context is already forwarding operations.");<span class="cstat-no" title="statement not covered" >t</span></span>.__originalSave=t.save;<span class="cstat-no" title="statement not covered" >t</span>.__originalRestore=t.restore;<span class="cstat-no" title="statement not covered" >t</span>.__originalRotate=t.rotate;<span class="cstat-no" title="statement not covered" >t</span>.__originalScale=t.scale;<span class="cstat-no" title="statement not covered" >t</span>.__originalTranslate=t.translate;<span class="cstat-no" title="statement not covered" >t</span>.__originalTransform=t.transform;<span class="cstat-no" title="statement not covered" >t</span>.__originalSetTransform=t.setTransform;<span class="cstat-no" title="statement not covered" >t</span>.__originalResetTransform=t.resetTransform;<span class="cstat-no" title="statement not covered" >t</span>.__originalClip=t.clip;<span class="cstat-no" title="statement not covered" >t</span>.__originalMoveTo=t.moveTo;<span class="cstat-no" title="statement not covered" >t</span>.__originalLineTo=t.lineTo;<span class="cstat-no" title="statement not covered" >t</span>.__originalBezierCurveTo=t.bezierCurveTo;<span class="cstat-no" title="statement not covered" >t</span>.__originalRect=t.rect;<span class="cstat-no" title="statement not covered" >t</span>.__originalClosePath=t.closePath;<span class="cstat-no" title="statement not covered" >t</span>.__originalBeginPath=t.beginPath;<span class="cstat-no" title="statement not covered" >t</span>._removeMirroring=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.save=t.__originalSave;<span class="cstat-no" title="statement not covered" >t</span>.restore=t.__originalRestore;<span class="cstat-no" title="statement not covered" >t</span>.rotate=t.__originalRotate;<span class="cstat-no" title="statement not covered" >t</span>.scale=t.__originalScale;<span class="cstat-no" title="statement not covered" >t</span>.translate=t.__originalTranslate;<span class="cstat-no" title="statement not covered" >t</span>.transform=t.__originalTransform;<span class="cstat-no" title="statement not covered" >t</span>.setTransform=t.__originalSetTransform;<span class="cstat-no" title="statement not covered" >t</span>.resetTransform=t.__originalResetTransform;<span class="cstat-no" title="statement not covered" >t</span>.clip=t.__originalClip;<span class="cstat-no" title="statement not covered" >t</span>.moveTo=t.__originalMoveTo;<span class="cstat-no" title="statement not covered" >t</span>.lineTo=t.__originalLineTo;<span class="cstat-no" title="statement not covered" >t</span>.bezierCurveTo=t.__originalBezierCurveTo;<span class="cstat-no" title="statement not covered" >t</span>.rect=t.__originalRect;<span class="cstat-no" title="statement not covered" >t</span>.closePath=t.__originalClosePath;<span class="cstat-no" title="statement not covered" >t</span>.beginPath=t.__originalBeginPath;<span class="cstat-no" title="statement not covered" >d</span>elete t._removeMirroring}</span>;<span class="cstat-no" title="statement not covered" >t</span>.save=function <span class="fstat-no" title="function not covered" >ctxSave(</span>){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >t</span>his.__originalSave()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.restore=function <span class="fstat-no" title="function not covered" >ctxRestore(</span>){<span class="cstat-no" title="statement not covered" >e.restore();<span class="cstat-no" title="statement not covered" >t</span>his.__originalRestore()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.translate=function <span class="fstat-no" title="function not covered" >ctxTranslate(</span>t,s){<span class="cstat-no" title="statement not covered" >e.translate(t,s);<span class="cstat-no" title="statement not covered" >t</span>his.__originalTranslate(t,s)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.scale=function <span class="fstat-no" title="function not covered" >ctxScale(</span>t,s){<span class="cstat-no" title="statement not covered" >e.scale(t,s);<span class="cstat-no" title="statement not covered" >t</span>his.__originalScale(t,s)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.transform=function <span class="fstat-no" title="function not covered" >ctxTransform(</span>t,s,n,i,a,r){<span class="cstat-no" title="statement not covered" >e.transform(t,s,n,i,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.__originalTransform(t,s,n,i,a,r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.setTransform=function <span class="fstat-no" title="function not covered" >ctxSetTransform(</span>t,s,n,i,a,r){<span class="cstat-no" title="statement not covered" >e.setTransform(t,s,n,i,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.__originalSetTransform(t,s,n,i,a,r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.resetTransform=function <span class="fstat-no" title="function not covered" >ctxResetTransform(</span>){<span class="cstat-no" title="statement not covered" >e.resetTransform();<span class="cstat-no" title="statement not covered" >t</span>his.__originalResetTransform()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.rotate=function <span class="fstat-no" title="function not covered" >ctxRotate(</span>t){<span class="cstat-no" title="statement not covered" >e.rotate(t);<span class="cstat-no" title="statement not covered" >t</span>his.__originalRotate(t)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.clip=function <span class="fstat-no" title="function not covered" >ctxRotate(</span>t){<span class="cstat-no" title="statement not covered" >e.clip(t);<span class="cstat-no" title="statement not covered" >t</span>his.__originalClip(t)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.moveTo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >e.moveTo(t,s);<span class="cstat-no" title="statement not covered" >t</span>his.__originalMoveTo(t,s)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.lineTo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >e.lineTo(t,s);<span class="cstat-no" title="statement not covered" >t</span>his.__originalLineTo(t,s)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.bezierCurveTo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,n,i,a,r){<span class="cstat-no" title="statement not covered" >e.bezierCurveTo(t,s,n,i,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.__originalBezierCurveTo(t,s,n,i,a,r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.rect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,n,i){<span class="cstat-no" title="statement not covered" >e.rect(t,s,n,i);<span class="cstat-no" title="statement not covered" >t</span>his.__originalRect(t,s,n,i)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.closePath=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.__originalClosePath()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.beginPath=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.beginPath();<span class="cstat-no" title="statement not covered" >t</span>his.__originalBeginPath()}</span>}</span>(a,this.suspendedCtx);<span class="cstat-no" title="statement not covered" >t</span>his.setGState([["BM","source-over"],["ca",1],["CA",1]])}<span class="fstat-no" title="function not covered" ></span>en</span>dSMaskMode(){<span class="cstat-no" title="statement not covered" >if(!this.inSMaskMode)<span class="cstat-no" title="statement not covered" >throw new Error("endSMaskMode called while not in smask mode");<span class="cstat-no" title="statement not covered" >t</span></span>his.ctx._removeMirroring();<span class="cstat-no" title="statement not covered" >c</span>opyCtxState(this.ctx,this.suspendedCtx);<span class="cstat-no" title="statement not covered" >t</span>his.ctx=this.suspendedCtx;<span class="cstat-no" title="statement not covered" >t</span>his.suspendedCtx=null}<span class="fstat-no" title="function not covered" ></span>co</span>mpose(t){<span class="cstat-no" title="statement not covered" >if(!this.current.activeSMask)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(t){<span class="cstat-no" title="statement not covered" >t[0]=Math.floor(t[0]);<span class="cstat-no" title="statement not covered" >t</span>[1]=Math.floor(t[1]);<span class="cstat-no" title="statement not covered" >t</span>[2]=Math.ceil(t[2]);<span class="cstat-no" title="statement not covered" >t</span>[3]=Math.ceil(t[3])}</span>else <span class="cstat-no" title="statement not covered" >t=[0,0,this.ctx.canvas.width,this.ctx.canvas.height];c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.current.activeSMask;<span class="cstat-no" title="statement not covered" ></span>composeSMask(this.suspendedCtx,e,this.ctx,t);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.restore()}<span class="fstat-no" title="function not covered" ></span>sa</span>ve(){<span class="cstat-no" title="statement not covered" >if(this.inSMaskMode){<span class="cstat-no" title="statement not covered" >copyCtxState(this.ctx,this.suspendedCtx);<span class="cstat-no" title="statement not covered" >t</span>his.suspendedCtx.save()}</span>else <span class="cstat-no" title="statement not covered" >this.ctx.save();c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>this.stateStack.push(t);<span class="cstat-no" title="statement not covered" >t</span>his.current=t.clone()}<span class="fstat-no" title="function not covered" ></span>re</span>store(){<span class="cstat-no" title="statement not covered" >0===this.stateStack.length&amp;&amp;this.inSMaskMode&amp;&amp;this.endSMaskMode();<span class="cstat-no" title="statement not covered" >i</span>f(0!==this.stateStack.length){<span class="cstat-no" title="statement not covered" >this.current=this.stateStack.pop();<span class="cstat-no" title="statement not covered" >i</span>f(this.inSMaskMode){<span class="cstat-no" title="statement not covered" >this.suspendedCtx.restore();<span class="cstat-no" title="statement not covered" >c</span>opyCtxState(this.suspendedCtx,this.ctx)}</span>else <span class="cstat-no" title="statement not covered" >this.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span></span>his.checkSMaskState();<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking[0]=-1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null}</span>}<span class="fstat-no" title="function not covered" ></span>tr</span>ansform(t,e,s,n,i,a){<span class="cstat-no" title="statement not covered" >this.ctx.transform(t,e,s,n,i,a);<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking[0]=-1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null}<span class="fstat-no" title="function not covered" ></span>co</span>nstructPath(t,e,s){const a=<span class="cstat-no" title="statement not covered" >this.ctx,</span>r=<span class="cstat-no" title="statement not covered" >this.current;</span>let o,l,c=<span class="cstat-no" title="statement not covered" >r.x,</span>h=<span class="cstat-no" title="statement not covered" >r.y;</span>const d=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(a),</span>u=<span class="cstat-no" title="statement not covered" >0===d[0]&amp;&amp;0===d[3]||0===d[1]&amp;&amp;0===d[2],</span>p=<span class="cstat-no" title="statement not covered" >u?s.slice(0):null;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;g;s++)<span class="cstat-no" title="statement not covered" >switch(0|t[s]){case n.OPS.rectangle:<span class="cstat-no" title="statement not covered" >c=e[i++];<span class="cstat-no" title="statement not covered" >h</span>=e[i++];c</span>onst t=<span class="cstat-no" title="statement not covered" >e[i++],</span>s=<span class="cstat-no" title="statement not covered" >e[i++],</span>g=<span class="cstat-no" title="statement not covered" >c+t,</span>f=<span class="cstat-no" title="statement not covered" >h+s;<span class="cstat-no" title="statement not covered" ></span>a.moveTo(c,h);<span class="cstat-no" title="statement not covered" >i</span>f(0===t||0===s)<span class="cstat-no" title="statement not covered" >a.lineTo(g,f);e</span>lse{<span class="cstat-no" title="statement not covered" >a.lineTo(g,h);<span class="cstat-no" title="statement not covered" >a</span>.lineTo(g,f);<span class="cstat-no" title="statement not covered" >a</span>.lineTo(c,f)}<span class="cstat-no" title="statement not covered" ></span>u</span>||r.updateRectMinMax(d,[c,h,g,f]);<span class="cstat-no" title="statement not covered" >a</span>.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.moveTo:<span class="cstat-no" title="statement not covered" >c=e[i++];<span class="cstat-no" title="statement not covered" >h</span>=e[i++];<span class="cstat-no" title="statement not covered" >a</span>.moveTo(c,h);<span class="cstat-no" title="statement not covered" >u</span>||r.updatePathMinMax(d,c,h);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.lineTo:<span class="cstat-no" title="statement not covered" >c=e[i++];<span class="cstat-no" title="statement not covered" >h</span>=e[i++];<span class="cstat-no" title="statement not covered" >a</span>.lineTo(c,h);<span class="cstat-no" title="statement not covered" >u</span>||r.updatePathMinMax(d,c,h);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.curveTo:<span class="cstat-no" title="statement not covered" >o=c;<span class="cstat-no" title="statement not covered" >l</span>=h;<span class="cstat-no" title="statement not covered" >c</span>=e[i+4];<span class="cstat-no" title="statement not covered" >h</span>=e[i+5];<span class="cstat-no" title="statement not covered" >a</span>.bezierCurveTo(e[i],e[i+1],e[i+2],e[i+3],c,h);<span class="cstat-no" title="statement not covered" >r</span>.updateCurvePathMinMax(d,o,l,e[i],e[i+1],e[i+2],e[i+3],c,h,p);<span class="cstat-no" title="statement not covered" >i</span>+=6;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.curveTo2:<span class="cstat-no" title="statement not covered" >o=c;<span class="cstat-no" title="statement not covered" >l</span>=h;<span class="cstat-no" title="statement not covered" >a</span>.bezierCurveTo(c,h,e[i],e[i+1],e[i+2],e[i+3]);<span class="cstat-no" title="statement not covered" >r</span>.updateCurvePathMinMax(d,o,l,c,h,e[i],e[i+1],e[i+2],e[i+3],p);<span class="cstat-no" title="statement not covered" >c</span>=e[i+2];<span class="cstat-no" title="statement not covered" >h</span>=e[i+3];<span class="cstat-no" title="statement not covered" >i</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.curveTo3:<span class="cstat-no" title="statement not covered" >o=c;<span class="cstat-no" title="statement not covered" >l</span>=h;<span class="cstat-no" title="statement not covered" >c</span>=e[i+2];<span class="cstat-no" title="statement not covered" >h</span>=e[i+3];<span class="cstat-no" title="statement not covered" >a</span>.bezierCurveTo(e[i],e[i+1],c,h,c,h);<span class="cstat-no" title="statement not covered" >r</span>.updateCurvePathMinMax(d,o,l,e[i],e[i+1],c,h,c,h,p);<span class="cstat-no" title="statement not covered" >i</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.closePath:<span class="cstat-no" title="statement not covered" >a.closePath()}<span class="cstat-no" title="statement not covered" ></span>u</span></span>&amp;&amp;r.updateScalingPathMinMax(d,p);<span class="cstat-no" title="statement not covered" >r</span>.setCurrentPoint(c,h)}<span class="fstat-no" title="function not covered" ></span>cl</span>osePath(){<span class="cstat-no" title="statement not covered" >this.ctx.closePath()}<span class="fstat-no" title="function not covered" ></span>st</span>roke(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this.current.strokeColor;<span class="cstat-no" title="statement not covered" ></span>e.globalAlpha=this.current.strokeAlpha;<span class="cstat-no" title="statement not covered" >i</span>f(this.contentVisible)<span class="cstat-no" title="statement not covered" >if("object"==typeof s&amp;&amp;s?.getPattern){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >e</span>.strokeStyle=s.getPattern(e,this,(0,i.getCurrentTransformInverse)(e),a.PathType.STROKE);<span class="cstat-no" title="statement not covered" >t</span>his.rescaleAndStroke(!1);<span class="cstat-no" title="statement not covered" >e</span>.restore()}</span>else <span class="cstat-no" title="statement not covered" >this.rescaleAndStroke(!0);<span class="cstat-no" title="statement not covered" >t</span></span></span>&amp;&amp;this.consumePath(this.current.getClippedPathBoundingBox());<span class="cstat-no" title="statement not covered" >e</span>.globalAlpha=this.current.fillAlpha}<span class="fstat-no" title="function not covered" ></span>cl</span>oseStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.stroke()}<span class="fstat-no" title="function not covered" ></span>fi</span>ll(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this.current.fillColor;</span>let n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(this.current.patternFill){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >e</span>.fillStyle=s.getPattern(e,this,(0,i.getCurrentTransformInverse)(e),a.PathType.FILL);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >this.current.getClippedPathBoundingBox();<span class="cstat-no" title="statement not covered" ></span>if(this.contentVisible&amp;&amp;null!==r)<span class="cstat-no" title="statement not covered" >if(this.pendingEOFill){<span class="cstat-no" title="statement not covered" >e.fill("evenodd");<span class="cstat-no" title="statement not covered" >t</span>his.pendingEOFill=!1}</span>else <span class="cstat-no" title="statement not covered" >e.fill();<span class="cstat-no" title="statement not covered" >n</span></span></span>&amp;&amp;e.restore();<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;this.consumePath(r)}<span class="fstat-no" title="function not covered" ></span>eo</span>Fill(){<span class="cstat-no" title="statement not covered" >this.pendingEOFill=!0;<span class="cstat-no" title="statement not covered" >t</span>his.fill()}<span class="fstat-no" title="function not covered" ></span>fi</span>llStroke(){<span class="cstat-no" title="statement not covered" >this.fill(!1);<span class="cstat-no" title="statement not covered" >t</span>his.stroke(!1);<span class="cstat-no" title="statement not covered" >t</span>his.consumePath()}<span class="fstat-no" title="function not covered" ></span>eo</span>FillStroke(){<span class="cstat-no" title="statement not covered" >this.pendingEOFill=!0;<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseFillStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseEOFillStroke(){<span class="cstat-no" title="statement not covered" >this.pendingEOFill=!0;<span class="cstat-no" title="statement not covered" >t</span>his.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>en</span>dPath(){<span class="cstat-no" title="statement not covered" >this.consumePath()}<span class="fstat-no" title="function not covered" ></span>cl</span>ip(){<span class="cstat-no" title="statement not covered" >this.pendingClip=u}<span class="fstat-no" title="function not covered" ></span>eo</span>Clip(){<span class="cstat-no" title="statement not covered" >this.pendingClip=p}<span class="fstat-no" title="function not covered" ></span>be</span>ginText(){<span class="cstat-no" title="statement not covered" >this.current.textMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.current.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.current.x=this.current.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.current.y=this.current.lineY=0}<span class="fstat-no" title="function not covered" ></span>en</span>dText(){const t=<span class="cstat-no" title="statement not covered" >this.pendingTextPaths,</span>e=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >e</span>.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const s of t){<span class="cstat-no" title="statement not covered" >e.setTransform(...s.transform);<span class="cstat-no" title="statement not covered" >e</span>.translate(s.x,s.y);<span class="cstat-no" title="statement not covered" >s</span>.addToPath(e,s.fontSize)}<span class="cstat-no" title="statement not covered" ></span>e</span>.restore();<span class="cstat-no" title="statement not covered" >e</span>.clip();<span class="cstat-no" title="statement not covered" >e</span>.beginPath();<span class="cstat-no" title="statement not covered" >d</span>elete this.pendingTextPaths}</span>else <span class="cstat-no" title="statement not covered" >e.beginPath()}<span class="fstat-no" title="function not covered" ></span></span>se</span>tCharSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.charSpacing=t}<span class="fstat-no" title="function not covered" ></span>se</span>tWordSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.wordSpacing=t}<span class="fstat-no" title="function not covered" ></span>se</span>tHScale(t){<span class="cstat-no" title="statement not covered" >this.current.textHScale=t/100}<span class="fstat-no" title="function not covered" ></span>se</span>tLeading(t){<span class="cstat-no" title="statement not covered" >this.current.leading=-t}<span class="fstat-no" title="function not covered" ></span>se</span>tFont(t,e){const s=<span class="cstat-no" title="statement not covered" >this.commonObjs.get(t),</span>i=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >throw new Error(`Can't find font for ${t}`);<span class="cstat-no" title="statement not covered" >i</span></span>.fontMatrix=s.fontMatrix||n.FONT_IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >0</span>!==i.fontMatrix[0]&amp;&amp;0!==i.fontMatrix[3]||(0,n.warn)("Invalid font matrix for font "+t);<span class="cstat-no" title="statement not covered" >i</span>f(e&lt;0){<span class="cstat-no" title="statement not covered" >e=-e;<span class="cstat-no" title="statement not covered" >i</span>.fontDirection=-1}</span>else <span class="cstat-no" title="statement not covered" >i.fontDirection=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.current.font=s;<span class="cstat-no" title="statement not covered" >t</span>his.current.fontSize=e;<span class="cstat-no" title="statement not covered" >i</span>f(s.isType3Font)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >s.loadedName||"sans-serif",</span>r=<span class="cstat-no" title="statement not covered" >s.systemFontInfo?.css||`"${a}", ${s.fallbackName}`;</span>let o=<span class="cstat-no" title="statement not covered" >"normal";<span class="cstat-no" title="statement not covered" ></span>s.black?o="900":s.bold&amp;&amp;(o="bold");c</span>onst l=<span class="cstat-no" title="statement not covered" >s.italic?"italic":"normal";</span>let c=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>e&lt;16?c=16:e&gt;100&amp;&amp;(c=100);<span class="cstat-no" title="statement not covered" >t</span>his.current.fontSizeScale=e/c;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.font=`${l} ${o} ${c}px ${r}`}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRenderingMode(t){<span class="cstat-no" title="statement not covered" >this.current.textRenderingMode=t}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRise(t){<span class="cstat-no" title="statement not covered" >this.current.textRise=t}<span class="fstat-no" title="function not covered" ></span>mo</span>veText(t,e){<span class="cstat-no" title="statement not covered" >this.current.x=this.current.lineX+=t;<span class="cstat-no" title="statement not covered" >t</span>his.current.y=this.current.lineY+=e}<span class="fstat-no" title="function not covered" ></span>se</span>tLeadingMoveText(t,e){<span class="cstat-no" title="statement not covered" >this.setLeading(-e);<span class="cstat-no" title="statement not covered" >t</span>his.moveText(t,e)}<span class="fstat-no" title="function not covered" ></span>se</span>tTextMatrix(t,e,s,n,i,a){<span class="cstat-no" title="statement not covered" >this.current.textMatrix=[t,e,s,n,i,a];<span class="cstat-no" title="statement not covered" >t</span>his.current.textMatrixScale=Math.hypot(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.current.x=this.current.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.current.y=this.current.lineY=0}<span class="fstat-no" title="function not covered" ></span>ne</span>xtLine(){<span class="cstat-no" title="statement not covered" >this.moveText(0,this.current.leading)}<span class="fstat-no" title="function not covered" ></span>pa</span>intChar(t,e,s,a){const r=<span class="cstat-no" title="statement not covered" >this.ctx,</span>o=<span class="cstat-no" title="statement not covered" >this.current,</span>l=<span class="cstat-no" title="statement not covered" >o.font,</span>c=<span class="cstat-no" title="statement not covered" >o.textRenderingMode,</span>h=<span class="cstat-no" title="statement not covered" >o.fontSize/o.fontSizeScale,</span>d=<span class="cstat-no" title="statement not covered" >c&amp;n.TextRenderingMode.FILL_STROKE_MASK,</span>u=<span class="cstat-no" title="statement not covered" >!!(c&amp;n.TextRenderingMode.ADD_TO_PATH_FLAG),</span>p=<span class="cstat-no" title="statement not covered" >o.patternFill&amp;&amp;!l.missingFile;</span>let g;<span class="cstat-no" title="statement not covered" >(l.disableFontFace||u||p)&amp;&amp;(g=l.getPathGenerator(this.commonObjs,t));<span class="cstat-no" title="statement not covered" >i</span>f(l.disableFontFace||p){<span class="cstat-no" title="statement not covered" >r.save();<span class="cstat-no" title="statement not covered" >r</span>.translate(e,s);<span class="cstat-no" title="statement not covered" >r</span>.beginPath();<span class="cstat-no" title="statement not covered" >g</span>(r,h);<span class="cstat-no" title="statement not covered" >a</span>&amp;&amp;r.setTransform(...a);<span class="cstat-no" title="statement not covered" >d</span>!==n.TextRenderingMode.FILL&amp;&amp;d!==n.TextRenderingMode.FILL_STROKE||r.fill();<span class="cstat-no" title="statement not covered" >d</span>!==n.TextRenderingMode.STROKE&amp;&amp;d!==n.TextRenderingMode.FILL_STROKE||r.stroke();<span class="cstat-no" title="statement not covered" >r</span>.restore()}</span>else{<span class="cstat-no" title="statement not covered" >d!==n.TextRenderingMode.FILL&amp;&amp;d!==n.TextRenderingMode.FILL_STROKE||r.fillText(t,e,s);<span class="cstat-no" title="statement not covered" >d</span>!==n.TextRenderingMode.STROKE&amp;&amp;d!==n.TextRenderingMode.FILL_STROKE||r.strokeText(t,e,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u){<span class="cstat-no" title="statement not covered" >(this.pendingTextPaths||=[]).push({transform:(0,i.getCurrentTransform)(r),x:e,y:s,fontSize:h,addToPath:g})}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isFontSubpixelAAEnabled(){const{context:t}=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled",10,10);<span class="cstat-no" title="statement not covered" ></span>t.scale(1.5,1);<span class="cstat-no" title="statement not covered" >t</span>.fillText("I",0,10);c</span>onst e=<span class="cstat-no" title="statement not covered" >t.getImageData(0,0,10,10).data;</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >3;</span>t&lt;e.length;t+=4)<span class="cstat-no" title="statement not covered" >if(e[t]&gt;0&amp;&amp;e[t]&lt;255){<span class="cstat-no" title="statement not covered" >s=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn(0,n.shadow)(this,"isFontSubpixelAAEnabled",s)}<span class="fstat-no" title="function not covered" ></span>sh</span>owText(t){const e=<span class="cstat-no" title="statement not covered" >this.current,</span>s=<span class="cstat-no" title="statement not covered" >e.font;<span class="cstat-no" title="statement not covered" ></span>if(s.isType3Font)<span class="cstat-no" title="statement not covered" >return this.showType3Text(t);c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e.fontSize;<span class="cstat-no" title="statement not covered" ></span>if(0===r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.ctx,</span>l=<span class="cstat-no" title="statement not covered" >e.fontSizeScale,</span>c=<span class="cstat-no" title="statement not covered" >e.charSpacing,</span>h=<span class="cstat-no" title="statement not covered" >e.wordSpacing,</span>d=<span class="cstat-no" title="statement not covered" >e.fontDirection,</span>u=<span class="cstat-no" title="statement not covered" >e.textHScale*d,</span>p=<span class="cstat-no" title="statement not covered" >t.length,</span>g=<span class="cstat-no" title="statement not covered" >s.vertical,</span>f=<span class="cstat-no" title="statement not covered" >g?1:-1,</span>m=<span class="cstat-no" title="statement not covered" >s.defaultVMetrics,</span>b=<span class="cstat-no" title="statement not covered" >r*e.fontMatrix[0],</span>A=<span class="cstat-no" title="statement not covered" >e.textRenderingMode===n.TextRenderingMode.FILL&amp;&amp;!s.disableFontFace&amp;&amp;!e.patternFill;<span class="cstat-no" title="statement not covered" ></span>o.save();<span class="cstat-no" title="statement not covered" >o</span>.transform(...e.textMatrix);<span class="cstat-no" title="statement not covered" >o</span>.translate(e.x,e.y+e.textRise);<span class="cstat-no" title="statement not covered" >d</span>&gt;0?o.scale(u,-1):o.scale(u,1);l</span>et _;<span class="cstat-no" title="statement not covered" >if(e.patternFill){<span class="cstat-no" title="statement not covered" >o.save();c</span>onst t=<span class="cstat-no" title="statement not covered" >e.fillColor.getPattern(o,this,(0,i.getCurrentTransformInverse)(o),a.PathType.FILL);<span class="cstat-no" title="statement not covered" ></span>_=(0,i.getCurrentTransform)(o);<span class="cstat-no" title="statement not covered" >o</span>.restore();<span class="cstat-no" title="statement not covered" >o</span>.fillStyle=t}</span>l</span>et y=<span class="cstat-no" title="statement not covered" >e.lineWidth;</span>const v=<span class="cstat-no" title="statement not covered" >e.textMatrixScale;<span class="cstat-no" title="statement not covered" ></span>if(0===v||0===y){const t=<span class="cstat-no" title="statement not covered" >e.textRenderingMode&amp;n.TextRenderingMode.FILL_STROKE_MASK;<span class="cstat-no" title="statement not covered" ></span>t!==n.TextRenderingMode.STROKE&amp;&amp;t!==n.TextRenderingMode.FILL_STROKE||(y=this.getSinglePixelWidth())}</span>else <span class="cstat-no" title="statement not covered" >y/=v;<span class="cstat-no" title="statement not covered" >i</span></span>f(1!==l){<span class="cstat-no" title="statement not covered" >o.scale(l,l);<span class="cstat-no" title="statement not covered" >y</span>/=l}<span class="cstat-no" title="statement not covered" ></span>o</span>.lineWidth=y;<span class="cstat-no" title="statement not covered" >i</span>f(s.isInvalidPDFjsFont){const s=<span class="cstat-no" title="statement not covered" >[];</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const e of t){<span class="cstat-no" title="statement not covered" >s.push(e.unicode);<span class="cstat-no" title="statement not covered" >n</span>+=e.width}<span class="cstat-no" title="statement not covered" ></span>o</span>.fillText(s.join(""),0,0);<span class="cstat-no" title="statement not covered" >e</span>.x+=n*b*u;<span class="cstat-no" title="statement not covered" >o</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span>et S,E=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(S=0;S&lt;p;++S){const e=<span class="cstat-no" title="statement not covered" >t[S];<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof e){<span class="cstat-no" title="statement not covered" >E+=f*e*r/1e3;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >!1;</span>const i=<span class="cstat-no" title="statement not covered" >(e.isSpace?h:0)+c,</span>a=<span class="cstat-no" title="statement not covered" >e.fontChar,</span>u=<span class="cstat-no" title="statement not covered" >e.accent;</span>let p,y,v,x=<span class="cstat-no" title="statement not covered" >e.width;<span class="cstat-no" title="statement not covered" ></span>if(g){const t=<span class="cstat-no" title="statement not covered" >e.vmetric||m,</span>s=<span class="cstat-no" title="statement not covered" >-(e.vmetric?t[1]:.5*x)*b,</span>n=<span class="cstat-no" title="statement not covered" >t[2]*b;<span class="cstat-no" title="statement not covered" ></span>x=t?-t[0]:x;<span class="cstat-no" title="statement not covered" >p</span>=s/l;<span class="cstat-no" title="statement not covered" >y</span>=(E+n)/l}</span>else{<span class="cstat-no" title="statement not covered" >p=E/l;<span class="cstat-no" title="statement not covered" >y</span>=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.remeasure&amp;&amp;x&gt;0){const t=<span class="cstat-no" title="statement not covered" >1e3*o.measureText(a).width/r*l;<span class="cstat-no" title="statement not covered" ></span>if(x&lt;t&amp;&amp;this.isFontSubpixelAAEnabled){const e=<span class="cstat-no" title="statement not covered" >x/t;<span class="cstat-no" title="statement not covered" ></span>n=!0;<span class="cstat-no" title="statement not covered" >o</span>.save();<span class="cstat-no" title="statement not covered" >o</span>.scale(e,1);<span class="cstat-no" title="statement not covered" >p</span>/=e}</span>else <span class="cstat-no" title="statement not covered" >x!==t&amp;&amp;(p+=(x-t)/2e3*r/l)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(this.contentVisible&amp;&amp;(e.isInFont||s.missingFile))<span class="cstat-no" title="statement not covered" >if(A&amp;&amp;!u)<span class="cstat-no" title="statement not covered" >o.fillText(a,p,y);e</span>lse{<span class="cstat-no" title="statement not covered" >this.paintChar(a,p,y,_);<span class="cstat-no" title="statement not covered" >i</span>f(u){const t=<span class="cstat-no" title="statement not covered" >p+r*u.offset.x/l,</span>e=<span class="cstat-no" title="statement not covered" >y-r*u.offset.y/l;<span class="cstat-no" title="statement not covered" ></span>this.paintChar(u.fontChar,t,e,_)}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span></span>=g?x*b-i*d:x*b+i*d;<span class="cstat-no" title="statement not covered" >E</span>+=v;<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;o.restore()}<span class="cstat-no" title="statement not covered" ></span>g</span>?e.y-=E:e.x+=E*u;<span class="cstat-no" title="statement not covered" >o</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>sh</span>owType3Text(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this.current,</span>i=<span class="cstat-no" title="statement not covered" >s.font,</span>a=<span class="cstat-no" title="statement not covered" >s.fontSize,</span>r=<span class="cstat-no" title="statement not covered" >s.fontDirection,</span>o=<span class="cstat-no" title="statement not covered" >i.vertical?1:-1,</span>l=<span class="cstat-no" title="statement not covered" >s.charSpacing,</span>c=<span class="cstat-no" title="statement not covered" >s.wordSpacing,</span>h=<span class="cstat-no" title="statement not covered" >s.textHScale*r,</span>d=<span class="cstat-no" title="statement not covered" >s.fontMatrix||n.FONT_IDENTITY_MATRIX,</span>u=<span class="cstat-no" title="statement not covered" >t.length;</span>let p,g,f,m;<span class="cstat-no" title="statement not covered" >if(!(s.textRenderingMode===n.TextRenderingMode.INVISIBLE)&amp;&amp;0!==a){<span class="cstat-no" title="statement not covered" >this._cachedScaleForStroking[0]=-1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null;<span class="cstat-no" title="statement not covered" >e</span>.save();<span class="cstat-no" title="statement not covered" >e</span>.transform(...s.textMatrix);<span class="cstat-no" title="statement not covered" >e</span>.translate(s.x,s.y);<span class="cstat-no" title="statement not covered" >e</span>.scale(h,r);<span class="cstat-no" title="statement not covered" >f</span>or(p=0;p&lt;u;++p){<span class="cstat-no" title="statement not covered" >g=t[p];<span class="cstat-no" title="statement not covered" >i</span>f("number"==typeof g){<span class="cstat-no" title="statement not covered" >m=o*g*a/1e3;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.translate(m,0);<span class="cstat-no" title="statement not covered" >s</span>.x+=m*h;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >(g.isSpace?c:0)+l,</span>u=<span class="cstat-no" title="statement not covered" >i.charProcOperatorList[g.operatorListId];<span class="cstat-no" title="statement not covered" ></span>if(!u){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Type3 character "${g.operatorListId}" is not available.`);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.processingType3=g;<span class="cstat-no" title="statement not covered" >t</span>his.save();<span class="cstat-no" title="statement not covered" >e</span>.scale(a,a);<span class="cstat-no" title="statement not covered" >e</span>.transform(...d);<span class="cstat-no" title="statement not covered" >t</span>his.executeOperatorList(u);<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="cstat-no" title="statement not covered" ></span>f</span>=n.Util.applyTransform([g.width,0],d)[0]*a+r;<span class="cstat-no" title="statement not covered" >e</span>.translate(f,0);<span class="cstat-no" title="statement not covered" >s</span>.x+=f*h}<span class="cstat-no" title="statement not covered" ></span>e</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.processingType3=null}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tCharWidth(t,e){}<span class="fstat-no" title="function not covered" >se</span>tCharWidthAndBounds(t,e,s,n,i,a){<span class="cstat-no" title="statement not covered" >this.ctx.rect(s,n,i-s,a-n);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.clip();<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}<span class="fstat-no" title="function not covered" ></span>ge</span>tColorN_Pattern(t){let e;<span class="cstat-no" title="statement not covered" >if("TilingPattern"===t[0]){const s=<span class="cstat-no" title="statement not covered" >t[1],</span>n=<span class="cstat-no" title="statement not covered" >this.baseTransform||(0,i.getCurrentTransform)(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >{createCanvasGraphics:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new CanvasGraphics(t,this.commonObjs,this.objs,this.canvasFactory,this.filterFactory,{optionalContentConfig:this.optionalContentConfig,markedContentStack:this.markedContentStack})}</span>;<span class="cstat-no" title="statement not covered" ></span>e=new a.TilingPattern(t,s,this.ctx,r,n)}</span>else <span class="cstat-no" title="statement not covered" >e=this._getPattern(t[1],t[2]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeColorN(){<span class="cstat-no" title="statement not covered" >this.current.strokeColor=this.getColorN_Pattern(arguments)}<span class="fstat-no" title="function not covered" ></span>se</span>tFillColorN(){<span class="cstat-no" title="statement not covered" >this.current.fillColor=this.getColorN_Pattern(arguments);<span class="cstat-no" title="statement not covered" >t</span>his.current.patternFill=!0}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeRGBColor(t,e,s){const i=<span class="cstat-no" title="statement not covered" >n.Util.makeHexColor(t,e,s);<span class="cstat-no" title="statement not covered" ></span>this.ctx.strokeStyle=i;<span class="cstat-no" title="statement not covered" >t</span>his.current.strokeColor=i}<span class="fstat-no" title="function not covered" ></span>se</span>tFillRGBColor(t,e,s){const i=<span class="cstat-no" title="statement not covered" >n.Util.makeHexColor(t,e,s);<span class="cstat-no" title="statement not covered" ></span>this.ctx.fillStyle=i;<span class="cstat-no" title="statement not covered" >t</span>his.current.fillColor=i;<span class="cstat-no" title="statement not covered" >t</span>his.current.patternFill=!1}<span class="fstat-no" title="function not covered" ></span>_g</span>etPattern(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{let s;<span class="cstat-no" title="statement not covered" >if(this.cachedPatterns.has(t))<span class="cstat-no" title="statement not covered" >s=this.cachedPatterns.get(t);e</span>lse{<span class="cstat-no" title="statement not covered" >s=(0,a.getShadingPattern)(this.getObject(t));<span class="cstat-no" title="statement not covered" >t</span>his.cachedPatterns.set(t,s)}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;(s.matrix=e);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>sh</span>adingFill(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>this.save();c</span>onst s=<span class="cstat-no" title="statement not covered" >this._getPattern(t);<span class="cstat-no" title="statement not covered" ></span>e.fillStyle=s.getPattern(e,this,(0,i.getCurrentTransformInverse)(e),a.PathType.SHADING);c</span>onst r=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransformInverse)(e);<span class="cstat-no" title="statement not covered" ></span>if(r){const{width:t,height:s}=<span class="cstat-no" title="statement not covered" >e.canvas,</span>[i,a,o,l]=<span class="cstat-no" title="statement not covered" >n.Util.getAxialAlignedBoundingBox([0,0,t,s],r);<span class="cstat-no" title="statement not covered" ></span>this.ctx.fillRect(i,a,o-i,l-a)}</span>else <span class="cstat-no" title="statement not covered" >this.ctx.fillRect(-1e10,-1e10,2e10,2e10);<span class="cstat-no" title="statement not covered" >t</span></span>his.compose(this.current.getClippedPathBoundingBox());<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="fstat-no" title="function not covered" ></span>be</span>ginInlineImage(){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Should not call beginInlineImage")}<span class="fstat-no" title="function not covered" ></span>be</span>ginImageData(){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Should not call beginImageData")}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectBegin(t,e){<span class="cstat-no" title="statement not covered" >if(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.save();<span class="cstat-no" title="statement not covered" >t</span>his.baseTransformStack.push(this.baseTransform);<span class="cstat-no" title="statement not covered" >A</span>rray.isArray(t)&amp;&amp;6===t.length&amp;&amp;this.transform(...t);<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=(0,i.getCurrentTransform)(this.ctx);<span class="cstat-no" title="statement not covered" >i</span>f(e){const t=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>s=<span class="cstat-no" title="statement not covered" >e[3]-e[1];<span class="cstat-no" title="statement not covered" ></span>this.ctx.rect(e[0],e[1],t,s);<span class="cstat-no" title="statement not covered" >t</span>his.current.updateRectMinMax((0,i.getCurrentTransform)(this.ctx),e);<span class="cstat-no" title="statement not covered" >t</span>his.clip();<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectEnd(){<span class="cstat-no" title="statement not covered" >if(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.restore();<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=this.baseTransformStack.pop()}</span>}<span class="fstat-no" title="function not covered" ></span>be</span>ginGroup(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.save();<span class="cstat-no" title="statement not covered" >i</span>f(this.inSMaskMode){<span class="cstat-no" title="statement not covered" >this.endSMaskMode();<span class="cstat-no" title="statement not covered" >t</span>his.current.activeSMask=null}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>t.isolated||(0,n.info)("TODO: Support non-isolated groups.");<span class="cstat-no" title="statement not covered" >t</span>.knockout&amp;&amp;(0,n.warn)("Knockout groups not supported.");c</span>onst s=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(e);<span class="cstat-no" title="statement not covered" ></span>t.matrix&amp;&amp;e.transform(...t.matrix);<span class="cstat-no" title="statement not covered" >i</span>f(!t.bbox)<span class="cstat-no" title="statement not covered" >throw new Error("Bounding box is required.");l</span></span>et a=<span class="cstat-no" title="statement not covered" >n.Util.getAxialAlignedBoundingBox(t.bbox,(0,i.getCurrentTransform)(e));</span>const r=<span class="cstat-no" title="statement not covered" >[0,0,e.canvas.width,e.canvas.height];<span class="cstat-no" title="statement not covered" ></span>a=n.Util.intersect(a,r)||[0,0,0,0];c</span>onst o=<span class="cstat-no" title="statement not covered" >Math.floor(a[0]),</span>c=<span class="cstat-no" title="statement not covered" >Math.floor(a[1]);</span>let h=<span class="cstat-no" title="statement not covered" >Math.max(Math.ceil(a[2])-o,1),</span>d=<span class="cstat-no" title="statement not covered" >Math.max(Math.ceil(a[3])-c,1),</span>u=<span class="cstat-no" title="statement not covered" >1,</span>p=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(h&gt;l){<span class="cstat-no" title="statement not covered" >u=h/l;<span class="cstat-no" title="statement not covered" >h</span>=l}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d&gt;l){<span class="cstat-no" title="statement not covered" >p=d/l;<span class="cstat-no" title="statement not covered" >d</span>=l}<span class="cstat-no" title="statement not covered" ></span>t</span>his.current.startNewPathAndClipBox([0,0,h,d]);l</span>et g=<span class="cstat-no" title="statement not covered" >"groupAt"+this.groupLevel;<span class="cstat-no" title="statement not covered" ></span>t.smask&amp;&amp;(g+="_smask_"+this.smaskCounter++%2);c</span>onst f=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas(g,h,d),</span>m=<span class="cstat-no" title="statement not covered" >f.context;<span class="cstat-no" title="statement not covered" ></span>m.scale(1/u,1/p);<span class="cstat-no" title="statement not covered" >m</span>.translate(-o,-c);<span class="cstat-no" title="statement not covered" >m</span>.transform(...s);<span class="cstat-no" title="statement not covered" >i</span>f(t.smask)<span class="cstat-no" title="statement not covered" >this.smaskStack.push({canvas:f.canvas,context:m,offsetX:o,offsetY:c,scaleX:u,scaleY:p,subtype:t.smask.subtype,backdrop:t.smask.backdrop,transferMap:t.smask.transferMap||null,startTransformInverse:null});e</span>lse{<span class="cstat-no" title="statement not covered" >e.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >e</span>.translate(o,c);<span class="cstat-no" title="statement not covered" >e</span>.scale(u,p);<span class="cstat-no" title="statement not covered" >e</span>.save()}<span class="cstat-no" title="statement not covered" ></span>c</span>opyCtxState(e,m);<span class="cstat-no" title="statement not covered" >t</span>his.ctx=m;<span class="cstat-no" title="statement not covered" >t</span>his.setGState([["BM","source-over"],["ca",1],["CA",1]]);<span class="cstat-no" title="statement not covered" >t</span>his.groupStack.push(e);<span class="cstat-no" title="statement not covered" >t</span>his.groupLevel++}<span class="fstat-no" title="function not covered" ></span>en</span>dGroup(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.groupLevel--;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this.groupStack.pop();<span class="cstat-no" title="statement not covered" ></span>this.ctx=s;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.imageSmoothingEnabled=!1;<span class="cstat-no" title="statement not covered" >i</span>f(t.smask){<span class="cstat-no" title="statement not covered" >this.tempSMask=this.smaskStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.restore()}</span>else{<span class="cstat-no" title="statement not covered" >this.ctx.restore();c</span>onst t=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.restore();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(...t);c</span>onst s=<span class="cstat-no" title="statement not covered" >n.Util.getAxialAlignedBoundingBox([0,0,e.canvas.width,e.canvas.height],t);<span class="cstat-no" title="statement not covered" ></span>this.ctx.drawImage(e.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose(s)}</span>}<span class="fstat-no" title="function not covered" ></span>be</span>ginAnnotation(t,e,s,a,r){<span class="cstat-no" title="statement not covered" >this.#Mt();<span class="cstat-no" title="statement not covered" >r</span>esetCtxToDefault(this.ctx);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.save();<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform&amp;&amp;this.ctx.setTransform(...this.baseTransform);<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(e)&amp;&amp;4===e.length){const a=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>o=<span class="cstat-no" title="statement not covered" >e[3]-e[1];<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;this.annotationCanvasMap){<span class="cstat-no" title="statement not covered" >(s=s.slice())[4]-=e[0];<span class="cstat-no" title="statement not covered" >s</span>[5]-=e[1];<span class="cstat-no" title="statement not covered" >(</span>e=e.slice())[0]=e[1]=0;<span class="cstat-no" title="statement not covered" >e</span>[2]=a;<span class="cstat-no" title="statement not covered" >e</span>[3]=o;c</span>onst[r,l]=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale((0,i.getCurrentTransform)(this.ctx)),</span>{viewportScale:c}=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >Math.ceil(a*this.outputScaleX*c),</span>d=<span class="cstat-no" title="statement not covered" >Math.ceil(o*this.outputScaleY*c);<span class="cstat-no" title="statement not covered" ></span>this.annotationCanvas=this.canvasFactory.create(h,d);c</span>onst{canvas:u,context:p}=<span class="cstat-no" title="statement not covered" >this.annotationCanvas;<span class="cstat-no" title="statement not covered" ></span>this.annotationCanvasMap.set(t,u);<span class="cstat-no" title="statement not covered" >t</span>his.annotationCanvas.savedCtx=this.ctx;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=p;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(r,0,0,-l,0,o*l);<span class="cstat-no" title="statement not covered" >r</span>esetCtxToDefault(this.ctx)}</span>else{<span class="cstat-no" title="statement not covered" >resetCtxToDefault(this.ctx);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.rect(e[0],e[1],a,o);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.clip();<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.current=new CanvasExtraState(this.ctx.canvas.width,this.ctx.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.transform(...s);<span class="cstat-no" title="statement not covered" >t</span>his.transform(...a)}<span class="fstat-no" title="function not covered" ></span>en</span>dAnnotation(){<span class="cstat-no" title="statement not covered" >if(this.annotationCanvas){<span class="cstat-no" title="statement not covered" >this.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span>his.#Rt();<span class="cstat-no" title="statement not covered" >t</span>his.ctx=this.annotationCanvas.savedCtx;<span class="cstat-no" title="statement not covered" >d</span>elete this.annotationCanvas.savedCtx;<span class="cstat-no" title="statement not covered" >d</span>elete this.annotationCanvas}</span>}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObject(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.count;<span class="cstat-no" title="statement not covered" ></span>(t=this.getObject(t.data,t)).count=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.ctx,</span>n=<span class="cstat-no" title="statement not covered" >this.processingType3;<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >void 0===n.compiled&amp;&amp;(n.compiled=function <span class="fstat-no" title="function not covered" >compileType3Glyph(</span>t){const{width:e,height:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;1e3||s&gt;1e3)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >new Uint8Array([0,2,4,0,1,0,5,4,8,10,0,8,0,2,1,0]),</span>i=<span class="cstat-no" title="statement not covered" >e+1;</span>let a,r,o,l=<span class="cstat-no" title="statement not covered" >new Uint8Array(i*(s+1));</span>const c=<span class="cstat-no" title="statement not covered" >e+7&amp;-8;</span>let h=<span class="cstat-no" title="statement not covered" >new Uint8Array(c*s),</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const e of t.data){let t=<span class="cstat-no" title="statement not covered" >128;<span class="cstat-no" title="statement not covered" ></span>for(;t&gt;0;){<span class="cstat-no" title="statement not covered" >h[d++]=e&amp;t?0:255;<span class="cstat-no" title="statement not covered" >t</span>&gt;&gt;=1}</span>}</span>l</span>et u=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>d=0;<span class="cstat-no" title="statement not covered" >i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[0]=1;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r=1;r&lt;e;r++){<span class="cstat-no" title="statement not covered" >if(h[d]!==h[d+1]){<span class="cstat-no" title="statement not covered" >l[r]=h[d]?2:1;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>d</span>++}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[r]=2;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>f</span>or(a=1;a&lt;s;a++){<span class="cstat-no" title="statement not covered" >d=a*c;<span class="cstat-no" title="statement not covered" >o</span>=a*i;<span class="cstat-no" title="statement not covered" >i</span>f(h[d-c]!==h[d]){<span class="cstat-no" title="statement not covered" >l[o]=h[d]?1:8;<span class="cstat-no" title="statement not covered" >+</span>+u}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >(h[d]?4:0)+(h[d-c]?8:0);<span class="cstat-no" title="statement not covered" ></span>for(r=1;r&lt;e;r++){<span class="cstat-no" title="statement not covered" >t=(t&gt;&gt;2)+(h[d+1]?4:0)+(h[d-c+1]?8:0);<span class="cstat-no" title="statement not covered" >i</span>f(n[t]){<span class="cstat-no" title="statement not covered" >l[o+r]=n[t];<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>d</span>++}<span class="cstat-no" title="statement not covered" ></span>i</span>f(h[d-c]!==h[d]){<span class="cstat-no" title="statement not covered" >l[o+r]=h[d]?2:4;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u&gt;1e3)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span>d</span>=c*(s-1);<span class="cstat-no" title="statement not covered" >o</span>=a*i;<span class="cstat-no" title="statement not covered" >i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[o]=8;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r=1;r&lt;e;r++){<span class="cstat-no" title="statement not covered" >if(h[d]!==h[d+1]){<span class="cstat-no" title="statement not covered" >l[o+r]=h[d]?4:8;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>d</span>++}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[o+r]=4;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u&gt;1e3)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst p=<span class="cstat-no" title="statement not covered" >new Int32Array([0,i,-1,0,-i,0,0,0,1]),</span>g=<span class="cstat-no" title="statement not covered" >new Path2D;<span class="cstat-no" title="statement not covered" ></span>for(a=0;u&amp;&amp;a&lt;=s;a++){let t=<span class="cstat-no" title="statement not covered" >a*i;</span>const s=<span class="cstat-no" title="statement not covered" >t+e;<span class="cstat-no" title="statement not covered" ></span>for(;t&lt;s&amp;&amp;!l[t];)<span class="cstat-no" title="statement not covered" >t++;<span class="cstat-no" title="statement not covered" >i</span></span>f(t===s)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >g</span></span>.moveTo(t%i,a);c</span>onst n=<span class="cstat-no" title="statement not covered" >t;</span>let r=<span class="cstat-no" title="statement not covered" >l[t];<span class="cstat-no" title="statement not covered" ></span>do{const e=<span class="cstat-no" title="statement not covered" >p[r];<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >t+=e}</span>while(!l[t]);c</span>onst s=<span class="cstat-no" title="statement not covered" >l[t];<span class="cstat-no" title="statement not covered" ></span>if(5!==s&amp;&amp;10!==s){<span class="cstat-no" title="statement not covered" >r=s;<span class="cstat-no" title="statement not covered" >l</span>[t]=0}</span>else{<span class="cstat-no" title="statement not covered" >r=s&amp;51*r&gt;&gt;4;<span class="cstat-no" title="statement not covered" >l</span>[t]&amp;=r&gt;&gt;2|r&lt;&lt;2}<span class="cstat-no" title="statement not covered" ></span>g</span>.lineTo(t%i,t/i|0);<span class="cstat-no" title="statement not covered" >l</span>[t]||--u}</span>while(n!==t);<span class="cstat-no" title="statement not covered" >-</span>-a}<span class="cstat-no" title="statement not covered" ></span>h</span>=null;<span class="cstat-no" title="statement not covered" >l</span>=null;<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.save();<span class="cstat-no" title="statement not covered" >t</span>.scale(1/e,-1/s);<span class="cstat-no" title="statement not covered" >t</span>.translate(0,-s);<span class="cstat-no" title="statement not covered" >t</span>.fill(g);<span class="cstat-no" title="statement not covered" >t</span>.beginPath();<span class="cstat-no" title="statement not covered" >t</span>.restore()}</span>}</span>(t));<span class="cstat-no" title="statement not covered" >i</span>f(n.compiled){<span class="cstat-no" title="statement not covered" >n.compiled(s);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >this._createMaskCanvas(t),</span>a=<span class="cstat-no" title="statement not covered" >i.canvas;<span class="cstat-no" title="statement not covered" ></span>s.save();<span class="cstat-no" title="statement not covered" >s</span>.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >s</span>.drawImage(a,i.offsetX,i.offsetY);<span class="cstat-no" title="statement not covered" >s</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObjectRepeat(t,e,s=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>a=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r,o){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>=this.getObject(t.data,t);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>l.save();c</span>onst c=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(l);<span class="cstat-no" title="statement not covered" ></span>l.transform(e,s,a,r,0,0);c</span>onst h=<span class="cstat-no" title="statement not covered" >this._createMaskCanvas(t);<span class="cstat-no" title="statement not covered" ></span>l.setTransform(1,0,0,1,h.offsetX-c[4],h.offsetY-c[5]);<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >o.length;</span>t&lt;i;t+=2){const i=<span class="cstat-no" title="statement not covered" >n.Util.transform(c,[e,s,a,r,o[t],o[t+1]]),</span>[d,u]=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform([0,0],i);<span class="cstat-no" title="statement not covered" ></span>l.drawImage(h.canvas,d,u)}<span class="cstat-no" title="statement not covered" ></span>l</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObjectGroup(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this.current.fillColor,</span>n=<span class="cstat-no" title="statement not covered" >this.current.patternFill;<span class="cstat-no" title="statement not covered" ></span>for(const r of t){const{data:t,width:o,height:l,transform:c}=<span class="cstat-no" title="statement not covered" >r,</span>h=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("maskCanvas",o,l),</span>d=<span class="cstat-no" title="statement not covered" >h.context;<span class="cstat-no" title="statement not covered" ></span>d.save();<span class="cstat-no" title="statement not covered" >p</span>utBinaryImageMask(d,this.getObject(t,r));<span class="cstat-no" title="statement not covered" >d</span>.globalCompositeOperation="source-in";<span class="cstat-no" title="statement not covered" >d</span>.fillStyle=n?s.getPattern(d,this,(0,i.getCurrentTransformInverse)(e),a.PathType.FILL):s;<span class="cstat-no" title="statement not covered" >d</span>.fillRect(0,0,o,l);<span class="cstat-no" title="statement not covered" >d</span>.restore();<span class="cstat-no" title="statement not covered" >e</span>.save();<span class="cstat-no" title="statement not covered" >e</span>.transform(...c);<span class="cstat-no" title="statement not covered" >e</span>.scale(1,-1);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(e,h.canvas,0,0,o,l,0,-1,1,1);<span class="cstat-no" title="statement not covered" >e</span>.restore()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageXObject(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.getObject(t);<span class="cstat-no" title="statement not covered" ></span>e?this.paintInlineImageXObject(e):(0,n.warn)("Dependent image isn't ready yet")}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageXObjectRepeat(t,e,s,i){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >this.getObject(t);<span class="cstat-no" title="statement not covered" ></span>if(!a){<span class="cstat-no" title="statement not covered" >(0,n.warn)("Dependent image isn't ready yet");<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >a.width,</span>o=<span class="cstat-no" title="statement not covered" >a.height,</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >i.length;</span>t&lt;n;t+=2)<span class="cstat-no" title="statement not covered" >l.push({transform:[e,0,0,s,i[t],i[t+1]],x:0,y:0,w:r,h:o});<span class="cstat-no" title="statement not covered" >t</span></span>his.paintInlineImageXObjectGroup(a,l)}<span class="fstat-no" title="function not covered" ></span>ap</span>plyTransferMapsToCanvas(t){<span class="cstat-no" title="statement not covered" >if("none"!==this.current.transferMaps){<span class="cstat-no" title="statement not covered" >t.filter=this.current.transferMaps;<span class="cstat-no" title="statement not covered" >t</span>.drawImage(t.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>.filter="none"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.canvas}<span class="fstat-no" title="function not covered" ></span>ap</span>plyTransferMapsToBitmap(t){<span class="cstat-no" title="statement not covered" >if("none"===this.current.transferMaps)<span class="cstat-no" title="statement not covered" >return t.bitmap;c</span></span>onst{bitmap:e,width:s,height:n}=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("inlineImage",s,n),</span>a=<span class="cstat-no" title="statement not covered" >i.context;<span class="cstat-no" title="statement not covered" ></span>a.filter=this.current.transferMaps;<span class="cstat-no" title="statement not covered" >a</span>.drawImage(e,0,0);<span class="cstat-no" title="statement not covered" >a</span>.filter="none";<span class="cstat-no" title="statement not covered" >r</span>eturn i.canvas}<span class="fstat-no" title="function not covered" ></span>pa</span>intInlineImageXObject(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.width,</span>s=<span class="cstat-no" title="statement not covered" >t.height,</span>n=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>this.save();<span class="cstat-no" title="statement not covered" >o</span>.isNodeJS||(n.filter="none");<span class="cstat-no" title="statement not covered" >n</span>.scale(1/e,-1/s);l</span>et a;<span class="cstat-no" title="statement not covered" >if(t.bitmap)<span class="cstat-no" title="statement not covered" >a=this.applyTransferMapsToBitmap(t);e</span>lse <span class="cstat-no" title="statement not covered" >if("function"==typeof HTMLElement&amp;&amp;t instanceof HTMLElement||!t.data)<span class="cstat-no" title="statement not covered" >a=t;e</span>lse{const n=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("inlineImage",e,s).context;<span class="cstat-no" title="statement not covered" ></span>putBinaryImageData(n,t);<span class="cstat-no" title="statement not covered" >a</span>=this.applyTransferMapsToCanvas(n)}</span>c</span></span>onst r=<span class="cstat-no" title="statement not covered" >this._scaleImage(a,(0,i.getCurrentTransformInverse)(n));<span class="cstat-no" title="statement not covered" ></span>n.imageSmoothingEnabled=getImageSmoothingEnabled((0,i.getCurrentTransform)(n),t.interpolate);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(n,r.img,0,0,r.paintWidth,r.paintHeight,0,-s,e,s);<span class="cstat-no" title="statement not covered" >t</span>his.compose();<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="fstat-no" title="function not covered" ></span>pa</span>intInlineImageXObjectGroup(t,e){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.ctx;</span>let n;<span class="cstat-no" title="statement not covered" >if(t.bitmap)<span class="cstat-no" title="statement not covered" >n=t.bitmap;e</span>lse{const e=<span class="cstat-no" title="statement not covered" >t.width,</span>s=<span class="cstat-no" title="statement not covered" >t.height,</span>i=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("inlineImage",e,s).context;<span class="cstat-no" title="statement not covered" ></span>putBinaryImageData(i,t);<span class="cstat-no" title="statement not covered" >n</span>=this.applyTransferMapsToCanvas(i)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of e){<span class="cstat-no" title="statement not covered" >s.save();<span class="cstat-no" title="statement not covered" >s</span>.transform(...t.transform);<span class="cstat-no" title="statement not covered" >s</span>.scale(1,-1);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(s,n,t.x,t.y,t.w,t.h,0,-1,1,1);<span class="cstat-no" title="statement not covered" >s</span>.restore()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intSolidColorImageMask(){<span class="cstat-no" title="statement not covered" >if(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.ctx.fillRect(0,0,1,1);<span class="cstat-no" title="statement not covered" >t</span>his.compose()}</span>}<span class="fstat-no" title="function not covered" ></span>ma</span>rkPoint(t){}<span class="fstat-no" title="function not covered" >ma</span>rkPointProps(t,e){}<span class="fstat-no" title="function not covered" >be</span>ginMarkedContent(t){<span class="cstat-no" title="statement not covered" >this.markedContentStack.push({visible:!0})}<span class="fstat-no" title="function not covered" ></span>be</span>ginMarkedContentProps(t,e){<span class="cstat-no" title="statement not covered" >"OC"===t?this.markedContentStack.push({visible:this.optionalContentConfig.isVisible(e)}):this.markedContentStack.push({visible:!0});<span class="cstat-no" title="statement not covered" >t</span>his.contentVisible=this.isContentVisible()}<span class="fstat-no" title="function not covered" ></span>en</span>dMarkedContent(){<span class="cstat-no" title="statement not covered" >this.markedContentStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.contentVisible=this.isContentVisible()}<span class="fstat-no" title="function not covered" ></span>be</span>ginCompat(){}<span class="fstat-no" title="function not covered" >en</span>dCompat(){}<span class="fstat-no" title="function not covered" >co</span>nsumePath(t){const e=<span class="cstat-no" title="statement not covered" >this.current.isEmptyClip();<span class="cstat-no" title="statement not covered" ></span>this.pendingClip&amp;&amp;this.current.updateClipFromPath();<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip||this.compose(t);c</span>onst s=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>if(this.pendingClip){<span class="cstat-no" title="statement not covered" >e||(this.pendingClip===p?s.clip("evenodd"):s.clip());<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.current.startNewPathAndClipBox(this.current.clipBox);<span class="cstat-no" title="statement not covered" >s</span>.beginPath()}<span class="fstat-no" title="function not covered" ></span>ge</span>tSinglePixelWidth(){<span class="cstat-no" title="statement not covered" >if(!this._cachedGetSinglePixelWidth){const t=<span class="cstat-no" title="statement not covered" >(0,i.getCurrentTransform)(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(0===t[1]&amp;&amp;0===t[2])<span class="cstat-no" title="statement not covered" >this._cachedGetSinglePixelWidth=1/Math.min(Math.abs(t[0]),Math.abs(t[3]));e</span>lse{const e=<span class="cstat-no" title="statement not covered" >Math.abs(t[0]*t[3]-t[2]*t[1]),</span>s=<span class="cstat-no" title="statement not covered" >Math.hypot(t[0],t[2]),</span>n=<span class="cstat-no" title="statement not covered" >Math.hypot(t[1],t[3]);<span class="cstat-no" title="statement not covered" ></span>this._cachedGetSinglePixelWidth=Math.max(s,n)/e}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._cachedGetSinglePixelWidth}<span class="fstat-no" title="function not covered" ></span>ge</span>tScaleForStroking(){<span class="cstat-no" title="statement not covered" >if(-1===this._cachedScaleForStroking[0]){const{lineWidth:t}=<span class="cstat-no" title="statement not covered" >this.current,</span>{a:e,b:s,c:n,d:i}=<span class="cstat-no" title="statement not covered" >this.ctx.getTransform();</span>let a,r;<span class="cstat-no" title="statement not covered" >if(0===s&amp;&amp;0===n){const s=<span class="cstat-no" title="statement not covered" >Math.abs(e),</span>n=<span class="cstat-no" title="statement not covered" >Math.abs(i);<span class="cstat-no" title="statement not covered" ></span>if(s===n)<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >a=r=1/s;e</span>lse{const e=<span class="cstat-no" title="statement not covered" >s*t;<span class="cstat-no" title="statement not covered" ></span>a=r=e&lt;1?1/e:1}</span>e</span>lse <span class="cstat-no" title="statement not covered" >if(0===t){<span class="cstat-no" title="statement not covered" >a=1/s;<span class="cstat-no" title="statement not covered" >r</span>=1/n}</span>else{const e=<span class="cstat-no" title="statement not covered" >s*t,</span>i=<span class="cstat-no" title="statement not covered" >n*t;<span class="cstat-no" title="statement not covered" ></span>a=e&lt;1?1/e:1;<span class="cstat-no" title="statement not covered" >r</span>=i&lt;1?1/i:1}</span>}</span></span>else{const o=<span class="cstat-no" title="statement not covered" >Math.abs(e*i-s*n),</span>l=<span class="cstat-no" title="statement not covered" >Math.hypot(e,s),</span>c=<span class="cstat-no" title="statement not covered" >Math.hypot(n,i);<span class="cstat-no" title="statement not covered" ></span>if(0===t){<span class="cstat-no" title="statement not covered" >a=c/o;<span class="cstat-no" title="statement not covered" >r</span>=l/o}</span>else{const e=<span class="cstat-no" title="statement not covered" >t*o;<span class="cstat-no" title="statement not covered" ></span>a=c&gt;e?c/e:1;<span class="cstat-no" title="statement not covered" >r</span>=l&gt;e?l/e:1}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._cachedScaleForStroking[0]=a;<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking[1]=r}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._cachedScaleForStroking}<span class="fstat-no" title="function not covered" ></span>re</span>scaleAndStroke(t){const{ctx:e}=<span class="cstat-no" title="statement not covered" >this,</span>{lineWidth:s}=<span class="cstat-no" title="statement not covered" >this.current,</span>[n,i]=<span class="cstat-no" title="statement not covered" >this.getScaleForStroking();<span class="cstat-no" title="statement not covered" ></span>e.lineWidth=s||1;<span class="cstat-no" title="statement not covered" >i</span>f(1===n&amp;&amp;1===i){<span class="cstat-no" title="statement not covered" >e.stroke();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >e.getLineDash();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;e.save();<span class="cstat-no" title="statement not covered" >e</span>.scale(n,i);<span class="cstat-no" title="statement not covered" >i</span>f(a.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >Math.max(n,i);<span class="cstat-no" title="statement not covered" ></span>e.setLineDash(a.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e/t)</span>));<span class="cstat-no" title="statement not covered" >e</span>.lineDashOffset/=t}<span class="cstat-no" title="statement not covered" ></span>e</span>.stroke();<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;e.restore()}<span class="fstat-no" title="function not covered" ></span>is</span>ContentVisible(){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >this.markedContentStack.length-1;</span>t&gt;=0;t--)<span class="cstat-no" title="statement not covered" >if(!this.markedContentStack[t].visible)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>}<span class="cstat-no" title="statement not covered" >e.CanvasGraphics=CanvasGraphics;<span class="cstat-no" title="statement not covered" >f</span>or(const t in n.OPS)<span class="cstat-no" title="statement not covered" >void 0!==CanvasGraphics.prototype[t]&amp;&amp;(CanvasGraphics.prototype[n.OPS[t]]=CanvasGraphics.prototype[t])}</span></span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.TilingPattern=e.PathType=void 0;<span class="cstat-no" title="statement not covered" >e</span>.getShadingPattern=function <span class="fstat-no" title="function not covered" >getShadingPattern(</span>t){<span class="cstat-no" title="statement not covered" >switch(t[0]){case"RadialAxial":<span class="cstat-no" title="statement not covered" >return new RadialAxialShadingPattern(t);c</span>ase"Mesh":<span class="cstat-no" title="statement not covered" >return new MeshShadingPattern(t);c</span>ase"Dummy":<span class="cstat-no" title="statement not covered" >return new DummyShadingPattern}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Error(`Unknown IR type: ${t[0]}`)}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(6);</span>const a=<span class="cstat-no" title="statement not covered" >{FILL:"Fill",STROKE:"Stroke",SHADING:"Shading"};<span class="cstat-no" title="statement not covered" ></span>e.PathType=a;f</span>unction <span class="fstat-no" title="function not covered" >applyBoundingBox(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>n=<span class="cstat-no" title="statement not covered" >e[3]-e[1],</span>i=<span class="cstat-no" title="statement not covered" >new Path2D;<span class="cstat-no" title="statement not covered" ></span>i.rect(e[0],e[1],s,n);<span class="cstat-no" title="statement not covered" >t</span>.clip(i)}</span>class BaseShadingPattern{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseShadingPattern&amp;&amp;(0,n.unreachable)("Cannot initialize BaseShadingPattern.")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Abstract method `getPattern` called.")}</span>}class RadialAxialShadingPattern extends BaseShadingPattern{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._type=t[1];<span class="cstat-no" title="statement not covered" >t</span>his._bbox=t[2];<span class="cstat-no" title="statement not covered" >t</span>his._colorStops=t[3];<span class="cstat-no" title="statement not covered" >t</span>his._p0=t[4];<span class="cstat-no" title="statement not covered" >t</span>his._p1=t[5];<span class="cstat-no" title="statement not covered" >t</span>his._r0=t[6];<span class="cstat-no" title="statement not covered" >t</span>his._r1=t[7];<span class="cstat-no" title="statement not covered" >t</span>his.matrix=null}<span class="fstat-no" title="function not covered" ></span>_c</span>reateGradient(t){let e;<span class="cstat-no" title="statement not covered" >"axial"===this._type?e=t.createLinearGradient(this._p0[0],this._p0[1],this._p1[0],this._p1[1]):"radial"===this._type&amp;&amp;(e=t.createRadialGradient(this._p0[0],this._p0[1],this._r0,this._p1[0],this._p1[1],this._r1));<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._colorStops)<span class="cstat-no" title="statement not covered" >e.addColorStop(t[0],t[1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(t,e,s,r){let o;<span class="cstat-no" title="statement not covered" >if(r===a.STROKE||r===a.FILL){const a=<span class="cstat-no" title="statement not covered" >e.current.getClippedPathBoundingBox(r,(0,i.getCurrentTransform)(t))||[0,0,0,0],</span>l=<span class="cstat-no" title="statement not covered" >Math.ceil(a[2]-a[0])||1,</span>c=<span class="cstat-no" title="statement not covered" >Math.ceil(a[3]-a[1])||1,</span>h=<span class="cstat-no" title="statement not covered" >e.cachedCanvases.getCanvas("pattern",l,c,!0),</span>d=<span class="cstat-no" title="statement not covered" >h.context;<span class="cstat-no" title="statement not covered" ></span>d.clearRect(0,0,d.canvas.width,d.canvas.height);<span class="cstat-no" title="statement not covered" >d</span>.beginPath();<span class="cstat-no" title="statement not covered" >d</span>.rect(0,0,d.canvas.width,d.canvas.height);<span class="cstat-no" title="statement not covered" >d</span>.translate(-a[0],-a[1]);<span class="cstat-no" title="statement not covered" >s</span>=n.Util.transform(s,[1,0,0,1,a[0],a[1]]);<span class="cstat-no" title="statement not covered" >d</span>.transform(...e.baseTransform);<span class="cstat-no" title="statement not covered" >t</span>his.matrix&amp;&amp;d.transform(...this.matrix);<span class="cstat-no" title="statement not covered" >a</span>pplyBoundingBox(d,this._bbox);<span class="cstat-no" title="statement not covered" >d</span>.fillStyle=this._createGradient(d);<span class="cstat-no" title="statement not covered" >d</span>.fill();<span class="cstat-no" title="statement not covered" >o</span>=t.createPattern(h.canvas,"no-repeat");c</span>onst u=<span class="cstat-no" title="statement not covered" >new DOMMatrix(s);<span class="cstat-no" title="statement not covered" ></span>o.setTransform(u)}</span>else{<span class="cstat-no" title="statement not covered" >applyBoundingBox(t,this._bbox);<span class="cstat-no" title="statement not covered" >o</span>=this._createGradient(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>}function <span class="fstat-no" title="function not covered" >drawTriangle(</span>t,e,s,n,i,a,r,o){const l=<span class="cstat-no" title="statement not covered" >e.coords,</span>c=<span class="cstat-no" title="statement not covered" >e.colors,</span>h=<span class="cstat-no" title="statement not covered" >t.data,</span>d=<span class="cstat-no" title="statement not covered" >4*t.width;</span>let u;<span class="cstat-no" title="statement not covered" >if(l[s+1]&gt;l[n+1]){<span class="cstat-no" title="statement not covered" >u=s;<span class="cstat-no" title="statement not covered" >s</span>=n;<span class="cstat-no" title="statement not covered" >n</span>=u;<span class="cstat-no" title="statement not covered" >u</span>=a;<span class="cstat-no" title="statement not covered" >a</span>=r;<span class="cstat-no" title="statement not covered" >r</span>=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l[n+1]&gt;l[i+1]){<span class="cstat-no" title="statement not covered" >u=n;<span class="cstat-no" title="statement not covered" >n</span>=i;<span class="cstat-no" title="statement not covered" >i</span>=u;<span class="cstat-no" title="statement not covered" >u</span>=r;<span class="cstat-no" title="statement not covered" >r</span>=o;<span class="cstat-no" title="statement not covered" >o</span>=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l[s+1]&gt;l[n+1]){<span class="cstat-no" title="statement not covered" >u=s;<span class="cstat-no" title="statement not covered" >s</span>=n;<span class="cstat-no" title="statement not covered" >n</span>=u;<span class="cstat-no" title="statement not covered" >u</span>=a;<span class="cstat-no" title="statement not covered" >a</span>=r;<span class="cstat-no" title="statement not covered" >r</span>=u}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >(l[s]+e.offsetX)*e.scaleX,</span>g=<span class="cstat-no" title="statement not covered" >(l[s+1]+e.offsetY)*e.scaleY,</span>f=<span class="cstat-no" title="statement not covered" >(l[n]+e.offsetX)*e.scaleX,</span>m=<span class="cstat-no" title="statement not covered" >(l[n+1]+e.offsetY)*e.scaleY,</span>b=<span class="cstat-no" title="statement not covered" >(l[i]+e.offsetX)*e.scaleX,</span>A=<span class="cstat-no" title="statement not covered" >(l[i+1]+e.offsetY)*e.scaleY;<span class="cstat-no" title="statement not covered" ></span>if(g&gt;=A)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst _=<span class="cstat-no" title="statement not covered" >c[a],</span>y=<span class="cstat-no" title="statement not covered" >c[a+1],</span>v=<span class="cstat-no" title="statement not covered" >c[a+2],</span>S=<span class="cstat-no" title="statement not covered" >c[r],</span>E=<span class="cstat-no" title="statement not covered" >c[r+1],</span>x=<span class="cstat-no" title="statement not covered" >c[r+2],</span>C=<span class="cstat-no" title="statement not covered" >c[o],</span>w=<span class="cstat-no" title="statement not covered" >c[o+1],</span>T=<span class="cstat-no" title="statement not covered" >c[o+2],</span>P=<span class="cstat-no" title="statement not covered" >Math.round(g),</span>F=<span class="cstat-no" title="statement not covered" >Math.round(A);</span>let k,M,R,D,I,O,L,N;<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >P;</span>t&lt;=F;t++){<span class="cstat-no" title="statement not covered" >if(t&lt;m){let e;<span class="cstat-no" title="statement not covered" >e=t&lt;g?0:(g-t)/(g-m);<span class="cstat-no" title="statement not covered" >k</span>=p-(p-f)*e;<span class="cstat-no" title="statement not covered" >M</span>=_-(_-S)*e;<span class="cstat-no" title="statement not covered" >R</span>=y-(y-E)*e;<span class="cstat-no" title="statement not covered" >D</span>=v-(v-x)*e}</span>else{let e;<span class="cstat-no" title="statement not covered" >e=t&gt;A?1:m===A?0:(m-t)/(m-A);<span class="cstat-no" title="statement not covered" >k</span>=f-(f-b)*e;<span class="cstat-no" title="statement not covered" >M</span>=S-(S-C)*e;<span class="cstat-no" title="statement not covered" >R</span>=E-(E-w)*e;<span class="cstat-no" title="statement not covered" >D</span>=x-(x-T)*e}</span>l</span>et e;<span class="cstat-no" title="statement not covered" >e=t&lt;g?0:t&gt;A?1:(g-t)/(g-A);<span class="cstat-no" title="statement not covered" >I</span>=p-(p-b)*e;<span class="cstat-no" title="statement not covered" >O</span>=_-(_-C)*e;<span class="cstat-no" title="statement not covered" >L</span>=y-(y-w)*e;<span class="cstat-no" title="statement not covered" >N</span>=v-(v-T)*e;c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.round(Math.min(k,I)),</span>n=<span class="cstat-no" title="statement not covered" >Math.round(Math.max(k,I));</span>let i=<span class="cstat-no" title="statement not covered" >d*t+4*s;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >s;</span>t&lt;=n;t++){<span class="cstat-no" title="statement not covered" >e=(k-t)/(k-I);<span class="cstat-no" title="statement not covered" >e</span>&lt;0?e=0:e&gt;1&amp;&amp;(e=1);<span class="cstat-no" title="statement not covered" >h</span>[i++]=M-(M-O)*e|0;<span class="cstat-no" title="statement not covered" >h</span>[i++]=R-(R-L)*e|0;<span class="cstat-no" title="statement not covered" >h</span>[i++]=D-(D-N)*e|0;<span class="cstat-no" title="statement not covered" >h</span>[i++]=255}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >drawFigure(</span>t,e,s){const n=<span class="cstat-no" title="statement not covered" >e.coords,</span>i=<span class="cstat-no" title="statement not covered" >e.colors;</span>let a,r;<span class="cstat-no" title="statement not covered" >switch(e.type){case"lattice":const o=<span class="cstat-no" title="statement not covered" >e.verticesPerRow,</span>l=<span class="cstat-no" title="statement not covered" >Math.floor(n.length/o)-1,</span>c=<span class="cstat-no" title="statement not covered" >o-1;<span class="cstat-no" title="statement not covered" ></span>for(a=0;a&lt;l;a++){let e=<span class="cstat-no" title="statement not covered" >a*o;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;c;a++,e++){<span class="cstat-no" title="statement not covered" >drawTriangle(t,s,n[e],n[e+1],n[e+o],i[e],i[e+1],i[e+o]);<span class="cstat-no" title="statement not covered" >d</span>rawTriangle(t,s,n[e+o+1],n[e+1],n[e+o],i[e+o+1],i[e+1],i[e+o])}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"triangles":<span class="cstat-no" title="statement not covered" >for(a=0,r=n.length;a&lt;r;a+=3)<span class="cstat-no" title="statement not covered" >drawTriangle(t,s,n[a],n[a+1],n[a+2],i[a],i[a+1],i[a+2]);<span class="cstat-no" title="statement not covered" >b</span></span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("illegal figure")}</span>}</span>class MeshShadingPattern extends BaseShadingPattern{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._coords=t[2];<span class="cstat-no" title="statement not covered" >t</span>his._colors=t[3];<span class="cstat-no" title="statement not covered" >t</span>his._figures=t[4];<span class="cstat-no" title="statement not covered" >t</span>his._bounds=t[5];<span class="cstat-no" title="statement not covered" >t</span>his._bbox=t[7];<span class="cstat-no" title="statement not covered" >t</span>his._background=t[8];<span class="cstat-no" title="statement not covered" >t</span>his.matrix=null}<span class="fstat-no" title="function not covered" ></span>_c</span>reateMeshCanvas(t,e,s){const n=<span class="cstat-no" title="statement not covered" >Math.floor(this._bounds[0]),</span>i=<span class="cstat-no" title="statement not covered" >Math.floor(this._bounds[1]),</span>a=<span class="cstat-no" title="statement not covered" >Math.ceil(this._bounds[2])-n,</span>r=<span class="cstat-no" title="statement not covered" >Math.ceil(this._bounds[3])-i,</span>o=<span class="cstat-no" title="statement not covered" >Math.min(Math.ceil(Math.abs(a*t[0]*1.1)),3e3),</span>l=<span class="cstat-no" title="statement not covered" >Math.min(Math.ceil(Math.abs(r*t[1]*1.1)),3e3),</span>c=<span class="cstat-no" title="statement not covered" >a/o,</span>h=<span class="cstat-no" title="statement not covered" >r/l,</span>d=<span class="cstat-no" title="statement not covered" >{coords:this._coords,colors:this._colors,offsetX:-n,offsetY:-i,scaleX:1/c,scaleY:1/h},</span>u=<span class="cstat-no" title="statement not covered" >o+4,</span>p=<span class="cstat-no" title="statement not covered" >l+4,</span>g=<span class="cstat-no" title="statement not covered" >s.getCanvas("mesh",u,p,!1),</span>f=<span class="cstat-no" title="statement not covered" >g.context,</span>m=<span class="cstat-no" title="statement not covered" >f.createImageData(o,l);<span class="cstat-no" title="statement not covered" ></span>if(e){const t=<span class="cstat-no" title="statement not covered" >m.data;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s+=4){<span class="cstat-no" title="statement not covered" >t[s]=e[0];<span class="cstat-no" title="statement not covered" >t</span>[s+1]=e[1];<span class="cstat-no" title="statement not covered" >t</span>[s+2]=e[2];<span class="cstat-no" title="statement not covered" >t</span>[s+3]=255}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of this._figures)<span class="cstat-no" title="statement not covered" >drawFigure(m,t,d);<span class="cstat-no" title="statement not covered" >f</span></span>.putImageData(m,2,2);<span class="cstat-no" title="statement not covered" >r</span>eturn{canvas:g.canvas,offsetX:n-2*c,offsetY:i-2*h,scaleX:c,scaleY:h}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(t,e,s,r){<span class="cstat-no" title="statement not covered" >applyBoundingBox(t,this._bbox);l</span>et o;<span class="cstat-no" title="statement not covered" >if(r===a.SHADING)<span class="cstat-no" title="statement not covered" >o=n.Util.singularValueDecompose2dScale((0,i.getCurrentTransform)(t));e</span>lse{<span class="cstat-no" title="statement not covered" >o=n.Util.singularValueDecompose2dScale(e.baseTransform);<span class="cstat-no" title="statement not covered" >i</span>f(this.matrix){const t=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale(this.matrix);<span class="cstat-no" title="statement not covered" ></span>o=[o[0]*t[0],o[1]*t[1]]}</span>}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >this._createMeshCanvas(o,r===a.SHADING?null:this._background,e.cachedCanvases);<span class="cstat-no" title="statement not covered" ></span>if(r!==a.SHADING){<span class="cstat-no" title="statement not covered" >t.setTransform(...e.baseTransform);<span class="cstat-no" title="statement not covered" >t</span>his.matrix&amp;&amp;t.transform(...this.matrix)}<span class="cstat-no" title="statement not covered" ></span>t</span>.translate(l.offsetX,l.offsetY);<span class="cstat-no" title="statement not covered" >t</span>.scale(l.scaleX,l.scaleY);<span class="cstat-no" title="statement not covered" >r</span>eturn t.createPattern(l.canvas,"no-repeat")}</span>}class DummyShadingPattern extends BaseShadingPattern{<span class="fstat-no" title="function not covered" >ge</span>tPattern(){<span class="cstat-no" title="statement not covered" >return"hotpink"}</span>}const r=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >2;</span>class TilingPattern{static MAX_PATTERN_SIZE=<span class="cstat-no" title="statement not covered" >3e3;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,s,n,i){<span class="cstat-no" title="statement not covered" >this.operatorList=t[2];<span class="cstat-no" title="statement not covered" >t</span>his.matrix=t[3]||[1,0,0,1,0,0];<span class="cstat-no" title="statement not covered" >t</span>his.bbox=t[4];<span class="cstat-no" title="statement not covered" >t</span>his.xstep=t[5];<span class="cstat-no" title="statement not covered" >t</span>his.ystep=t[6];<span class="cstat-no" title="statement not covered" >t</span>his.paintType=t[7];<span class="cstat-no" title="statement not covered" >t</span>his.tilingType=t[8];<span class="cstat-no" title="statement not covered" >t</span>his.color=e;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=s;<span class="cstat-no" title="statement not covered" >t</span>his.canvasGraphicsFactory=n;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=i}<span class="fstat-no" title="function not covered" ></span>cr</span>eatePatternCanvas(t){const e=<span class="cstat-no" title="statement not covered" >this.operatorList,</span>s=<span class="cstat-no" title="statement not covered" >this.bbox,</span>a=<span class="cstat-no" title="statement not covered" >this.xstep,</span>r=<span class="cstat-no" title="statement not covered" >this.ystep,</span>o=<span class="cstat-no" title="statement not covered" >this.paintType,</span>l=<span class="cstat-no" title="statement not covered" >this.tilingType,</span>c=<span class="cstat-no" title="statement not covered" >this.color,</span>h=<span class="cstat-no" title="statement not covered" >this.canvasGraphicsFactory;<span class="cstat-no" title="statement not covered" ></span>(0,n.info)("TilingType: "+l);c</span>onst d=<span class="cstat-no" title="statement not covered" >s[0],</span>u=<span class="cstat-no" title="statement not covered" >s[1],</span>p=<span class="cstat-no" title="statement not covered" >s[2],</span>g=<span class="cstat-no" title="statement not covered" >s[3],</span>f=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale(this.matrix),</span>m=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale(this.baseTransform),</span>b=<span class="cstat-no" title="statement not covered" >[f[0]*m[0],f[1]*m[1]],</span>A=<span class="cstat-no" title="statement not covered" >this.getSizeAndScale(a,this.ctx.canvas.width,b[0]),</span>_=<span class="cstat-no" title="statement not covered" >this.getSizeAndScale(r,this.ctx.canvas.height,b[1]),</span>y=<span class="cstat-no" title="statement not covered" >t.cachedCanvases.getCanvas("pattern",A.size,_.size,!0),</span>v=<span class="cstat-no" title="statement not covered" >y.context,</span>S=<span class="cstat-no" title="statement not covered" >h.createCanvasGraphics(v);<span class="cstat-no" title="statement not covered" ></span>S.groupLevel=t.groupLevel;<span class="cstat-no" title="statement not covered" >t</span>his.setFillAndStrokeStyleToContext(S,o,c);l</span>et E=<span class="cstat-no" title="statement not covered" >d,</span>x=<span class="cstat-no" title="statement not covered" >u,</span>C=<span class="cstat-no" title="statement not covered" >p,</span>w=<span class="cstat-no" title="statement not covered" >g;<span class="cstat-no" title="statement not covered" ></span>if(d&lt;0){<span class="cstat-no" title="statement not covered" >E=0;<span class="cstat-no" title="statement not covered" >C</span>+=Math.abs(d)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u&lt;0){<span class="cstat-no" title="statement not covered" >x=0;<span class="cstat-no" title="statement not covered" >w</span>+=Math.abs(u)}<span class="cstat-no" title="statement not covered" ></span>v</span>.translate(-A.scale*E,-_.scale*x);<span class="cstat-no" title="statement not covered" >S</span>.transform(A.scale,0,0,_.scale,0,0);<span class="cstat-no" title="statement not covered" >v</span>.save();<span class="cstat-no" title="statement not covered" >t</span>his.clipBbox(S,E,x,C,w);<span class="cstat-no" title="statement not covered" >S</span>.baseTransform=(0,i.getCurrentTransform)(S.ctx);<span class="cstat-no" title="statement not covered" >S</span>.executeOperatorList(e);<span class="cstat-no" title="statement not covered" >S</span>.endDrawing();<span class="cstat-no" title="statement not covered" >r</span>eturn{canvas:y.canvas,scaleX:A.scale,scaleY:_.scale,offsetX:E,offsetY:x}}<span class="fstat-no" title="function not covered" ></span>ge</span>tSizeAndScale(t,e,s){<span class="cstat-no" title="statement not covered" >t=Math.abs(t);c</span>onst n=<span class="cstat-no" title="statement not covered" >Math.max(TilingPattern.MAX_PATTERN_SIZE,e);</span>let i=<span class="cstat-no" title="statement not covered" >Math.ceil(t*s);<span class="cstat-no" title="statement not covered" ></span>i&gt;=n?i=n:s=i/t;<span class="cstat-no" title="statement not covered" >r</span>eturn{scale:s,size:i}}<span class="fstat-no" title="function not covered" ></span>cl</span>ipBbox(t,e,s,n,a){const r=<span class="cstat-no" title="statement not covered" >n-e,</span>o=<span class="cstat-no" title="statement not covered" >a-s;<span class="cstat-no" title="statement not covered" ></span>t.ctx.rect(e,s,r,o);<span class="cstat-no" title="statement not covered" >t</span>.current.updateRectMinMax((0,i.getCurrentTransform)(t.ctx),[e,s,n,a]);<span class="cstat-no" title="statement not covered" >t</span>.clip();<span class="cstat-no" title="statement not covered" >t</span>.endPath()}<span class="fstat-no" title="function not covered" ></span>se</span>tFillAndStrokeStyleToContext(t,e,s){const i=<span class="cstat-no" title="statement not covered" >t.ctx,</span>a=<span class="cstat-no" title="statement not covered" >t.current;<span class="cstat-no" title="statement not covered" ></span>switch(e){case r:const t=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>i.fillStyle=t.fillStyle;<span class="cstat-no" title="statement not covered" >i</span>.strokeStyle=t.strokeStyle;<span class="cstat-no" title="statement not covered" >a</span>.fillColor=t.fillStyle;<span class="cstat-no" title="statement not covered" >a</span>.strokeColor=t.strokeStyle;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase o:const l=<span class="cstat-no" title="statement not covered" >n.Util.makeHexColor(s[0],s[1],s[2]);<span class="cstat-no" title="statement not covered" ></span>i.fillStyle=l;<span class="cstat-no" title="statement not covered" >i</span>.strokeStyle=l;<span class="cstat-no" title="statement not covered" >a</span>.fillColor=l;<span class="cstat-no" title="statement not covered" >a</span>.strokeColor=l;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new n.FormatError(`Unsupported paint type: ${e}`)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(t,e,s,i){let r=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(i!==a.SHADING){<span class="cstat-no" title="statement not covered" >r=n.Util.transform(r,e.baseTransform);<span class="cstat-no" title="statement not covered" >t</span>his.matrix&amp;&amp;(r=n.Util.transform(r,this.matrix))}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >this.createPatternCanvas(e);</span>let l=<span class="cstat-no" title="statement not covered" >new DOMMatrix(r);<span class="cstat-no" title="statement not covered" ></span>l=l.translate(o.offsetX,o.offsetY);<span class="cstat-no" title="statement not covered" >l</span>=l.scale(1/o.scaleX,1/o.scaleY);c</span>onst c=<span class="cstat-no" title="statement not covered" >t.createPattern(o.canvas,"repeat");<span class="cstat-no" title="statement not covered" ></span>c.setTransform(l);<span class="cstat-no" title="statement not covered" >r</span>eturn c}</span>}<span class="cstat-no" title="statement not covered" >e.TilingPattern=TilingPattern}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.convertBlackAndWhiteToRGBA=convertBlackAndWhiteToRGBA;<span class="cstat-no" title="statement not covered" >e</span>.convertToRGBA=function <span class="fstat-no" title="function not covered" >convertToRGBA(</span>t){<span class="cstat-no" title="statement not covered" >switch(t.kind){case n.ImageKind.GRAYSCALE_1BPP:<span class="cstat-no" title="statement not covered" >return convertBlackAndWhiteToRGBA(t);c</span>ase n.ImageKind.RGB_24BPP:<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >convertRGBToRGBA(</span>{src:t,srcPos:e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dest:s,destPos:i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>width:a,height:r}){let o=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >t.length&gt;&gt;2,</span>c=<span class="cstat-no" title="statement not covered" >new Uint32Array(t.buffer,e,l);<span class="cstat-no" title="statement not covered" ></span>if(n.FeatureTest.isLittleEndian){<span class="cstat-no" title="statement not covered" >for(;o&lt;l-2;o+=3,i+=4){const t=<span class="cstat-no" title="statement not covered" >c[o],</span>e=<span class="cstat-no" title="statement not covered" >c[o+1],</span>n=<span class="cstat-no" title="statement not covered" >c[o+2];<span class="cstat-no" title="statement not covered" ></span>s[i]=4278190080|t;<span class="cstat-no" title="statement not covered" >s</span>[i+1]=t&gt;&gt;&gt;24|e&lt;&lt;8|4278190080;<span class="cstat-no" title="statement not covered" >s</span>[i+2]=e&gt;&gt;&gt;16|n&lt;&lt;16|4278190080;<span class="cstat-no" title="statement not covered" >s</span>[i+3]=n&gt;&gt;&gt;8|4278190080}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let e=<span class="cstat-no" title="statement not covered" >4*o,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;n;e+=3)<span class="cstat-no" title="statement not covered" >s[i++]=t[e]|t[e+1]&lt;&lt;8|t[e+2]&lt;&lt;16|4278190080}</span></span>else{<span class="cstat-no" title="statement not covered" >for(;o&lt;l-2;o+=3,i+=4){const t=<span class="cstat-no" title="statement not covered" >c[o],</span>e=<span class="cstat-no" title="statement not covered" >c[o+1],</span>n=<span class="cstat-no" title="statement not covered" >c[o+2];<span class="cstat-no" title="statement not covered" ></span>s[i]=255|t;<span class="cstat-no" title="statement not covered" >s</span>[i+1]=t&lt;&lt;24|e&gt;&gt;&gt;8|255;<span class="cstat-no" title="statement not covered" >s</span>[i+2]=e&lt;&lt;16|n&gt;&gt;&gt;16|255;<span class="cstat-no" title="statement not covered" >s</span>[i+3]=n&lt;&lt;8|255}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let e=<span class="cstat-no" title="statement not covered" >4*o,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;n;e+=3)<span class="cstat-no" title="statement not covered" >s[i++]=t[e]&lt;&lt;24|t[e+1]&lt;&lt;16|t[e+2]&lt;&lt;8|255}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{srcPos:e,destPos:i}}</span>(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>;<span class="cstat-no" title="statement not covered" >e</span>.grayToRGBA=function <span class="fstat-no" title="function not covered" >grayToRGBA(</span>t,e){<span class="cstat-no" title="statement not covered" >if(n.FeatureTest.isLittleEndian)<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++)<span class="cstat-no" title="statement not covered" >e[s]=65793*t[s]|4278190080;e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++)<span class="cstat-no" title="statement not covered" >e[s]=16843008*t[s]|255}</span></span></span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1);</span>function <span class="fstat-no" title="function not covered" >convertBlackAndWhiteToRGBA(</span>{src:t,srcPos:e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dest:s,width:i,height:a,nonBlackColor:r=<span class="branch-0 cbranch-no" title="branch not covered" >4294967295,</span>inverseDecode:o=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){const l=<span class="cstat-no" title="statement not covered" >n.FeatureTest.isLittleEndian?4278190080:255,</span>[c,h]=<span class="cstat-no" title="statement not covered" >o?[r,l]:[l,r],</span>d=<span class="cstat-no" title="statement not covered" >i&gt;&gt;3,</span>u=<span class="cstat-no" title="statement not covered" >7&amp;i,</span>p=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>s=new Uint32Array(s.buffer);l</span>et g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;a;n++){<span class="cstat-no" title="statement not covered" >for(const n=<span class="cstat-no" title="statement not covered" >e+d;</span>e&lt;n;e++){const n=<span class="cstat-no" title="statement not covered" >e&lt;p?t[e]:255;<span class="cstat-no" title="statement not covered" ></span>s[g++]=128&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=64&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=32&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=16&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=8&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=4&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=2&amp;n?h:c;<span class="cstat-no" title="statement not covered" >s</span>[g++]=1&amp;n?h:c}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===u)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e&lt;p?t[e++]:255;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;u;t++)<span class="cstat-no" title="statement not covered" >s[g++]=n&amp;1&lt;&lt;7-t?h:c}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{srcPos:e,destPos:g}}</span>},<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.GlobalWorkerOptions=void 0;c</span>onst s=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>e.GlobalWorkerOptions=s;<span class="cstat-no" title="statement not covered" >s</span>.workerPort=null;<span class="cstat-no" title="statement not covered" >s</span>.workerSrc=""}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.MessageHandler=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1);</span>const i=<span class="cstat-no" title="statement not covered" >1,</span>a=<span class="cstat-no" title="statement not covered" >2,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >2,</span>l=<span class="cstat-no" title="statement not covered" >3,</span>c=<span class="cstat-no" title="statement not covered" >4,</span>h=<span class="cstat-no" title="statement not covered" >5,</span>d=<span class="cstat-no" title="statement not covered" >6,</span>u=<span class="cstat-no" title="statement not covered" >7,</span>p=<span class="cstat-no" title="statement not covered" >8;</span>function <span class="fstat-no" title="function not covered" >wrapReason(</span>t){<span class="cstat-no" title="statement not covered" >t instanceof Error||"object"==typeof t&amp;&amp;null!==t||(0,n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');<span class="cstat-no" title="statement not covered" >s</span>witch(t.name){case"AbortException":<span class="cstat-no" title="statement not covered" >return new n.AbortException(t.message);c</span>ase"MissingPDFException":<span class="cstat-no" title="statement not covered" >return new n.MissingPDFException(t.message);c</span>ase"PasswordException":<span class="cstat-no" title="statement not covered" >return new n.PasswordException(t.message,t.code);c</span>ase"UnexpectedResponseException":<span class="cstat-no" title="statement not covered" >return new n.UnexpectedResponseException(t.message,t.status);c</span>ase"UnknownErrorException":<span class="cstat-no" title="statement not covered" >return new n.UnknownErrorException(t.message,t.details);d</span>efault:<span class="cstat-no" title="statement not covered" >return new n.UnknownErrorException(t.message,t.toString())}</span>}<span class="cstat-no" title="statement not covered" ></span>e.MessageHandler=class MessageHandler{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >this.sourceName=t;<span class="cstat-no" title="statement not covered" >t</span>his.targetName=e;<span class="cstat-no" title="statement not covered" >t</span>his.comObj=s;<span class="cstat-no" title="statement not covered" >t</span>his.callbackId=1;<span class="cstat-no" title="statement not covered" >t</span>his.streamId=1;<span class="cstat-no" title="statement not covered" >t</span>his.streamSinks=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.streamControllers=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.callbackCapabilities=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.actionHandler=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his._onComObjOnMessage=<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.data;<span class="cstat-no" title="statement not covered" ></span>if(e.targetName!==this.sourceName)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.stream){<span class="cstat-no" title="statement not covered" >this.#Dt(e);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.callback){const t=<span class="cstat-no" title="statement not covered" >e.callbackId,</span>s=<span class="cstat-no" title="statement not covered" >this.callbackCapabilities[t];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot resolve callback ${t}`);<span class="cstat-no" title="statement not covered" >d</span></span>elete this.callbackCapabilities[t];<span class="cstat-no" title="statement not covered" >i</span>f(e.callback===i)<span class="cstat-no" title="statement not covered" >s.resolve(e.data);e</span>lse{<span class="cstat-no" title="statement not covered" >if(e.callback!==a)<span class="cstat-no" title="statement not covered" >throw new Error("Unexpected callback case");<span class="cstat-no" title="statement not covered" >s</span></span>.reject(wrapReason(e.reason))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >this.actionHandler[e.action];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new Error(`Unknown action from worker: ${e.action}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.callbackId){const t=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>r=<span class="cstat-no" title="statement not covered" >e.sourceName;<span class="cstat-no" title="statement not covered" ></span>new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t(n(e.data))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >s.postMessage({sourceName:t,targetName:r,callback:i,callbackId:e.callbackId,data:n})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >s.postMessage({sourceName:t,targetName:r,callback:a,callbackId:e.callbackId,reason:wrapReason(n)})}</span>))}</span>else <span class="cstat-no" title="statement not covered" >e.streamId?this.#It(e):n(e.data)}</span></span>;<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("message",this._onComObjOnMessage)}<span class="fstat-no" title="function not covered" ></span>on</span>(t,e){const s=<span class="cstat-no" title="statement not covered" >this.actionHandler;<span class="cstat-no" title="statement not covered" ></span>if(s[t])<span class="cstat-no" title="statement not covered" >throw new Error(`There is already an actionName called "${t}"`);<span class="cstat-no" title="statement not covered" >s</span></span>[t]=e}<span class="fstat-no" title="function not covered" ></span>se</span>nd(t,e,s){<span class="cstat-no" title="statement not covered" >this.comObj.postMessage({sourceName:this.sourceName,targetName:this.targetName,action:t,data:e},s)}<span class="fstat-no" title="function not covered" ></span>se</span>ndWithPromise(t,e,s){const i=<span class="cstat-no" title="statement not covered" >this.callbackId++,</span>a=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.callbackCapabilities[i]=a;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.comObj.postMessage({sourceName:this.sourceName,targetName:this.targetName,action:t,callbackId:i,data:e},s)}</span>catch(t){<span class="cstat-no" title="statement not covered" >a.reject(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.promise}<span class="fstat-no" title="function not covered" ></span>se</span>ndWithStream(t,e,s,i){const a=<span class="cstat-no" title="statement not covered" >this.streamId++,</span>o=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>l=<span class="cstat-no" title="statement not covered" >this.targetName,</span>c=<span class="cstat-no" title="statement not covered" >this.comObj;<span class="cstat-no" title="statement not covered" ></span>return new ReadableStream({start:<span class="fstat-no" title="function not covered" >s=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.streamControllers[a]={controller:s,startCall:r,pullCall:null,cancelCall:null,isClosed:!1};<span class="cstat-no" title="statement not covered" >c</span>.postMessage({sourceName:o,targetName:l,action:t,streamId:a,data:e,desiredSize:s.desiredSize},i);<span class="cstat-no" title="statement not covered" >r</span>eturn r.promise}</span>,pull:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.streamControllers[a].pullCall=e;<span class="cstat-no" title="statement not covered" >c</span>.postMessage({sourceName:o,targetName:l,stream:d,streamId:a,desiredSize:t.desiredSize});<span class="cstat-no" title="statement not covered" >r</span>eturn e.promise}</span>,cancel:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >(0,n.assert)(t instanceof Error,"cancel must have a valid reason");c</span>onst e=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.streamControllers[a].cancelCall=e;<span class="cstat-no" title="statement not covered" >t</span>his.streamControllers[a].isClosed=!0;<span class="cstat-no" title="statement not covered" >c</span>.postMessage({sourceName:o,targetName:l,stream:r,streamId:a,reason:wrapReason(t)});<span class="cstat-no" title="statement not covered" >r</span>eturn e.promise}</span>},s)}</span>#It(t){const e=<span class="cstat-no" title="statement not covered" >t.streamId,</span>s=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>i=<span class="cstat-no" title="statement not covered" >t.sourceName,</span>a=<span class="cstat-no" title="statement not covered" >this.comObj,</span>r=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this.actionHandler[t.action],</span>d=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >en</span>queue(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>o){<span class="cstat-no" title="statement not covered" >if(this.isCancelled)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >this.desiredSize;<span class="cstat-no" title="statement not covered" ></span>this.desiredSize-=r;<span class="cstat-no" title="statement not covered" >i</span>f(l&gt;0&amp;&amp;this.desiredSize&lt;=0){<span class="cstat-no" title="statement not covered" >this.sinkCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.ready=this.sinkCapability.promise}<span class="cstat-no" title="statement not covered" ></span>a</span>.postMessage({sourceName:s,targetName:i,stream:c,streamId:e,chunk:t},o)}</span>,<span class="fstat-no" title="function not covered" >cl</span>ose(){<span class="cstat-no" title="statement not covered" >if(!this.isCancelled){<span class="cstat-no" title="statement not covered" >this.isCancelled=!0;<span class="cstat-no" title="statement not covered" >a</span>.postMessage({sourceName:s,targetName:i,stream:l,streamId:e});<span class="cstat-no" title="statement not covered" >d</span>elete r.streamSinks[e]}</span>}</span>,<span class="fstat-no" title="function not covered" >er</span>ror(t){<span class="cstat-no" title="statement not covered" >(0,n.assert)(t instanceof Error,"error must have a valid reason");<span class="cstat-no" title="statement not covered" >i</span>f(!this.isCancelled){<span class="cstat-no" title="statement not covered" >this.isCancelled=!0;<span class="cstat-no" title="statement not covered" >a</span>.postMessage({sourceName:s,targetName:i,stream:h,streamId:e,reason:wrapReason(t)})}</span>}</span>,sinkCapability:new n.PromiseCapability,onPull:null,onCancel:null,isCancelled:!1,desiredSize:t.desiredSize,ready:null};<span class="cstat-no" title="statement not covered" ></span>d.sinkCapability.resolve();<span class="cstat-no" title="statement not covered" >d</span>.ready=d.sinkCapability.promise;<span class="cstat-no" title="statement not covered" >t</span>his.streamSinks[e]=d;<span class="cstat-no" title="statement not covered" >n</span>ew Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(o(t.data,d))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:p,streamId:e,success:!0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:p,streamId:e,reason:wrapReason(t)})}</span>))}</span>#Dt(t){const e=<span class="cstat-no" title="statement not covered" >t.streamId,</span>s=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>i=<span class="cstat-no" title="statement not covered" >t.sourceName,</span>a=<span class="cstat-no" title="statement not covered" >this.comObj,</span>g=<span class="cstat-no" title="statement not covered" >this.streamControllers[e],</span>f=<span class="cstat-no" title="statement not covered" >this.streamSinks[e];<span class="cstat-no" title="statement not covered" ></span>switch(t.stream){case p:<span class="cstat-no" title="statement not covered" >t.success?g.startCall.resolve():g.startCall.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase u:<span class="cstat-no" title="statement not covered" >t.success?g.pullCall.resolve():g.pullCall.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase d:<span class="cstat-no" title="statement not covered" >if(!f){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:u,streamId:e,success:!0});<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>f</span>.desiredSize&lt;=0&amp;&amp;t.desiredSize&gt;0&amp;&amp;f.sinkCapability.resolve();<span class="cstat-no" title="statement not covered" >f</span>.desiredSize=t.desiredSize;<span class="cstat-no" title="statement not covered" >n</span>ew Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t(f.onPull?.())}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:u,streamId:e,success:!0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:u,streamId:e,reason:wrapReason(t)})}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase c:<span class="cstat-no" title="statement not covered" >(0,n.assert)(g,"enqueue should have stream controller");<span class="cstat-no" title="statement not covered" >i</span>f(g.isClosed)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >g</span></span>.controller.enqueue(t.chunk);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l:<span class="cstat-no" title="statement not covered" >(0,n.assert)(g,"close should have stream controller");<span class="cstat-no" title="statement not covered" >i</span>f(g.isClosed)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >g</span></span>.isClosed=!0;<span class="cstat-no" title="statement not covered" >g</span>.controller.close();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot(g,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase h:<span class="cstat-no" title="statement not covered" >(0,n.assert)(g,"error should have stream controller");<span class="cstat-no" title="statement not covered" >g</span>.controller.error(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >t</span>his.#Ot(g,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase o:<span class="cstat-no" title="statement not covered" >t.success?g.cancelCall.resolve():g.cancelCall.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >t</span>his.#Ot(g,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase r:<span class="cstat-no" title="statement not covered" >if(!f)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>ew Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(f.onCancel?.(wrapReason(t.reason)))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:o,streamId:e,success:!0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:s,targetName:i,stream:o,streamId:e,reason:wrapReason(t)})}</span>));<span class="cstat-no" title="statement not covered" >f</span>.sinkCapability.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >f</span>.isCancelled=!0;<span class="cstat-no" title="statement not covered" >d</span>elete this.streamSinks[e];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Unexpected stream case")}</span>}</span>async#Ot(t,e){<span class="cstat-no" title="statement not covered" >await Promise.allSettled([t.startCall?.promise,t.pullCall?.promise,t.cancelCall?.promise]);<span class="cstat-no" title="statement not covered" >d</span>elete this.streamControllers[e]}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.comObj.removeEventListener("message",this._onComObjOnMessage)}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.Metadata=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1);<span class="cstat-no" title="statement not covered" ></span>e.Metadata=class Metadata{#Lt;#Nt;<span class="fstat-no" title="function not covered" >co</span>nstructor({parsedData:t,rawData:e}){<span class="cstat-no" title="statement not covered" >this.#Lt=t;<span class="cstat-no" title="statement not covered" >t</span>his.#Nt=e}<span class="fstat-no" title="function not covered" ></span>ge</span>tRaw(){<span class="cstat-no" title="statement not covered" >return this.#Nt}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this.#Lt.get(t)??null}<span class="fstat-no" title="function not covered" ></span>ge</span>tAll(){<span class="cstat-no" title="statement not covered" >return(0,n.objectFromMap)(this.#Lt)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this.#Lt.has(t)}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.OptionalContentConfig=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(8);</span>const a=<span class="cstat-no" title="statement not covered" >Symbol("INTERNAL");</span>class OptionalContentGroup{#Bt=<span class="cstat-no" title="statement not covered" >!0;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.intent=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t visible(){<span class="cstat-no" title="statement not covered" >return this.#Bt}<span class="fstat-no" title="function not covered" ></span>_s</span>etVisible(t,e){<span class="cstat-no" title="statement not covered" >t!==a&amp;&amp;(0,n.unreachable)("Internal method `_setVisible` called.");<span class="cstat-no" title="statement not covered" >t</span>his.#Bt=e}</span>}<span class="cstat-no" title="statement not covered" >e.OptionalContentConfig=class OptionalContentConfig{#jt=<span class="cstat-no" title="statement not covered" >null;</span>#Ut=<span class="cstat-no" title="statement not covered" >new Map;</span>#Ht=<span class="cstat-no" title="statement not covered" >null;</span>#qt=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.name=null;<span class="cstat-no" title="statement not covered" >t</span>his.creator=null;<span class="cstat-no" title="statement not covered" >i</span>f(null!==t){<span class="cstat-no" title="statement not covered" >this.name=t.name;<span class="cstat-no" title="statement not covered" >t</span>his.creator=t.creator;<span class="cstat-no" title="statement not covered" >t</span>his.#qt=t.order;<span class="cstat-no" title="statement not covered" >f</span>or(const e of t.groups)<span class="cstat-no" title="statement not covered" >this.#Ut.set(e.id,new OptionalContentGroup(e.name,e.intent));<span class="cstat-no" title="statement not covered" >i</span></span>f("OFF"===t.baseState)<span class="cstat-no" title="statement not covered" >for(const t of this.#Ut.values())<span class="cstat-no" title="statement not covered" >t._setVisible(a,!1);<span class="cstat-no" title="statement not covered" >f</span></span></span>or(const e of t.on)<span class="cstat-no" title="statement not covered" >this.#Ut.get(e)._setVisible(a,!0);<span class="cstat-no" title="statement not covered" >f</span></span>or(const e of t.off)<span class="cstat-no" title="statement not covered" >this.#Ut.get(e)._setVisible(a,!1);<span class="cstat-no" title="statement not covered" >t</span></span>his.#Ht=this.getHash()}</span>}</span>#Wt(t){const e=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;2)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >1;</span>i&lt;e;i++){const e=<span class="cstat-no" title="statement not covered" >t[i];</span>let a;<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >a=this.#Wt(e);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!this.#Ut.has(e)){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>a</span>=this.#Ut.get(e).visible}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(s){case"And":<span class="cstat-no" title="statement not covered" >if(!a)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"Or":<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"Not":<span class="cstat-no" title="statement not covered" >return!a;d</span>efault:<span class="cstat-no" title="statement not covered" >return!0}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"And"===s}<span class="fstat-no" title="function not covered" ></span>is</span>Visible(t){<span class="cstat-no" title="statement not covered" >if(0===this.#Ut.size)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t){<span class="cstat-no" title="statement not covered" >(0,n.warn)("Optional content group not defined.");<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f("OCG"===t.type){<span class="cstat-no" title="statement not covered" >if(!this.#Ut.has(t.id)){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${t.id}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.#Ut.get(t.id).visible}<span class="cstat-no" title="statement not covered" ></span>i</span>f("OCMD"===t.type){<span class="cstat-no" title="statement not covered" >if(t.expression)<span class="cstat-no" title="statement not covered" >return this.#Wt(t.expression);<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.policy||"AnyOn"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#Ut.has(e)){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#Ut.get(e).visible)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f("AllOn"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#Ut.has(e)){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.#Ut.get(e).visible)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f("AnyOff"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#Ut.has(e)){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.#Ut.get(e).visible)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f("AllOff"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#Ut.has(e)){<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#Ut.get(e).visible)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>(</span>0,n.warn)(`Unknown optional content policy ${t.policy}.`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>(</span>0,n.warn)(`Unknown group type ${t.type}.`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>se</span>tVisibility(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(this.#Ut.has(t)){<span class="cstat-no" title="statement not covered" >this.#Ut.get(t)._setVisible(a,!!e);<span class="cstat-no" title="statement not covered" >t</span>his.#jt=null}</span>else<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Optional content group not found: ${t}`)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t hasInitialVisibility(){<span class="cstat-no" title="statement not covered" >return this.getHash()===this.#Ht}<span class="fstat-no" title="function not covered" ></span>ge</span>tOrder(){<span class="cstat-no" title="statement not covered" >return this.#Ut.size?this.#qt?this.#qt.slice():[...this.#Ut.keys()]:null}<span class="fstat-no" title="function not covered" ></span>ge</span>tGroups(){<span class="cstat-no" title="statement not covered" >return this.#Ut.size&gt;0?(0,n.objectFromMap)(this.#Ut):null}<span class="fstat-no" title="function not covered" ></span>ge</span>tGroup(t){<span class="cstat-no" title="statement not covered" >return this.#Ut.get(t)||null}<span class="fstat-no" title="function not covered" ></span>ge</span>tHash(){<span class="cstat-no" title="statement not covered" >if(null!==this.#jt)<span class="cstat-no" title="statement not covered" >return this.#jt;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new i.MurmurHash3_64;<span class="cstat-no" title="statement not covered" ></span>for(const[e,s]of this.#Ut)<span class="cstat-no" title="statement not covered" >t.update(`${e}:${s.visible}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.#jt=t.hexdigest()}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFDataTransportStream=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(6);<span class="cstat-no" title="statement not covered" ></span>e.PDFDataTransportStream=class PDFDataTransportStream{<span class="fstat-no" title="function not covered" >co</span>nstructor({length:t,initialData:e,progressiveDone:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>contentDispositionFilename:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>disableRange:a=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>disableStream:r=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>,o){<span class="cstat-no" title="statement not covered" >(0,n.assert)(o,'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunks=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressiveDone=s;<span class="cstat-no" title="statement not covered" >t</span>his._contentDispositionFilename=i;<span class="cstat-no" title="statement not covered" >i</span>f(e?.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >e instanceof Uint8Array&amp;&amp;e.byteLength===e.buffer.byteLength?e.buffer:new Uint8Array(e).buffer;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunks.push(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._pdfDataRangeTransport=o;<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!r;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!a;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=t;<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeReaders=[];<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addRangeListener((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this._onReceiveData({begin:t,chunk:e})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addProgressListener((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this._onProgress({loaded:t,total:e})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addProgressiveReadListener((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._onReceiveData({chunk:t})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addProgressiveDoneListener((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._onProgressiveDone()}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.transportReady()}<span class="fstat-no" title="function not covered" ></span>_o</span>nReceiveData({begin:t,chunk:e}){const s=<span class="cstat-no" title="statement not covered" >e instanceof Uint8Array&amp;&amp;e.byteLength===e.buffer.byteLength?e.buffer:new Uint8Array(e).buffer;<span class="cstat-no" title="statement not covered" ></span>if(void 0===t)<span class="cstat-no" title="statement not covered" >this._fullRequestReader?this._fullRequestReader._enqueue(s):this._queuedChunks.push(s);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >this._rangeReaders.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e._begin!==t)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >e</span></span>._enqueue(s);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}</span>));<span class="cstat-no" title="statement not covered" ></span>(0,n.assert)(e,"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.")}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t _progressiveDataLength(){<span class="cstat-no" title="statement not covered" >return this._fullRequestReader?._loaded??0}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgress(t){<span class="cstat-no" title="statement not covered" >void 0===t.total?this._rangeReaders[0]?.onProgress?.({loaded:t.loaded}):this._fullRequestReader?.onProgress?.({loaded:t.loaded,total:t.total})}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgressiveDone(){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.progressiveDone();<span class="cstat-no" title="statement not covered" >t</span>his._progressiveDone=!0}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveRangeReader(t){const e=<span class="cstat-no" title="statement not covered" >this._rangeReaders.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>e&gt;=0&amp;&amp;this._rangeReaders.splice(e,1)}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,n.assert)(!this._fullRequestReader,"PDFDataTransportStream.getFullReader can only be called once.");c</span>onst t=<span class="cstat-no" title="statement not covered" >this._queuedChunks;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunks=null;<span class="cstat-no" title="statement not covered" >r</span>eturn new PDFDataTransportStreamReader(this,t,this._progressiveDone,this._contentDispositionFilename)}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){<span class="cstat-no" title="statement not covered" >if(e&lt;=this._progressiveDataLength)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new PDFDataTransportStreamRangeReader(this,t,e);<span class="cstat-no" title="statement not covered" ></span>this._pdfDataRangeTransport.requestDataRange(t,e);<span class="cstat-no" title="statement not covered" >t</span>his._rangeReaders.push(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t);<span class="cstat-no" title="statement not covered" >t</span></span>his._pdfDataRangeTransport.abort()}</span>};c</span>lass PDFDataTransportStreamReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._done=s||!1;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,i.isPdfFile)(n)?n:null;<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunks=e||[];<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._queuedChunks)<span class="cstat-no" title="statement not covered" >this._loaded+=t.byteLength;<span class="cstat-no" title="statement not covered" >t</span></span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._headersReady=Promise.resolve();<span class="cstat-no" title="statement not covered" >t</span>._fullRequestReader=this;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>_e</span>nqueue(t){<span class="cstat-no" title="statement not covered" >if(!this._done){<span class="cstat-no" title="statement not covered" >if(this._requests.length&gt;0){<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:t,done:!1})}</span>else <span class="cstat-no" title="statement not covered" >this._queuedChunks.push(t);<span class="cstat-no" title="statement not covered" >t</span></span>his._loaded+=t.byteLength}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersReady}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._stream._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._stream._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._stream._contentLength}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._queuedChunks.length&gt;0){<span class="cstat-no" title="statement not covered" >return{value:this._queuedChunks.shift(),done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0}<span class="fstat-no" title="function not covered" ></span>pr</span>ogressiveDone(){<span class="cstat-no" title="statement not covered" >this._done||(this._done=!0)}</span>}class PDFDataTransportStreamRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._begin=e;<span class="cstat-no" title="statement not covered" >t</span>his._end=s;<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunk=null;<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>_e</span>nqueue(t){<span class="cstat-no" title="statement not covered" >if(!this._done){<span class="cstat-no" title="statement not covered" >if(0===this._requests.length)<span class="cstat-no" title="statement not covered" >this._queuedChunk=t;e</span>lse{<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:t,done:!1});<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0}<span class="cstat-no" title="statement not covered" ></span>t</span>his._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._stream._removeRangeReader(this)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._queuedChunk){const t=<span class="cstat-no" title="statement not covered" >this._queuedChunk;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunk=null;<span class="cstat-no" title="statement not covered" >r</span>eturn{value:t,done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._stream._removeRangeReader(this)}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.XfaText=void 0;c</span>lass XfaText{<span class="fstat-no" title="function not covered" >st</span>atic textContent(t){const e=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >{items:e,styles:Object.create(null)};<span class="cstat-no" title="statement not covered" ></span>!function <span class="fstat-no" title="function not covered" >walk(</span>t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >null;</span>const n=<span class="cstat-no" title="statement not covered" >t.name;<span class="cstat-no" title="statement not covered" ></span>if("#text"===n)<span class="cstat-no" title="statement not covered" >s=t.value;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!XfaText.shouldBuildText(n))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>?.attributes?.textContent?s=t.attributes.textContent:t.value&amp;&amp;(s=t.value)}<span class="cstat-no" title="statement not covered" ></span>n</span>ull!==s&amp;&amp;e.push({str:s});<span class="cstat-no" title="statement not covered" >i</span>f(t.children)<span class="cstat-no" title="statement not covered" >for(const e of t.children)<span class="cstat-no" title="statement not covered" >walk(e)}</span></span></span>(t);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>st</span>atic shouldBuildText(t){<span class="cstat-no" title="statement not covered" >return!("textarea"===t||"input"===t||"option"===t||"select"===t)}</span>}<span class="cstat-no" title="statement not covered" >e.XfaText=XfaText}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.NodeStandardFontDataFactory=e.NodeFilterFactory=e.NodeCanvasFactory=e.NodeCMapReaderFactory=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(7);</span>const fetchData=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >require("fs").readFile(t,(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >!t&amp;&amp;n?e(new Uint8Array(n)):s(new Error(t))}</span>))}</span>))}</span>;</span>class NodeFilterFactory extends n.BaseFilterFactory{}<span class="cstat-no" title="statement not covered" >e.NodeFilterFactory=NodeFilterFactory;c</span>lass NodeCanvasFactory extends n.BaseCanvasFactory{<span class="fstat-no" title="function not covered" >_c</span>reateCanvas(t,e){<span class="cstat-no" title="statement not covered" >return require("canvas").createCanvas(t,e)}</span>}<span class="cstat-no" title="statement not covered" >e.NodeCanvasFactory=NodeCanvasFactory;c</span>lass NodeCMapReaderFactory extends n.BaseCMapReaderFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t,e){<span class="cstat-no" title="statement not covered" >return fetchData(t).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{cMapData:t,compressionType:e})</span>))}</span>}<span class="cstat-no" title="statement not covered" >e.NodeCMapReaderFactory=NodeCMapReaderFactory;c</span>lass NodeStandardFontDataFactory extends n.BaseStandardFontDataFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t){<span class="cstat-no" title="statement not covered" >return fetchData(t)}</span>}<span class="cstat-no" title="statement not covered" >e.NodeStandardFontDataFactory=NodeStandardFontDataFactory}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFNodeStream=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(22);</span>const a=<span class="cstat-no" title="statement not covered" >require("fs"),</span>r=<span class="cstat-no" title="statement not covered" >require("http"),</span>o=<span class="cstat-no" title="statement not covered" >require("https"),</span>l=<span class="cstat-no" title="statement not covered" >require("url"),</span>c=<span class="cstat-no" title="statement not covered" >/^file:\/\/\/[a-zA-Z]:\//;<span class="cstat-no" title="statement not covered" ></span>e.PDFNodeStream=class PDFNodeStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.source=t;<span class="cstat-no" title="statement not covered" >t</span>his.url=function <span class="fstat-no" title="function not covered" >parseUrl(</span>t){const e=<span class="cstat-no" title="statement not covered" >l.parse(t);<span class="cstat-no" title="statement not covered" ></span>if("file:"===e.protocol||e.host)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(/^[a-z]:[/\\]/i.test(t))<span class="cstat-no" title="statement not covered" >return l.parse(`file:///${t}`);<span class="cstat-no" title="statement not covered" >e</span></span>.host||(e.protocol="file:");<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>(t.url);<span class="cstat-no" title="statement not covered" >t</span>his.isHttp="http:"===this.url.protocol||"https:"===this.url.protocol;<span class="cstat-no" title="statement not covered" >t</span>his.isFsUrl="file:"===this.url.protocol;<span class="cstat-no" title="statement not covered" >t</span>his.httpHeaders=this.isHttp&amp;&amp;t.httpHeaders||{};<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders=[]}<span class="fstat-no" title="function not covered" ></span>ge</span>t _progressiveDataLength(){<span class="cstat-no" title="statement not covered" >return this._fullRequestReader?._loaded??0}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,n.assert)(!this._fullRequestReader,"PDFNodeStream.getFullReader can only be called once.");<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=this.isFsUrl?new PDFNodeStreamFsFullReader(this):new PDFNodeStreamFullReader(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this._fullRequestReader}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){<span class="cstat-no" title="statement not covered" >if(e&lt;=this._progressiveDataLength)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.isFsUrl?new PDFNodeStreamFsRangeReader(this,t,e):new PDFNodeStreamRangeReader(this,t,e);<span class="cstat-no" title="statement not covered" ></span>this._rangeRequestReaders.push(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeRequestReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t)}</span></span>};c</span>lass BaseFullReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._url=t.url;<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null;c</span>onst e=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._contentLength=e.length;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >t</span>his._filename=null;<span class="cstat-no" title="statement not covered" >t</span>his._disableRange=e.disableRange||!1;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=e.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize||this._disableRange||(this._disableRange=!0);<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!e.disableStream;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!e.disableRange;<span class="cstat-no" title="statement not covered" >t</span>his._readableStream=null;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability=new n.PromiseCapability}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersCapability.promise}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._contentLength}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._readCapability.promise;<span class="cstat-no" title="statement not covered" >i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};<span class="cstat-no" title="statement not covered" >i</span></span>f(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._readableStream.read();<span class="cstat-no" title="statement not covered" ></span>if(null===t){<span class="cstat-no" title="statement not covered" >this._readCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >r</span>eturn this.read()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._loaded+=t.length;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded,total:this._contentLength});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:new Uint8Array(t).buffer,done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._readableStream?this._readableStream.destroy(t):this._error(t)}<span class="fstat-no" title="function not covered" ></span>_e</span>rror(t){<span class="cstat-no" title="statement not covered" >this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>_s</span>etReadableStream(t){<span class="cstat-no" title="statement not covered" >this._readableStream=t;<span class="cstat-no" title="statement not covered" >t</span>.on("readable",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("end",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._error(t)}</span>));<span class="cstat-no" title="statement not covered" >!</span>this._isStreamingSupported&amp;&amp;this._isRangeSupported&amp;&amp;this._error(new n.AbortException("streaming is disabled"));<span class="cstat-no" title="statement not covered" >t</span>his._storedError&amp;&amp;this._readableStream.destroy(this._storedError)}</span>}class BaseRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._url=t.url;<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >t</span>his._readableStream=null;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability=new n.PromiseCapability;c</span>onst e=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._isStreamingSupported=!e.disableStream}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._readCapability.promise;<span class="cstat-no" title="statement not covered" >i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};<span class="cstat-no" title="statement not covered" >i</span></span>f(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._readableStream.read();<span class="cstat-no" title="statement not covered" ></span>if(null===t){<span class="cstat-no" title="statement not covered" >this._readCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >r</span>eturn this.read()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._loaded+=t.length;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:new Uint8Array(t).buffer,done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._readableStream?this._readableStream.destroy(t):this._error(t)}<span class="fstat-no" title="function not covered" ></span>_e</span>rror(t){<span class="cstat-no" title="statement not covered" >this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>_s</span>etReadableStream(t){<span class="cstat-no" title="statement not covered" >this._readableStream=t;<span class="cstat-no" title="statement not covered" >t</span>.on("readable",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("end",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._error(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._storedError&amp;&amp;this._readableStream.destroy(this._storedError)}</span>}function <span class="fstat-no" title="function not covered" >createRequestOptions(</span>t,e){<span class="cstat-no" title="statement not covered" >return{protocol:t.protocol,auth:t.auth,host:t.hostname,port:t.port,path:t.path,method:"GET",headers:e}}</span>class PDFNodeStreamFullReader extends BaseFullReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);c</span>onst handleResponse=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(404===e.statusCode){const t=<span class="cstat-no" title="statement not covered" >new n.MissingPDFException(`Missing PDF "${this._url}".`);<span class="cstat-no" title="statement not covered" ></span>this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.reject(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his._headersCapability.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._setReadableStream(e);c</span>onst getResponseHeader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._readableStream.headers[t.toLowerCase()],</span></span>{allowRangeRequests:s,suggestedLength:a}=<span class="cstat-no" title="statement not covered" >(0,i.validateRangeRequestCapabilities)({getResponseHeader:getResponseHeader,isHttp:t.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});<span class="cstat-no" title="statement not covered" ></span>this._isRangeSupported=s;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=a||this._contentLength;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,i.extractFilenameFromHeader)(getResponseHeader)}</span>;<span class="cstat-no" title="statement not covered" ></span>this._request=null;<span class="cstat-no" title="statement not covered" >"</span>http:"===this._url.protocol?this._request=r.request(createRequestOptions(this._url,t.httpHeaders),handleResponse):this._request=o.request(createRequestOptions(this._url,t.httpHeaders),handleResponse);<span class="cstat-no" title="statement not covered" >t</span>his._request.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.reject(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._request.end()}</span>}class PDFNodeStreamRangeReader extends BaseRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >super(t);<span class="cstat-no" title="statement not covered" >t</span>his._httpHeaders={};<span class="cstat-no" title="statement not covered" >f</span>or(const e in t.httpHeaders){const s=<span class="cstat-no" title="statement not covered" >t.httpHeaders[e];<span class="cstat-no" title="statement not covered" ></span>void 0!==s&amp;&amp;(this._httpHeaders[e]=s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._httpHeaders.Range=`bytes=${e}-${s-1}`;c</span>onst handleResponse=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(404!==t.statusCode)<span class="cstat-no" title="statement not covered" >this._setReadableStream(t);e</span>lse{const t=<span class="cstat-no" title="statement not covered" >new n.MissingPDFException(`Missing PDF "${this._url}".`);<span class="cstat-no" title="statement not covered" ></span>this._storedError=t}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>this._request=null;<span class="cstat-no" title="statement not covered" >"</span>http:"===this._url.protocol?this._request=r.request(createRequestOptions(this._url,this._httpHeaders),handleResponse):this._request=o.request(createRequestOptions(this._url,this._httpHeaders),handleResponse);<span class="cstat-no" title="statement not covered" >t</span>his._request.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._storedError=t}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._request.end()}</span>}class PDFNodeStreamFsFullReader extends BaseFullReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);l</span>et e=<span class="cstat-no" title="statement not covered" >decodeURIComponent(this._url.path);<span class="cstat-no" title="statement not covered" ></span>c.test(this._url.href)&amp;&amp;(e=e.replace(/^\//,""));<span class="cstat-no" title="statement not covered" >a</span>.lstat(e,(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >"ENOENT"===t.code&amp;&amp;(t=new n.MissingPDFException(`Missing PDF "${e}".`));<span class="cstat-no" title="statement not covered" >t</span>his._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.reject(t)}</span>else{<span class="cstat-no" title="statement not covered" >this._contentLength=s.size;<span class="cstat-no" title="statement not covered" >t</span>his._setReadableStream(a.createReadStream(e));<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.resolve()}</span>}</span>))}</span>}class PDFNodeStreamFsRangeReader extends BaseRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >super(t);l</span>et n=<span class="cstat-no" title="statement not covered" >decodeURIComponent(this._url.path);<span class="cstat-no" title="statement not covered" ></span>c.test(this._url.href)&amp;&amp;(n=n.replace(/^\//,""));<span class="cstat-no" title="statement not covered" >t</span>his._setReadableStream(a.createReadStream(n,{start:e,end:s-1}))}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.createResponseStatusError=function <span class="fstat-no" title="function not covered" >createResponseStatusError(</span>t,e){<span class="cstat-no" title="statement not covered" >if(404===t||0===t&amp;&amp;e.startsWith("file:"))<span class="cstat-no" title="statement not covered" >return new n.MissingPDFException('Missing PDF "'+e+'".');<span class="cstat-no" title="statement not covered" >r</span></span>eturn new n.UnexpectedResponseException(`Unexpected server response (${t}) while retrieving PDF "${e}".`,t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.extractFilenameFromHeader=function <span class="fstat-no" title="function not covered" >extractFilenameFromHeader(</span>t){const e=<span class="cstat-no" title="statement not covered" >t("Content-Disposition");<span class="cstat-no" title="statement not covered" ></span>if(e){let t=<span class="cstat-no" title="statement not covered" >(0,i.getFilenameFromContentDispositionHeader)(e);<span class="cstat-no" title="statement not covered" ></span>if(t.includes("%"))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=decodeURIComponent(t)}</span>catch{}<span class="cstat-no" title="statement not covered" >i</span></span>f((0,a.isPdfFile)(t))<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>;<span class="cstat-no" title="statement not covered" >e</span>.validateRangeRequestCapabilities=function <span class="fstat-no" title="function not covered" >validateRangeRequestCapabilities(</span>{getResponseHeader:t,isHttp:e,rangeChunkSize:s,disableRange:n}){const i=<span class="cstat-no" title="statement not covered" >{allowRangeRequests:!1,suggestedLength:void 0},</span>a=<span class="cstat-no" title="statement not covered" >parseInt(t("Content-Length"),10);<span class="cstat-no" title="statement not covered" ></span>if(!Number.isInteger(a))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>.suggestedLength=a;<span class="cstat-no" title="statement not covered" >i</span>f(a&lt;=2*s)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f(n||!e)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f("bytes"!==t("Accept-Ranges"))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f("identity"!==(t("Content-Encoding")||"identity"))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>.allowRangeRequests=!0;<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>;<span class="cstat-no" title="statement not covered" >e</span>.validateResponseStatus=function <span class="fstat-no" title="function not covered" >validateResponseStatus(</span>t){<span class="cstat-no" title="statement not covered" >return 200===t||206===t}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(23),</span>a=<span class="cstat-no" title="statement not covered" >s(6)}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.getFilenameFromContentDispositionHeader=function <span class="fstat-no" title="function not covered" >getFilenameFromContentDispositionHeader(</span>t){let e=<span class="cstat-no" title="statement not covered" >!0,</span>s=<span class="cstat-no" title="statement not covered" >toParamRegExp("filename\\*","i").exec(t);<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >s=s[1];l</span>et t=<span class="cstat-no" title="statement not covered" >rfc2616unquote(s);<span class="cstat-no" title="statement not covered" ></span>t=unescape(t);<span class="cstat-no" title="statement not covered" >t</span>=rfc5987decode(t);<span class="cstat-no" title="statement not covered" >t</span>=rfc2047decode(t);<span class="cstat-no" title="statement not covered" >r</span>eturn fixupEncoding(t)}<span class="cstat-no" title="statement not covered" ></span>s</span>=function <span class="fstat-no" title="function not covered" >rfc2231getparam(</span>t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let s;const n=<span class="cstat-no" title="statement not covered" >toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)","ig");<span class="cstat-no" title="statement not covered" ></span>for(;null!==(s=n.exec(t));){let[,t,n,i]=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>t=parseInt(t,10);<span class="cstat-no" title="statement not covered" >i</span>f(t in e){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >break}</span></span>else <span class="cstat-no" title="statement not covered" >e[t]=[n,i]}</span></span>c</span>onst i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length&amp;&amp;t in e;++t){let[s,n]=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>n=rfc2616unquote(n);<span class="cstat-no" title="statement not covered" >i</span>f(s){<span class="cstat-no" title="statement not covered" >n=unescape(n);<span class="cstat-no" title="statement not covered" >0</span>===t&amp;&amp;(n=rfc5987decode(n))}<span class="cstat-no" title="statement not covered" ></span>i</span>.push(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.join("")}</span>(t);<span class="cstat-no" title="statement not covered" >i</span>f(s){<span class="cstat-no" title="statement not covered" >return fixupEncoding(rfc2047decode(s))}<span class="cstat-no" title="statement not covered" ></span>s</span>=toParamRegExp("filename","i").exec(t);<span class="cstat-no" title="statement not covered" >i</span>f(s){<span class="cstat-no" title="statement not covered" >s=s[1];l</span>et t=<span class="cstat-no" title="statement not covered" >rfc2616unquote(s);<span class="cstat-no" title="statement not covered" ></span>t=rfc2047decode(t);<span class="cstat-no" title="statement not covered" >r</span>eturn fixupEncoding(t)}</span>f</span>unction <span class="fstat-no" title="function not covered" >toParamRegExp(</span>t,e){<span class="cstat-no" title="statement not covered" >return new RegExp("(?:^|;)\\s*"+t+'\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)',e)}</span>function <span class="fstat-no" title="function not covered" >textdecode(</span>t,s){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >if(!/^[\x00-\xFF]+$/.test(s))<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >t</span></span>ry{const i=<span class="cstat-no" title="statement not covered" >new TextDecoder(t,{fatal:!0}),</span>a=<span class="cstat-no" title="statement not covered" >(0,n.stringToBytes)(s);<span class="cstat-no" title="statement not covered" ></span>s=i.decode(a);<span class="cstat-no" title="statement not covered" >e</span>=!1}</span>catch{}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>function <span class="fstat-no" title="function not covered" >fixupEncoding(</span>t){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;/[\x80-\xff]/.test(t)){<span class="cstat-no" title="statement not covered" >t=textdecode("utf-8",t);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(t=textdecode("iso-8859-1",t))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >rfc2616unquote(</span>t){<span class="cstat-no" title="statement not covered" >if(t.startsWith('"')){const e=<span class="cstat-no" title="statement not covered" >t.slice(1).split('\\"');<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;++t){const s=<span class="cstat-no" title="statement not covered" >e[t].indexOf('"');<span class="cstat-no" title="statement not covered" ></span>if(-1!==s){<span class="cstat-no" title="statement not covered" >e[t]=e[t].slice(0,s);<span class="cstat-no" title="statement not covered" >e</span>.length=t+1}<span class="cstat-no" title="statement not covered" ></span>e</span>[t]=e[t].replaceAll(/\\(.)/g,"$1")}<span class="cstat-no" title="statement not covered" ></span>t</span>=e.join('"')}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >rfc5987decode(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.indexOf("'");<span class="cstat-no" title="statement not covered" ></span>if(-1===e)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn textdecode(t.slice(0,e),t.slice(e+1).replace(/^[^']*'/,""))}</span>function <span class="fstat-no" title="function not covered" >rfc2047decode(</span>t){<span class="cstat-no" title="statement not covered" >return!t.startsWith("=?")||/[\x00-\x19\x80-\xff]/.test(t)?t:t.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,s,n){<span class="cstat-no" title="statement not covered" >if("q"===s||"Q"===s)<span class="cstat-no" title="statement not covered" >return textdecode(e,n=(n=n.replaceAll("_"," ")).replaceAll(/=([0-9a-fA-F]{2})/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return String.fromCharCode(parseInt(e,16))}</span>)));<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >n=atob(n)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn textdecode(e,n)}</span>))}<span class="cstat-no" title="statement not covered" ></span>return""}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1)}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFNetworkStream=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(22);</span>class NetworkManager{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.url=t;<span class="cstat-no" title="statement not covered" >t</span>his.isHttp=/^https?:/i.test(t);<span class="cstat-no" title="statement not covered" >t</span>his.httpHeaders=this.isHttp&amp;&amp;e.httpHeaders||Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.withCredentials=e.withCredentials||!1;<span class="cstat-no" title="statement not covered" >t</span>his.currXhrId=0;<span class="cstat-no" title="statement not covered" >t</span>his.pendingRequests=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>re</span>questRange(t,e,s){const n=<span class="cstat-no" title="statement not covered" >{begin:t,end:e};<span class="cstat-no" title="statement not covered" ></span>for(const t in s)<span class="cstat-no" title="statement not covered" >n[t]=s[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.request(n)}<span class="fstat-no" title="function not covered" ></span>re</span>questFull(t){<span class="cstat-no" title="statement not covered" >return this.request(t)}<span class="fstat-no" title="function not covered" ></span>re</span>quest(t){const e=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest,</span>s=<span class="cstat-no" title="statement not covered" >this.currXhrId++,</span>n=<span class="cstat-no" title="statement not covered" >this.pendingRequests[s]={xhr:e};<span class="cstat-no" title="statement not covered" ></span>e.open("GET",this.url);<span class="cstat-no" title="statement not covered" >e</span>.withCredentials=this.withCredentials;<span class="cstat-no" title="statement not covered" >f</span>or(const t in this.httpHeaders){const s=<span class="cstat-no" title="statement not covered" >this.httpHeaders[t];<span class="cstat-no" title="statement not covered" ></span>void 0!==s&amp;&amp;e.setRequestHeader(t,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.isHttp&amp;&amp;"begin"in t&amp;&amp;"end"in t){<span class="cstat-no" title="statement not covered" >e.setRequestHeader("Range",`bytes=${t.begin}-${t.end-1}`);<span class="cstat-no" title="statement not covered" >n</span>.expectedStatus=206}</span>else <span class="cstat-no" title="statement not covered" >n.expectedStatus=200;<span class="cstat-no" title="statement not covered" >e</span></span>.responseType="arraybuffer";<span class="cstat-no" title="statement not covered" >t</span>.onError&amp;&amp;(e.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >t.onError(e.status)}</span>);<span class="cstat-no" title="statement not covered" >e</span>.onreadystatechange=this.onStateChange.bind(this,s);<span class="cstat-no" title="statement not covered" >e</span>.onprogress=this.onProgress.bind(this,s);<span class="cstat-no" title="statement not covered" >n</span>.onHeadersReceived=t.onHeadersReceived;<span class="cstat-no" title="statement not covered" >n</span>.onDone=t.onDone;<span class="cstat-no" title="statement not covered" >n</span>.onError=t.onError;<span class="cstat-no" title="statement not covered" >n</span>.onProgress=t.onProgress;<span class="cstat-no" title="statement not covered" >e</span>.send(null);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>on</span>Progress(t,e){const s=<span class="cstat-no" title="statement not covered" >this.pendingRequests[t];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;s.onProgress?.(e)}<span class="fstat-no" title="function not covered" ></span>on</span>StateChange(t,e){const s=<span class="cstat-no" title="statement not covered" >this.pendingRequests[t];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >s.xhr;<span class="cstat-no" title="statement not covered" ></span>if(i.readyState&gt;=2&amp;&amp;s.onHeadersReceived){<span class="cstat-no" title="statement not covered" >s.onHeadersReceived();<span class="cstat-no" title="statement not covered" >d</span>elete s.onHeadersReceived}<span class="cstat-no" title="statement not covered" ></span>i</span>f(4!==i.readyState)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!(t in this.pendingRequests))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete this.pendingRequests[t];<span class="cstat-no" title="statement not covered" >i</span>f(0===i.status&amp;&amp;this.isHttp){<span class="cstat-no" title="statement not covered" >s.onError?.(i.status);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >i.status||200;<span class="cstat-no" title="statement not covered" ></span>if(!(200===a&amp;&amp;206===s.expectedStatus)&amp;&amp;a!==s.expectedStatus){<span class="cstat-no" title="statement not covered" >s.onError?.(i.status);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >getArrayBuffer(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.response;<span class="cstat-no" title="statement not covered" ></span>return"string"!=typeof e?e:(0,n.stringToBytes)(e).buffer}</span>(i);<span class="cstat-no" title="statement not covered" ></span>if(206===a){const t=<span class="cstat-no" title="statement not covered" >i.getResponseHeader("Content-Range"),</span>e=<span class="cstat-no" title="statement not covered" >/bytes (\d+)-(\d+)\/(\d+)/.exec(t);<span class="cstat-no" title="statement not covered" ></span>s.onDone({begin:parseInt(e[1],10),chunk:r})}</span>else <span class="cstat-no" title="statement not covered" >r?s.onDone({begin:0,chunk:r}):s.onError?.(i.status)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tRequestXhr(t){<span class="cstat-no" title="statement not covered" >return this.pendingRequests[t].xhr}<span class="fstat-no" title="function not covered" ></span>is</span>PendingRequest(t){<span class="cstat-no" title="statement not covered" >return t in this.pendingRequests}<span class="fstat-no" title="function not covered" ></span>ab</span>ortRequest(t){const e=<span class="cstat-no" title="statement not covered" >this.pendingRequests[t].xhr;<span class="cstat-no" title="statement not covered" ></span>delete this.pendingRequests[t];<span class="cstat-no" title="statement not covered" >e</span>.abort()}</span>}<span class="cstat-no" title="statement not covered" >e.PDFNetworkStream=class PDFNetworkStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._source=t;<span class="cstat-no" title="statement not covered" >t</span>his._manager=new NetworkManager(t.url,{httpHeaders:t.httpHeaders,withCredentials:t.withCredentials});<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=t.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders=[]}<span class="fstat-no" title="function not covered" ></span>_o</span>nRangeRequestReaderClosed(t){const e=<span class="cstat-no" title="statement not covered" >this._rangeRequestReaders.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>e&gt;=0&amp;&amp;this._rangeRequestReaders.splice(e,1)}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,n.assert)(!this._fullRequestReader,"PDFNetworkStream.getFullReader can only be called once.");<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=new PDFNetworkStreamFullRequestReader(this._manager,this._source);<span class="cstat-no" title="statement not covered" >r</span>eturn this._fullRequestReader}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){const s=<span class="cstat-no" title="statement not covered" >new PDFNetworkStreamRangeRequestReader(this._manager,t,e);<span class="cstat-no" title="statement not covered" ></span>s.onClosed=this._onRangeRequestReaderClosed.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders.push(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeRequestReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t)}</span></span>};c</span>lass PDFNetworkStreamFullRequestReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._manager=t;c</span>onst s=<span class="cstat-no" title="statement not covered" >{onHeadersReceived:this._onHeadersReceived.bind(this),onDone:this._onDone.bind(this),onError:this._onError.bind(this),onProgress:this._onProgress.bind(this)};<span class="cstat-no" title="statement not covered" ></span>this._url=e.url;<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestId=t.requestFull(s);<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._disableRange=e.disableRange||!1;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=e.length;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=e.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize||this._disableRange||(this._disableRange=!0);<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!1;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedChunks=[];<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=void 0;<span class="cstat-no" title="statement not covered" >t</span>his._filename=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>_o</span>nHeadersReceived(){const t=<span class="cstat-no" title="statement not covered" >this._fullRequestId,</span>e=<span class="cstat-no" title="statement not covered" >this._manager.getRequestXhr(t),</span>getResponseHeader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.getResponseHeader(t),</span></span>{allowRangeRequests:s,suggestedLength:n}=<span class="cstat-no" title="statement not covered" >(0,i.validateRangeRequestCapabilities)({getResponseHeader:getResponseHeader,isHttp:this._manager.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(this._isRangeSupported=!0);<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=n||this._contentLength;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,i.extractFilenameFromHeader)(getResponseHeader);<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported&amp;&amp;this._manager.abortRequest(t);<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>_o</span>nDone(t){<span class="cstat-no" title="statement not covered" >if(t)<span class="cstat-no" title="statement not covered" >if(this._requests.length&gt;0){<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:t.chunk,done:!1})}</span>else <span class="cstat-no" title="statement not covered" >this._cachedChunks.push(t.chunk);<span class="cstat-no" title="statement not covered" >t</span></span></span>his._done=!0;<span class="cstat-no" title="statement not covered" >i</span>f(!(this._cachedChunks.length&gt;0)){<span class="cstat-no" title="statement not covered" >for(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0}</span>}<span class="fstat-no" title="function not covered" ></span>_o</span>nError(t){<span class="cstat-no" title="statement not covered" >this._storedError=(0,i.createResponseStatusError)(t,this._url);<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability.reject(this._storedError);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.reject(this._storedError);<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._cachedChunks.length=0}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgress(t){<span class="cstat-no" title="statement not covered" >this.onProgress?.({loaded:t.loaded,total:t.lengthComputable?t.total:this._contentLength})}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._contentLength}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersReceivedCapability.promise}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._cachedChunks.length&gt;0){<span class="cstat-no" title="statement not covered" >return{value:this._cachedChunks.shift(),done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability.reject(t);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._manager.isPendingRequest(this._fullRequestId)&amp;&amp;this._manager.abortRequest(this._fullRequestId);<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null}</span>}class PDFNetworkStreamRangeRequestReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >this._manager=t;c</span>onst n=<span class="cstat-no" title="statement not covered" >{onDone:this._onDone.bind(this),onError:this._onError.bind(this),onProgress:this._onProgress.bind(this)};<span class="cstat-no" title="statement not covered" ></span>this._url=t.url;<span class="cstat-no" title="statement not covered" >t</span>his._requestId=t.requestRange(e,s,n);<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunk=null;<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=void 0;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null;<span class="cstat-no" title="statement not covered" >t</span>his.onClosed=null}<span class="fstat-no" title="function not covered" ></span>_c</span>lose(){<span class="cstat-no" title="statement not covered" >this.onClosed?.(this)}<span class="fstat-no" title="function not covered" ></span>_o</span>nDone(t){const e=<span class="cstat-no" title="statement not covered" >t.chunk;<span class="cstat-no" title="statement not covered" ></span>if(this._requests.length&gt;0){<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:e,done:!1})}</span>else <span class="cstat-no" title="statement not covered" >this._queuedChunk=e;<span class="cstat-no" title="statement not covered" >t</span></span>his._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._close()}<span class="fstat-no" title="function not covered" ></span>_o</span>nError(t){<span class="cstat-no" title="statement not covered" >this._storedError=(0,i.createResponseStatusError)(t,this._url);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.reject(this._storedError);<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunk=null}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgress(t){<span class="cstat-no" title="statement not covered" >this.isStreamingSupported||this.onProgress?.({loaded:t.loaded})}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;<span class="cstat-no" title="statement not covered" >i</span></span>f(null!==this._queuedChunk){const t=<span class="cstat-no" title="statement not covered" >this._queuedChunk;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunk=null;<span class="cstat-no" title="statement not covered" >r</span>eturn{value:t,done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._manager.isPendingRequest(this._requestId)&amp;&amp;this._manager.abortRequest(this._requestId);<span class="cstat-no" title="statement not covered" >t</span>his._close()}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFFetchStream=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(22);</span>function <span class="fstat-no" title="function not covered" >createFetchOptions(</span>t,e,s){<span class="cstat-no" title="statement not covered" >return{method:"GET",headers:t,signal:s.signal,mode:"cors",credentials:e?"include":"same-origin",redirect:"follow"}}</span>function <span class="fstat-no" title="function not covered" >createHeaders(</span>t){const e=<span class="cstat-no" title="statement not covered" >new Headers;<span class="cstat-no" title="statement not covered" ></span>for(const s in t){const n=<span class="cstat-no" title="statement not covered" >t[s];<span class="cstat-no" title="statement not covered" ></span>void 0!==n&amp;&amp;e.append(s,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >getArrayBuffer(</span>t){<span class="cstat-no" title="statement not covered" >if(t instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return t.buffer;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ArrayBuffer)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >(</span></span>0,n.warn)(`getArrayBuffer - unexpected data format: ${t}`);<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(t).buffer}<span class="cstat-no" title="statement not covered" ></span>e.PDFFetchStream=class PDFFetchStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.source=t;<span class="cstat-no" title="statement not covered" >t</span>his.isHttp=/^https?:/i.test(t.url);<span class="cstat-no" title="statement not covered" >t</span>his.httpHeaders=this.isHttp&amp;&amp;t.httpHeaders||{};<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders=[]}<span class="fstat-no" title="function not covered" ></span>ge</span>t _progressiveDataLength(){<span class="cstat-no" title="statement not covered" >return this._fullRequestReader?._loaded??0}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,n.assert)(!this._fullRequestReader,"PDFFetchStream.getFullReader can only be called once.");<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=new PDFFetchStreamReader(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this._fullRequestReader}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){<span class="cstat-no" title="statement not covered" >if(e&lt;=this._progressiveDataLength)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new PDFFetchStreamRangeReader(this,t,e);<span class="cstat-no" title="statement not covered" ></span>this._rangeRequestReaders.push(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeRequestReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t)}</span></span>};c</span>lass PDFFetchStreamReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._reader=null;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >t</span>his._filename=null;c</span>onst e=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._withCredentials=e.withCredentials||!1;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=e.length;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._disableRange=e.disableRange||!1;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=e.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize||this._disableRange||(this._disableRange=!0);<span class="cstat-no" title="statement not covered" >t</span>his._abortController=new AbortController;<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!e.disableStream;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!e.disableRange;<span class="cstat-no" title="statement not covered" >t</span>his._headers=createHeaders(this._stream.httpHeaders);c</span>onst s=<span class="cstat-no" title="statement not covered" >e.url;<span class="cstat-no" title="statement not covered" ></span>fetch(s,createFetchOptions(this._headers,this._withCredentials,this._abortController)).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!(0,i.validateResponseStatus)(t.status))<span class="cstat-no" title="statement not covered" >throw(0,i.createResponseStatusError)(t.status,s);<span class="cstat-no" title="statement not covered" >t</span></span>his._reader=t.body.getReader();<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.resolve();c</span>onst getResponseHeader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.headers.get(e),</span></span>{allowRangeRequests:e,suggestedLength:a}=<span class="cstat-no" title="statement not covered" >(0,i.validateRangeRequestCapabilities)({getResponseHeader:getResponseHeader,isHttp:this._stream.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});<span class="cstat-no" title="statement not covered" ></span>this._isRangeSupported=e;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=a||this._contentLength;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,i.extractFilenameFromHeader)(getResponseHeader);<span class="cstat-no" title="statement not covered" >!</span>this._isStreamingSupported&amp;&amp;this._isRangeSupported&amp;&amp;this.cancel(new n.AbortException("Streaming is disabled."))}</span>)).catch(this._headersCapability.reject);<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersCapability.promise}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._contentLength}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._headersCapability.promise;c</span>onst{value:t,done:e}=<span class="cstat-no" title="statement not covered" >await this._reader.read();<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return{value:t,done:e};<span class="cstat-no" title="statement not covered" >t</span></span>his._loaded+=t.byteLength;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded,total:this._contentLength});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:getArrayBuffer(t),done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._reader?.cancel(t);<span class="cstat-no" title="statement not covered" >t</span>his._abortController.abort()}</span>}class PDFFetchStreamRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._reader=null;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;c</span>onst a=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._withCredentials=a.withCredentials||!1;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!a.disableStream;<span class="cstat-no" title="statement not covered" >t</span>his._abortController=new AbortController;<span class="cstat-no" title="statement not covered" >t</span>his._headers=createHeaders(this._stream.httpHeaders);<span class="cstat-no" title="statement not covered" >t</span>his._headers.append("Range",`bytes=${e}-${s-1}`);c</span>onst r=<span class="cstat-no" title="statement not covered" >a.url;<span class="cstat-no" title="statement not covered" ></span>fetch(r,createFetchOptions(this._headers,this._withCredentials,this._abortController)).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!(0,i.validateResponseStatus)(t.status))<span class="cstat-no" title="statement not covered" >throw(0,i.createResponseStatusError)(t.status,r);<span class="cstat-no" title="statement not covered" >t</span></span>his._readCapability.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._reader=t.body.getReader()}</span>)).catch(this._readCapability.reject);<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._readCapability.promise;c</span>onst{value:t,done:e}=<span class="cstat-no" title="statement not covered" >await this._reader.read();<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return{value:t,done:e};<span class="cstat-no" title="statement not covered" >t</span></span>his._loaded+=t.byteLength;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:getArrayBuffer(t),done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._reader?.cancel(t);<span class="cstat-no" title="statement not covered" >t</span>his._abortController.abort()}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.TextLayerRenderTask=void 0;<span class="cstat-no" title="statement not covered" >e</span>.renderTextLayer=function <span class="fstat-no" title="function not covered" >renderTextLayer(</span>t){<span class="cstat-no" title="statement not covered" >if(!t.textContentSource&amp;&amp;(t.textContent||t.textContentStream)){<span class="cstat-no" title="statement not covered" >(0,i.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.");<span class="cstat-no" title="statement not covered" >t</span>.textContentSource=t.textContent||t.textContentStream}</span>c</span>onst{container:e,viewport:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >getComputedStyle(e),</span>a=<span class="cstat-no" title="statement not covered" >n.getPropertyValue("visibility"),</span>r=<span class="cstat-no" title="statement not covered" >parseFloat(n.getPropertyValue("--scale-factor"));<span class="cstat-no" title="statement not covered" ></span>"visible"===a&amp;&amp;(!r||Math.abs(r-s.scale)&gt;1e-5)&amp;&amp;console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");c</span>onst o=<span class="cstat-no" title="statement not covered" >new TextLayerRenderTask(t);<span class="cstat-no" title="statement not covered" ></span>o._render();<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>;<span class="cstat-no" title="statement not covered" >e</span>.updateTextLayer=function <span class="fstat-no" title="function not covered" >updateTextLayer(</span>{container:t,viewport:e,textDivs:s,textDivProperties:n,isOffscreenCanvasSupported:a,mustRotate:r=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>mustRescale:o=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>){<span class="cstat-no" title="statement not covered" >r&amp;&amp;(0,i.setLayerDimensions)(t,{rotation:e.rotation});<span class="cstat-no" title="statement not covered" >i</span>f(o){const t=<span class="cstat-no" title="statement not covered" >getCtx(0,a),</span>i=<span class="cstat-no" title="statement not covered" >{prevFontSize:null,prevFontFamily:null,div:null,scale:e.scale*(globalThis.devicePixelRatio||1),properties:null,ctx:t};<span class="cstat-no" title="statement not covered" ></span>for(const t of s){<span class="cstat-no" title="statement not covered" >i.properties=n.get(t);<span class="cstat-no" title="statement not covered" >i</span>.div=t;<span class="cstat-no" title="statement not covered" >l</span>ayout(i)}</span>}</span>}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(6);</span>const a=<span class="cstat-no" title="statement not covered" >30,</span>r=<span class="cstat-no" title="statement not covered" >.8,</span>o=<span class="cstat-no" title="statement not covered" >new Map;</span>function <span class="fstat-no" title="function not covered" >getCtx(</span>t,e){let s;<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;n.FeatureTest.isOffscreenCanvasSupported)<span class="cstat-no" title="statement not covered" >s=new OffscreenCanvas(t,t).getContext("2d",{alpha:!1});e</span>lse{const e=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>e.width=e.height=t;<span class="cstat-no" title="statement not covered" >s</span>=e.getContext("2d",{alpha:!1})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>function <span class="fstat-no" title="function not covered" >appendText(</span>t,e,s){const i=<span class="cstat-no" title="statement not covered" >document.createElement("span"),</span>l=<span class="cstat-no" title="statement not covered" >{angle:0,canvasWidth:0,hasText:""!==e.str,hasEOL:e.hasEOL,fontSize:0};<span class="cstat-no" title="statement not covered" ></span>t._textDivs.push(i);c</span>onst c=<span class="cstat-no" title="statement not covered" >n.Util.transform(t._transform,e.transform);</span>let h=<span class="cstat-no" title="statement not covered" >Math.atan2(c[1],c[0]);</span>const d=<span class="cstat-no" title="statement not covered" >s[e.fontName];<span class="cstat-no" title="statement not covered" ></span>d.vertical&amp;&amp;(h+=Math.PI/2);c</span>onst u=<span class="cstat-no" title="statement not covered" >Math.hypot(c[2],c[3]),</span>p=<span class="cstat-no" title="statement not covered" >u*function <span class="fstat-no" title="function not covered" >getAscent(</span>t,e){const s=<span class="cstat-no" title="statement not covered" >o.get(t);<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return s;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >getCtx(a,e);<span class="cstat-no" title="statement not covered" ></span>n.font=`${a}px ${t}`;c</span>onst i=<span class="cstat-no" title="statement not covered" >n.measureText("");</span>let l=<span class="cstat-no" title="statement not covered" >i.fontBoundingBoxAscent,</span>c=<span class="cstat-no" title="statement not covered" >Math.abs(i.fontBoundingBoxDescent);<span class="cstat-no" title="statement not covered" ></span>if(l){const e=<span class="cstat-no" title="statement not covered" >l/(l+c);<span class="cstat-no" title="statement not covered" ></span>o.set(t,e);<span class="cstat-no" title="statement not covered" >n</span>.canvas.width=n.canvas.height=0;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>n</span>.strokeStyle="red";<span class="cstat-no" title="statement not covered" >n</span>.clearRect(0,0,a,a);<span class="cstat-no" title="statement not covered" >n</span>.strokeText("g",0,0);l</span>et h=<span class="cstat-no" title="statement not covered" >n.getImageData(0,0,a,a).data;<span class="cstat-no" title="statement not covered" ></span>c=0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >h.length-1-3;</span>t&gt;=0;t-=4)<span class="cstat-no" title="statement not covered" >if(h[t]&gt;0){<span class="cstat-no" title="statement not covered" >c=Math.ceil(t/4/a);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>n</span></span>.clearRect(0,0,a,a);<span class="cstat-no" title="statement not covered" >n</span>.strokeText("A",0,a);<span class="cstat-no" title="statement not covered" >h</span>=n.getImageData(0,0,a,a).data;<span class="cstat-no" title="statement not covered" >l</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >h.length;</span>t&lt;e;t+=4)<span class="cstat-no" title="statement not covered" >if(h[t]&gt;0){<span class="cstat-no" title="statement not covered" >l=a-Math.floor(t/4/a);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>n</span></span>.canvas.width=n.canvas.height=0;<span class="cstat-no" title="statement not covered" >i</span>f(l){const e=<span class="cstat-no" title="statement not covered" >l/(l+c);<span class="cstat-no" title="statement not covered" ></span>o.set(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>o</span>.set(t,r);<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>(d.fontFamily,t._isOffscreenCanvasSupported);</span>let g,f;<span class="cstat-no" title="statement not covered" >if(0===h){<span class="cstat-no" title="statement not covered" >g=c[4];<span class="cstat-no" title="statement not covered" >f</span>=c[5]-p}</span>else{<span class="cstat-no" title="statement not covered" >g=c[4]+p*Math.sin(h);<span class="cstat-no" title="statement not covered" >f</span>=c[5]-p*Math.cos(h)}</span>c</span>onst m=<span class="cstat-no" title="statement not covered" >"calc(var(--scale-factor)*",</span>b=<span class="cstat-no" title="statement not covered" >i.style;<span class="cstat-no" title="statement not covered" ></span>if(t._container===t._rootContainer){<span class="cstat-no" title="statement not covered" >b.left=`${(100*g/t._pageWidth).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >b</span>.top=`${(100*f/t._pageHeight).toFixed(2)}%`}</span>else{<span class="cstat-no" title="statement not covered" >b.left=`${m}${g.toFixed(2)}px)`;<span class="cstat-no" title="statement not covered" >b</span>.top=`${m}${f.toFixed(2)}px)`}<span class="cstat-no" title="statement not covered" ></span>b</span>.fontSize=`${m}${u.toFixed(2)}px)`;<span class="cstat-no" title="statement not covered" >b</span>.fontFamily=d.fontFamily;<span class="cstat-no" title="statement not covered" >l</span>.fontSize=u;<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("role","presentation");<span class="cstat-no" title="statement not covered" >i</span>.textContent=e.str;<span class="cstat-no" title="statement not covered" >i</span>.dir=e.dir;<span class="cstat-no" title="statement not covered" >t</span>._fontInspectorEnabled&amp;&amp;(i.dataset.fontName=e.fontName);<span class="cstat-no" title="statement not covered" >0</span>!==h&amp;&amp;(l.angle=h*(180/Math.PI));l</span>et A=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(e.str.length&gt;1)<span class="cstat-no" title="statement not covered" >A=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(" "!==e.str&amp;&amp;e.transform[0]!==e.transform[3]){const t=<span class="cstat-no" title="statement not covered" >Math.abs(e.transform[0]),</span>s=<span class="cstat-no" title="statement not covered" >Math.abs(e.transform[3]);<span class="cstat-no" title="statement not covered" ></span>t!==s&amp;&amp;Math.max(t,s)/Math.min(t,s)&gt;1.5&amp;&amp;(A=!0)}<span class="cstat-no" title="statement not covered" ></span>A</span></span>&amp;&amp;(l.canvasWidth=d.vertical?e.height:e.width);<span class="cstat-no" title="statement not covered" >t</span>._textDivProperties.set(i,l);<span class="cstat-no" title="statement not covered" >t</span>._isReadableStream&amp;&amp;t._layoutText(i)}</span>function <span class="fstat-no" title="function not covered" >layout(</span>t){const{div:e,scale:s,properties:n,ctx:i,prevFontSize:a,prevFontFamily:r}=<span class="cstat-no" title="statement not covered" >t,</span>{style:o}=<span class="cstat-no" title="statement not covered" >e;</span>let l=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(0!==n.canvasWidth&amp;&amp;n.hasText){const{fontFamily:c}=<span class="cstat-no" title="statement not covered" >o,</span>{canvasWidth:h,fontSize:d}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(a!==d||r!==c){<span class="cstat-no" title="statement not covered" >i.font=`${d*s}px ${c}`;<span class="cstat-no" title="statement not covered" >t</span>.prevFontSize=d;<span class="cstat-no" title="statement not covered" >t</span>.prevFontFamily=c}</span>c</span>onst{width:u}=<span class="cstat-no" title="statement not covered" >i.measureText(e.textContent);<span class="cstat-no" title="statement not covered" ></span>u&gt;0&amp;&amp;(l=`scaleX(${h*s/u})`)}<span class="cstat-no" title="statement not covered" ></span>0</span>!==n.angle&amp;&amp;(l=`rotate(${n.angle}deg) ${l}`);<span class="cstat-no" title="statement not covered" >l</span>.length&gt;0&amp;&amp;(o.transform=l)}</span>class TextLayerRenderTask{<span class="fstat-no" title="function not covered" >co</span>nstructor({textContentSource:t,container:e,viewport:s,textDivs:a,textDivProperties:r,textContentItemsStr:o,isOffscreenCanvasSupported:l}){<span class="cstat-no" title="statement not covered" >this._textContentSource=t;<span class="cstat-no" title="statement not covered" >t</span>his._isReadableStream=t instanceof ReadableStream;<span class="cstat-no" title="statement not covered" >t</span>his._container=this._rootContainer=e;<span class="cstat-no" title="statement not covered" >t</span>his._textDivs=a||[];<span class="cstat-no" title="statement not covered" >t</span>his._textContentItemsStr=o||[];<span class="cstat-no" title="statement not covered" >t</span>his._isOffscreenCanvasSupported=l;<span class="cstat-no" title="statement not covered" >t</span>his._fontInspectorEnabled=!!globalThis.FontInspector?.enabled;<span class="cstat-no" title="statement not covered" >t</span>his._reader=null;<span class="cstat-no" title="statement not covered" >t</span>his._textDivProperties=r||new WeakMap;<span class="cstat-no" title="statement not covered" >t</span>his._canceled=!1;<span class="cstat-no" title="statement not covered" >t</span>his._capability=new n.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._layoutTextParams={prevFontSize:null,prevFontFamily:null,div:null,scale:s.scale*(globalThis.devicePixelRatio||1),properties:null,ctx:getCtx(0,l)};c</span>onst{pageWidth:c,pageHeight:h,pageX:d,pageY:u}=<span class="cstat-no" title="statement not covered" >s.rawDims;<span class="cstat-no" title="statement not covered" ></span>this._transform=[1,0,0,-1,-d,u+h];<span class="cstat-no" title="statement not covered" >t</span>his._pageWidth=c;<span class="cstat-no" title="statement not covered" >t</span>his._pageHeight=h;<span class="cstat-no" title="statement not covered" >(</span>0,i.setLayerDimensions)(e,s);<span class="cstat-no" title="statement not covered" >t</span>his._capability.promise.finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._layoutTextParams=null}</span>)).catch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{}))}<span class="fstat-no" title="function not covered" ></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this._capability.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._canceled=!0;<span class="cstat-no" title="statement not covered" >i</span>f(this._reader){<span class="cstat-no" title="statement not covered" >this._reader.cancel(new n.AbortException("TextLayer task cancelled.")).catch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{}));<span class="cstat-no" title="statement not covered" >t</span>his._reader=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his._capability.reject(new n.AbortException("TextLayer task cancelled."))}<span class="fstat-no" title="function not covered" ></span>_p</span>rocessItems(t,e){<span class="cstat-no" title="statement not covered" >for(const s of t)<span class="cstat-no" title="statement not covered" >if(void 0!==s.str){<span class="cstat-no" title="statement not covered" >this._textContentItemsStr.push(s.str);<span class="cstat-no" title="statement not covered" >a</span>ppendText(this,s,e)}</span>else <span class="cstat-no" title="statement not covered" >if("beginMarkedContentProps"===s.type||"beginMarkedContent"===s.type){const t=<span class="cstat-no" title="statement not covered" >this._container;<span class="cstat-no" title="statement not covered" ></span>this._container=document.createElement("span");<span class="cstat-no" title="statement not covered" >t</span>his._container.classList.add("markedContent");<span class="cstat-no" title="statement not covered" >n</span>ull!==s.id&amp;&amp;this._container.setAttribute("id",`${s.id}`);<span class="cstat-no" title="statement not covered" >t</span>.append(this._container)}</span>else<span class="cstat-no" title="statement not covered" >"endMarkedContent"===s.type&amp;&amp;(this._container=this._container.parentNode)}<span class="fstat-no" title="function not covered" ></span></span></span></span>_l</span>ayoutText(t){const e=<span class="cstat-no" title="statement not covered" >this._layoutTextParams.properties=this._textDivProperties.get(t);<span class="cstat-no" title="statement not covered" ></span>this._layoutTextParams.div=t;<span class="cstat-no" title="statement not covered" >l</span>ayout(this._layoutTextParams);<span class="cstat-no" title="statement not covered" >e</span>.hasText&amp;&amp;this._container.append(t);<span class="cstat-no" title="statement not covered" >i</span>f(e.hasEOL){const t=<span class="cstat-no" title="statement not covered" >document.createElement("br");<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("role","presentation");<span class="cstat-no" title="statement not covered" >t</span>his._container.append(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_r</span>ender(){const t=<span class="cstat-no" title="statement not covered" >new n.PromiseCapability;</span>let e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(this._isReadableStream){const pump=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._reader.read().then((<span class="fstat-no" title="function not covered" >({</span>value:s,done:n})=&gt;{<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >t.resolve();e</span>lse{<span class="cstat-no" title="statement not covered" >Object.assign(e,s.styles);<span class="cstat-no" title="statement not covered" >t</span>his._processItems(s.items,e);<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>}</span>),t.reject)}</span>;<span class="cstat-no" title="statement not covered" ></span>this._reader=this._textContentSource.getReader();<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>else{<span class="cstat-no" title="statement not covered" >if(!this._textContentSource)<span class="cstat-no" title="statement not covered" >throw new Error('No "textContentSource" parameter specified.');{</span></span>const{items:e,styles:s}=<span class="cstat-no" title="statement not covered" >this._textContentSource;<span class="cstat-no" title="statement not covered" ></span>this._processItems(e,s);<span class="cstat-no" title="statement not covered" >t</span>.resolve()}</span>}<span class="cstat-no" title="statement not covered" >t</span>.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e=null;<span class="cstat-no" title="statement not covered" >!</span>function <span class="fstat-no" title="function not covered" >render(</span>t){<span class="cstat-no" title="statement not covered" >if(t._canceled)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t._textDivs,</span>s=<span class="cstat-no" title="statement not covered" >t._capability;<span class="cstat-no" title="statement not covered" ></span>if(e.length&gt;1e5)<span class="cstat-no" title="statement not covered" >s.resolve();e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t._isReadableStream)<span class="cstat-no" title="statement not covered" >for(const s of e)<span class="cstat-no" title="statement not covered" >t._layoutText(s);<span class="cstat-no" title="statement not covered" >s</span></span></span>.resolve()}</span>}</span>(this)}</span>),this._capability.reject)}</span>}<span class="cstat-no" title="statement not covered" >e.TextLayerRenderTask=TextLayerRenderTask}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorLayer=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(4),</span>a=<span class="cstat-no" title="statement not covered" >s(5),</span>r=<span class="cstat-no" title="statement not covered" >s(28),</span>o=<span class="cstat-no" title="statement not covered" >s(33),</span>l=<span class="cstat-no" title="statement not covered" >s(6);</span>class AnnotationEditorLayer{#Gt;#zt=<span class="cstat-no" title="statement not covered" >!1;</span>#Vt=<span class="cstat-no" title="statement not covered" >null;</span>#Xt=<span class="cstat-no" title="statement not covered" >this.pointerup.bind(this);</span>#$t=<span class="cstat-no" title="statement not covered" >this.pointerdown.bind(this);</span>#Kt=<span class="cstat-no" title="statement not covered" >new Map;</span>#Yt=<span class="cstat-no" title="statement not covered" >!1;</span>#Jt=<span class="cstat-no" title="statement not covered" >!1;</span>#Qt=<span class="cstat-no" title="statement not covered" >!1;</span>#Zt;static _initialized=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >if(!AnnotationEditorLayer._initialized){<span class="cstat-no" title="statement not covered" >AnnotationEditorLayer._initialized=!0;<span class="cstat-no" title="statement not covered" >r</span>.FreeTextEditor.initialize(t.l10n);<span class="cstat-no" title="statement not covered" >o</span>.InkEditor.initialize(t.l10n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.uiManager.registerEditorTypes([r.FreeTextEditor,o.InkEditor]);<span class="cstat-no" title="statement not covered" >t</span>his.#Zt=t.uiManager;<span class="cstat-no" title="statement not covered" >t</span>his.pageIndex=t.pageIndex;<span class="cstat-no" title="statement not covered" >t</span>his.div=t.div;<span class="cstat-no" title="statement not covered" >t</span>his.#Gt=t.accessibilityManager;<span class="cstat-no" title="statement not covered" >t</span>his.#Vt=t.annotationLayer;<span class="cstat-no" title="statement not covered" >t</span>his.viewport=t.viewport;<span class="cstat-no" title="statement not covered" >t</span>his.#Zt.addLayer(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isEmpty(){<span class="cstat-no" title="statement not covered" >return 0===this.#Kt.size}<span class="fstat-no" title="function not covered" ></span>up</span>dateToolbar(t){<span class="cstat-no" title="statement not covered" >this.#Zt.updateToolbar(t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateMode(t=<span class="branch-0 cbranch-no" title="branch not covered" >this.#Zt.getMode())</span>{<span class="cstat-no" title="statement not covered" >this.#te();<span class="cstat-no" title="statement not covered" >i</span>f(t===n.AnnotationEditorType.INK){<span class="cstat-no" title="statement not covered" >this.addInkEditorIfNeeded(!1);<span class="cstat-no" title="statement not covered" >t</span>his.disableClick()}</span>else <span class="cstat-no" title="statement not covered" >this.enableClick();<span class="cstat-no" title="statement not covered" >t</span></span>his.#Zt.unselectAll();<span class="cstat-no" title="statement not covered" >i</span>f(t!==n.AnnotationEditorType.NONE){<span class="cstat-no" title="statement not covered" >this.div.classList.toggle("freeTextEditing",t===n.AnnotationEditorType.FREETEXT);<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.toggle("inkEditing",t===n.AnnotationEditorType.INK);<span class="cstat-no" title="statement not covered" >t</span>his.div.hidden=!1}</span>}<span class="fstat-no" title="function not covered" ></span>ad</span>dInkEditorIfNeeded(t){<span class="cstat-no" title="statement not covered" >if(!t&amp;&amp;this.#Zt.getMode()!==n.AnnotationEditorType.INK)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >for(const t of this.#Kt.values())<span class="cstat-no" title="statement not covered" >if(t.isEmpty()){<span class="cstat-no" title="statement not covered" >t.setInBackground();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span></span></span>his.#ee({offsetX:0,offsetY:0}).setInBackground()}<span class="fstat-no" title="function not covered" ></span>se</span>tEditingState(t){<span class="cstat-no" title="statement not covered" >this.#Zt.setEditingState(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dCommands(t){<span class="cstat-no" title="statement not covered" >this.#Zt.addCommands(t)}<span class="fstat-no" title="function not covered" ></span>en</span>able(){<span class="cstat-no" title="statement not covered" >this.div.style.pointerEvents="auto";c</span>onst t=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#Kt.values()){<span class="cstat-no" title="statement not covered" >e.enableEditing();<span class="cstat-no" title="statement not covered" >e</span>.annotationElementId&amp;&amp;t.add(e.annotationElementId)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.#Vt)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.#Vt.getEditableAnnotations();<span class="cstat-no" title="statement not covered" ></span>for(const s of e){<span class="cstat-no" title="statement not covered" >s.hide();<span class="cstat-no" title="statement not covered" >i</span>f(this.#Zt.isDeletedAnnotationElement(s.data.id))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.has(s.data.id))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.deserialize(s);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >this.addOrRebuild(e);<span class="cstat-no" title="statement not covered" >e</span>.enableEditing()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>di</span>sable(){<span class="cstat-no" title="statement not covered" >this.#Qt=!0;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.pointerEvents="none";c</span>onst t=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#Kt.values()){<span class="cstat-no" title="statement not covered" >e.disableEditing();<span class="cstat-no" title="statement not covered" >i</span>f(e.annotationElementId&amp;&amp;null===e.serialize()){<span class="cstat-no" title="statement not covered" >this.getEditableAnnotation(e.annotationElementId)?.show();<span class="cstat-no" title="statement not covered" >e</span>.remove()}</span>else <span class="cstat-no" title="statement not covered" >t.add(e.annotationElementId)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(this.#Vt){const e=<span class="cstat-no" title="statement not covered" >this.#Vt.getEditableAnnotations();<span class="cstat-no" title="statement not covered" ></span>for(const s of e){const{id:e}=<span class="cstat-no" title="statement not covered" >s.data;<span class="cstat-no" title="statement not covered" ></span>t.has(e)||this.#Zt.isDeletedAnnotationElement(e)||s.show()}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#te();<span class="cstat-no" title="statement not covered" >t</span>his.isEmpty&amp;&amp;(this.div.hidden=!0);<span class="cstat-no" title="statement not covered" >t</span>his.#Qt=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditableAnnotation(t){<span class="cstat-no" title="statement not covered" >return this.#Vt?.getEditableAnnotation(t)||null}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveEditor(t){<span class="cstat-no" title="statement not covered" >this.#Zt.getActive()!==t&amp;&amp;this.#Zt.setActiveEditor(t)}<span class="fstat-no" title="function not covered" ></span>en</span>ableClick(){<span class="cstat-no" title="statement not covered" >this.div.addEventListener("pointerdown",this.#$t);<span class="cstat-no" title="statement not covered" >t</span>his.div.addEventListener("pointerup",this.#Xt)}<span class="fstat-no" title="function not covered" ></span>di</span>sableClick(){<span class="cstat-no" title="statement not covered" >this.div.removeEventListener("pointerdown",this.#$t);<span class="cstat-no" title="statement not covered" >t</span>his.div.removeEventListener("pointerup",this.#Xt)}<span class="fstat-no" title="function not covered" ></span>at</span>tach(t){<span class="cstat-no" title="statement not covered" >this.#Kt.set(t.id,t);c</span>onst{annotationElementId:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.#Zt.isDeletedAnnotationElement(e)&amp;&amp;this.#Zt.removeDeletedAnnotationElement(t)}<span class="fstat-no" title="function not covered" ></span>de</span>tach(t){<span class="cstat-no" title="statement not covered" >this.#Kt.delete(t.id);<span class="cstat-no" title="statement not covered" >t</span>his.#Gt?.removePointerInTextLayer(t.contentDiv);<span class="cstat-no" title="statement not covered" >!</span>this.#Qt&amp;&amp;t.annotationElementId&amp;&amp;this.#Zt.addDeletedAnnotationElement(t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >this.detach(t);<span class="cstat-no" title="statement not covered" >t</span>his.#Zt.removeEditor(t);<span class="cstat-no" title="statement not covered" >t</span>.div.style.display="none";<span class="cstat-no" title="statement not covered" >s</span>etTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.div.style.display="";<span class="cstat-no" title="statement not covered" >t</span>.div.remove();<span class="cstat-no" title="statement not covered" >t</span>.isAttachedToDOM=!1;<span class="cstat-no" title="statement not covered" >d</span>ocument.activeElement===document.body&amp;&amp;this.#Zt.focusMainContainer()}</span>),0);<span class="cstat-no" title="statement not covered" >t</span>his.#Jt||this.addInkEditorIfNeeded(!1)}</span>#se(t){<span class="cstat-no" title="statement not covered" >if(t.parent!==this){<span class="cstat-no" title="statement not covered" >if(t.annotationElementId){<span class="cstat-no" title="statement not covered" >this.#Zt.addDeletedAnnotationElement(t.annotationElementId);<span class="cstat-no" title="statement not covered" >i</span>.AnnotationEditor.deleteAnnotationElement(t);<span class="cstat-no" title="statement not covered" >t</span>.annotationElementId=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.attach(t);<span class="cstat-no" title="statement not covered" >t</span>.parent?.detach(t);<span class="cstat-no" title="statement not covered" >t</span>.setParent(this);<span class="cstat-no" title="statement not covered" >i</span>f(t.div&amp;&amp;t.isAttachedToDOM){<span class="cstat-no" title="statement not covered" >t.div.remove();<span class="cstat-no" title="statement not covered" >t</span>his.div.append(t.div)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){<span class="cstat-no" title="statement not covered" >this.#se(t);<span class="cstat-no" title="statement not covered" >t</span>his.#Zt.addEditor(t);<span class="cstat-no" title="statement not covered" >t</span>his.attach(t);<span class="cstat-no" title="statement not covered" >i</span>f(!t.isAttachedToDOM){const e=<span class="cstat-no" title="statement not covered" >t.render();<span class="cstat-no" title="statement not covered" ></span>this.div.append(e);<span class="cstat-no" title="statement not covered" >t</span>.isAttachedToDOM=!0}<span class="cstat-no" title="statement not covered" ></span>t</span>his.moveEditorInDOM(t);<span class="cstat-no" title="statement not covered" >t</span>.onceAdded();<span class="cstat-no" title="statement not covered" >t</span>his.#Zt.addToAnnotationStorage(t)}<span class="fstat-no" title="function not covered" ></span>mo</span>veEditorInDOM(t){<span class="cstat-no" title="statement not covered" >this.#Gt?.moveElementInDOM(this.div,t.div,t.contentDiv,!0)}<span class="fstat-no" title="function not covered" ></span>ad</span>dOrRebuild(t){<span class="cstat-no" title="statement not covered" >t.needsToBeRebuilt()?t.rebuild():this.add(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tNextId(){<span class="cstat-no" title="statement not covered" >return this.#Zt.getId()}</span>#ne(t){<span class="cstat-no" title="statement not covered" >switch(this.#Zt.getMode()){case n.AnnotationEditorType.FREETEXT:<span class="cstat-no" title="statement not covered" >return new r.FreeTextEditor(t);c</span>ase n.AnnotationEditorType.INK:<span class="cstat-no" title="statement not covered" >return new o.InkEditor(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}<span class="fstat-no" title="function not covered" ></span>de</span>serialize(t){<span class="cstat-no" title="statement not covered" >switch(t.annotationType??t.annotationEditorType){case n.AnnotationEditorType.FREETEXT:<span class="cstat-no" title="statement not covered" >return r.FreeTextEditor.deserialize(t,this,this.#Zt);c</span>ase n.AnnotationEditorType.INK:<span class="cstat-no" title="statement not covered" >return o.InkEditor.deserialize(t,this,this.#Zt)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>#ee(t){const e=<span class="cstat-no" title="statement not covered" >this.getNextId(),</span>s=<span class="cstat-no" title="statement not covered" >this.#ne({parent:this,id:e,x:t.offsetX,y:t.offsetY,uiManager:this.#Zt});<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;this.add(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>se</span>tSelected(t){<span class="cstat-no" title="statement not covered" >this.#Zt.setSelected(t)}<span class="fstat-no" title="function not covered" ></span>to</span>ggleSelected(t){<span class="cstat-no" title="statement not covered" >this.#Zt.toggleSelected(t)}<span class="fstat-no" title="function not covered" ></span>is</span>Selected(t){<span class="cstat-no" title="statement not covered" >return this.#Zt.isSelected(t)}<span class="fstat-no" title="function not covered" ></span>un</span>select(t){<span class="cstat-no" title="statement not covered" >this.#Zt.unselect(t)}<span class="fstat-no" title="function not covered" ></span>po</span>interup(t){const{isMac:e}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(!(0!==t.button||t.ctrlKey&amp;&amp;e)&amp;&amp;t.target===this.div&amp;&amp;this.#Yt){<span class="cstat-no" title="statement not covered" >this.#Yt=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#zt?this.#ee(t):this.#zt=!0}</span>}<span class="fstat-no" title="function not covered" ></span>po</span>interdown(t){const{isMac:e}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(0!==t.button||t.ctrlKey&amp;&amp;e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.target!==this.div)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#Yt=!0;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.#Zt.getActive();<span class="cstat-no" title="statement not covered" ></span>this.#zt=!s||s.isEmpty()}<span class="fstat-no" title="function not covered" ></span>dr</span>op(t){const e=<span class="cstat-no" title="statement not covered" >t.dataTransfer.getData("text/plain"),</span>s=<span class="cstat-no" title="statement not covered" >this.#Zt.getEditor(e);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>.dataTransfer.dropEffect="move";<span class="cstat-no" title="statement not covered" >t</span>his.#se(s);c</span>onst n=<span class="cstat-no" title="statement not covered" >this.div.getBoundingClientRect(),</span>i=<span class="cstat-no" title="statement not covered" >t.clientX-n.x,</span>a=<span class="cstat-no" title="statement not covered" >t.clientY-n.y;<span class="cstat-no" title="statement not covered" ></span>s.translate(i-s.startX,a-s.startY);<span class="cstat-no" title="statement not covered" >t</span>his.moveEditorInDOM(s);<span class="cstat-no" title="statement not covered" >s</span>.div.focus()}<span class="fstat-no" title="function not covered" ></span>dr</span>agover(t){<span class="cstat-no" title="statement not covered" >t.preventDefault()}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.#Zt.getActive()?.parent===this&amp;&amp;this.#Zt.setActiveEditor(null);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#Kt.values()){<span class="cstat-no" title="statement not covered" >this.#Gt?.removePointerInTextLayer(t.contentDiv);<span class="cstat-no" title="statement not covered" >t</span>.setParent(null);<span class="cstat-no" title="statement not covered" >t</span>.isAttachedToDOM=!1;<span class="cstat-no" title="statement not covered" >t</span>.div.remove()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.div=null;<span class="cstat-no" title="statement not covered" >t</span>his.#Kt.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#Zt.removeLayer(this)}</span>#te(){<span class="cstat-no" title="statement not covered" >this.#Jt=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#Kt.values())<span class="cstat-no" title="statement not covered" >t.isEmpty()&amp;&amp;t.remove();<span class="cstat-no" title="statement not covered" >t</span></span>his.#Jt=!1}<span class="fstat-no" title="function not covered" ></span>re</span>nder({viewport:t}){<span class="cstat-no" title="statement not covered" >this.viewport=t;<span class="cstat-no" title="statement not covered" >(</span>0,l.setLayerDimensions)(this.div,t);<span class="cstat-no" title="statement not covered" >(</span>0,a.bindEvents)(this,this.div,["dragover","drop"]);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#Zt.getEditors(this.pageIndex))<span class="cstat-no" title="statement not covered" >this.add(t);<span class="cstat-no" title="statement not covered" >t</span></span>his.updateMode()}<span class="fstat-no" title="function not covered" ></span>up</span>date({viewport:t}){<span class="cstat-no" title="statement not covered" >this.#Zt.commitOrRemove();<span class="cstat-no" title="statement not covered" >t</span>his.viewport=t;<span class="cstat-no" title="statement not covered" >(</span>0,l.setLayerDimensions)(this.div,{rotation:t.rotation});<span class="cstat-no" title="statement not covered" >t</span>his.updateMode()}<span class="fstat-no" title="function not covered" ></span>ge</span>t pageDimensions(){const{pageWidth:t,pageHeight:e}=<span class="cstat-no" title="statement not covered" >this.viewport.rawDims;<span class="cstat-no" title="statement not covered" ></span>return[t,e]}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationEditorLayer=AnnotationEditorLayer}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.FreeTextEditor=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(5),</span>a=<span class="cstat-no" title="statement not covered" >s(4),</span>r=<span class="cstat-no" title="statement not covered" >s(29);</span>class FreeTextEditor extends a.AnnotationEditor{#ie=<span class="cstat-no" title="statement not covered" >this.editorDivBlur.bind(this);</span>#ae=<span class="cstat-no" title="statement not covered" >this.editorDivFocus.bind(this);</span>#re=<span class="cstat-no" title="statement not covered" >this.editorDivInput.bind(this);</span>#oe=<span class="cstat-no" title="statement not covered" >this.editorDivKeydown.bind(this);</span>#le;#ce=<span class="cstat-no" title="statement not covered" >"";</span>#he=<span class="cstat-no" title="statement not covered" >`${this.id}-editor`;</span>#de;#ue=<span class="cstat-no" title="statement not covered" >null;</span>static _freeTextDefaultContent=<span class="cstat-no" title="statement not covered" >"";</span>static _l10nPromise;static _internalPadding=<span class="cstat-no" title="statement not covered" >0;</span>static _defaultColor=<span class="cstat-no" title="statement not covered" >null;</span>static _defaultFontSize=<span class="cstat-no" title="statement not covered" >10;<span class="fstat-no" title="function not covered" ></span>st</span>atic get _keyboardManager(){<span class="cstat-no" title="statement not covered" >return(0,n.shadow)(this,"_keyboardManager",new i.KeyboardManager([[["ctrl+s","mac+meta+s","ctrl+p","mac+meta+p"],FreeTextEditor.prototype.commitOrRemove,!0],[["ctrl+Enter","mac+meta+Enter","Escape","mac+Escape"],FreeTextEditor.prototype.commitOrRemove]]))}</span>static _type=<span class="cstat-no" title="statement not covered" >"freetext";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super({...t,name:"freeTextEditor"});<span class="cstat-no" title="statement not covered" >t</span>his.#le=t.color||FreeTextEditor._defaultColor||a.AnnotationEditor._defaultLineColor;<span class="cstat-no" title="statement not covered" >t</span>his.#de=t.fontSize||FreeTextEditor._defaultFontSize}<span class="fstat-no" title="function not covered" ></span>st</span>atic initialize(t){<span class="cstat-no" title="statement not covered" >this._l10nPromise=new Map(["free_text2_default_content","editor_free_text2_aria_label"].map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >[e,t.get(e)])</span>));c</span>onst e=<span class="cstat-no" title="statement not covered" >getComputedStyle(document.documentElement);<span class="cstat-no" title="statement not covered" ></span>this._internalPadding=parseFloat(e.getPropertyValue("--freetext-padding"))}<span class="fstat-no" title="function not covered" ></span>st</span>atic updateDefaultParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case n.AnnotationEditorParamsType.FREETEXT_SIZE:<span class="cstat-no" title="statement not covered" >FreeTextEditor._defaultFontSize=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationEditorParamsType.FREETEXT_COLOR:<span class="cstat-no" title="statement not covered" >FreeTextEditor._defaultColor=e}</span>}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case n.AnnotationEditorParamsType.FREETEXT_SIZE:<span class="cstat-no" title="statement not covered" >this.#pe(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationEditorParamsType.FREETEXT_COLOR:<span class="cstat-no" title="statement not covered" >this.#ge(e)}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic get defaultPropertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[n.AnnotationEditorParamsType.FREETEXT_SIZE,FreeTextEditor._defaultFontSize],[n.AnnotationEditorParamsType.FREETEXT_COLOR,FreeTextEditor._defaultColor||a.AnnotationEditor._defaultLineColor]]}<span class="fstat-no" title="function not covered" ></span>ge</span>t propertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[n.AnnotationEditorParamsType.FREETEXT_SIZE,this.#de],[n.AnnotationEditorParamsType.FREETEXT_COLOR,this.#le]]}</span>#pe(t){const setFontsize=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.editorDiv.style.fontSize=`calc(${t}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" >t</span>his.translate(0,-(t-this.#de)*this.parentScale);<span class="cstat-no" title="statement not covered" >t</span>his.#de=t;<span class="cstat-no" title="statement not covered" >t</span>his.#fe()}</span>,</span>e=<span class="cstat-no" title="statement not covered" >this.#de;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setFontsize(t)}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setFontsize(e)}</span>,mustExec:!0,type:n.AnnotationEditorParamsType.FREETEXT_SIZE,overwriteIfSameType:!0,keepUndo:!0})}</span>#ge(t){const e=<span class="cstat-no" title="statement not covered" >this.#le;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#le=this.editorDiv.style.color=t}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#le=this.editorDiv.style.color=e}</span>,mustExec:!0,type:n.AnnotationEditorParamsType.FREETEXT_COLOR,overwriteIfSameType:!0,keepUndo:!0})}<span class="fstat-no" title="function not covered" ></span>ge</span>tInitialTranslation(){const t=<span class="cstat-no" title="statement not covered" >this.parentScale;<span class="cstat-no" title="statement not covered" ></span>return[-FreeTextEditor._internalPadding*t,-(FreeTextEditor._internalPadding+this.#de)*t]}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >super.rebuild();<span class="cstat-no" title="statement not covered" >n</span>ull!==this.div&amp;&amp;(this.isAttachedToDOM||this.parent.add(this))}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditMode(){<span class="cstat-no" title="statement not covered" >if(!this.isInEditMode()){<span class="cstat-no" title="statement not covered" >this.parent.setEditingState(!1);<span class="cstat-no" title="statement not covered" >t</span>his.parent.updateToolbar(n.AnnotationEditorType.FREETEXT);<span class="cstat-no" title="statement not covered" >s</span>uper.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv.classList.remove("enabled");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!0;<span class="cstat-no" title="statement not covered" >t</span>his.div.draggable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.div.removeAttribute("aria-activedescendant");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("keydown",this.#oe);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("focus",this.#ae);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("blur",this.#ie);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("input",this.#re)}</span>}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditMode(){<span class="cstat-no" title="statement not covered" >if(this.isInEditMode()){<span class="cstat-no" title="statement not covered" >this.parent.setEditingState(!0);<span class="cstat-no" title="statement not covered" >s</span>uper.disableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv.classList.add("enabled");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("aria-activedescendant",this.#he);<span class="cstat-no" title="statement not covered" >t</span>his.div.draggable=!0;<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("keydown",this.#oe);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("focus",this.#ae);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("blur",this.#ie);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("input",this.#re);<span class="cstat-no" title="statement not covered" >t</span>his.div.focus({preventScroll:!0});<span class="cstat-no" title="statement not covered" >t</span>his.isEditing=!1;<span class="cstat-no" title="statement not covered" >t</span>his.parent.div.classList.add("freeTextEditing")}</span>}<span class="fstat-no" title="function not covered" ></span>fo</span>cusin(t){<span class="cstat-no" title="statement not covered" >super.focusin(t);<span class="cstat-no" title="statement not covered" >t</span>.target!==this.editorDiv&amp;&amp;this.editorDiv.focus()}<span class="fstat-no" title="function not covered" ></span>on</span>ceAdded(){<span class="cstat-no" title="statement not covered" >if(this.width)<span class="cstat-no" title="statement not covered" >this.#me();e</span>lse{<span class="cstat-no" title="statement not covered" >this.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.focus()}</span>}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return!this.editorDiv||""===this.editorDiv.innerText.trim()}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >this.isEditing=!1;<span class="cstat-no" title="statement not covered" >t</span>his.parent.setEditingState(!0);<span class="cstat-no" title="statement not covered" >t</span>his.parent.div.classList.add("freeTextEditing");<span class="cstat-no" title="statement not covered" >s</span>uper.remove()}</span>#be(){const t=<span class="cstat-no" title="statement not covered" >this.editorDiv.getElementsByTagName("div");<span class="cstat-no" title="statement not covered" ></span>if(0===t.length)<span class="cstat-no" title="statement not covered" >return this.editorDiv.innerText;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const s of t)<span class="cstat-no" title="statement not covered" >e.push(s.innerText.replace(/\r\n?|\n/,""));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.join("\n")}</span>#fe(){const[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;</span>let s;<span class="cstat-no" title="statement not covered" >if(this.isAttachedToDOM)<span class="cstat-no" title="statement not covered" >s=this.div.getBoundingClientRect();e</span>lse{const{currentLayer:t,div:e}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >e.style.display;<span class="cstat-no" title="statement not covered" ></span>e.style.display="hidden";<span class="cstat-no" title="statement not covered" >t</span>.div.append(this.div);<span class="cstat-no" title="statement not covered" >s</span>=e.getBoundingClientRect();<span class="cstat-no" title="statement not covered" >e</span>.remove();<span class="cstat-no" title="statement not covered" >e</span>.style.display=n}<span class="cstat-no" title="statement not covered" ></span>t</span>his.width=s.width/t;<span class="cstat-no" title="statement not covered" >t</span>his.height=s.height/e}<span class="fstat-no" title="function not covered" ></span>co</span>mmit(){<span class="cstat-no" title="statement not covered" >if(!this.isInEditMode())<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>uper.commit();<span class="cstat-no" title="statement not covered" >t</span>his.disableEditMode();c</span>onst t=<span class="cstat-no" title="statement not covered" >this.#ce,</span>e=<span class="cstat-no" title="statement not covered" >this.#ce=this.#be().trimEnd();<span class="cstat-no" title="statement not covered" ></span>if(t===e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst setText=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#ce=t;<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >this.#Ae();<span class="cstat-no" title="statement not covered" >t</span>his.rebuild();<span class="cstat-no" title="statement not covered" >t</span>his.#fe()}</span>else <span class="cstat-no" title="statement not covered" >this.remove()}</span></span>;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setText(e)}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setText(t)}</span>,mustExec:!1});<span class="cstat-no" title="statement not covered" >t</span>his.#fe()}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldGetKeyboardEvents(){<span class="cstat-no" title="statement not covered" >return this.isInEditMode()}<span class="fstat-no" title="function not covered" ></span>db</span>lclick(t){<span class="cstat-no" title="statement not covered" >this.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.focus()}<span class="fstat-no" title="function not covered" ></span>ke</span>ydown(t){<span class="cstat-no" title="statement not covered" >if(t.target===this.div&amp;&amp;"Enter"===t.key){<span class="cstat-no" title="statement not covered" >this.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.focus()}</span>}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivKeydown(t){<span class="cstat-no" title="statement not covered" >FreeTextEditor._keyboardManager.exec(this,t)}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivFocus(t){<span class="cstat-no" title="statement not covered" >this.isEditing=!0}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivBlur(t){<span class="cstat-no" title="statement not covered" >this.isEditing=!1}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivInput(t){<span class="cstat-no" title="statement not covered" >this.parent.div.classList.toggle("freeTextEditing",this.isEmpty())}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditing(){<span class="cstat-no" title="statement not covered" >this.editorDiv.setAttribute("role","comment");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeAttribute("aria-multiline")}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditing(){<span class="cstat-no" title="statement not covered" >this.editorDiv.setAttribute("role","textbox");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.setAttribute("aria-multiline",!0)}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.div)<span class="cstat-no" title="statement not covered" >return this.div;l</span></span>et t,e;<span class="cstat-no" title="statement not covered" >if(this.width){<span class="cstat-no" title="statement not covered" >t=this.x;<span class="cstat-no" title="statement not covered" >e</span>=this.y}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.render();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.className="internal";<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.setAttribute("id",this.#he);<span class="cstat-no" title="statement not covered" >t</span>his.enableEditing();<span class="cstat-no" title="statement not covered" >F</span>reeTextEditor._l10nPromise.get("editor_free_text2_aria_label").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.editorDiv?.setAttribute("aria-label",t))</span>);<span class="cstat-no" title="statement not covered" >F</span>reeTextEditor._l10nPromise.get("free_text2_default_content").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.editorDiv?.setAttribute("default-content",t))</span>);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!0;c</span>onst{style:s}=<span class="cstat-no" title="statement not covered" >this.editorDiv;<span class="cstat-no" title="statement not covered" ></span>s.fontSize=`calc(${this.#de}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" >s</span>.color=this.#le;<span class="cstat-no" title="statement not covered" >t</span>his.div.append(this.editorDiv);<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv.classList.add("overlay","enabled");<span class="cstat-no" title="statement not covered" >t</span>his.div.append(this.overlayDiv);<span class="cstat-no" title="statement not covered" >(</span>0,i.bindEvents)(this,this.div,["dblclick","keydown"]);<span class="cstat-no" title="statement not covered" >i</span>f(this.width){const[s,n]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>if(this.annotationElementId){const[i]=<span class="cstat-no" title="statement not covered" >this.getInitialTranslation();<span class="cstat-no" title="statement not covered" ></span>this.setAt(t*s,e*n,i,i)}</span>else <span class="cstat-no" title="statement not covered" >this.setAt(t*s,e*n,this.width*s,this.height*n);<span class="cstat-no" title="statement not covered" >t</span></span>his.#Ae();<span class="cstat-no" title="statement not covered" >t</span>his.div.draggable=!0;<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!1}</span>else{<span class="cstat-no" title="statement not covered" >this.div.draggable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.div}</span>#Ae(){<span class="cstat-no" title="statement not covered" >this.editorDiv.replaceChildren();<span class="cstat-no" title="statement not covered" >i</span>f(this.#ce)<span class="cstat-no" title="statement not covered" >for(const t of this.#ce.split("\n")){const e=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>e.append(t?document.createTextNode(t):document.createElement("br"));<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.append(e)}</span>}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t contentDiv(){<span class="cstat-no" title="statement not covered" >return this.editorDiv}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,s){let i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(t instanceof r.FreeTextAnnotationElement){const{data:{defaultAppearanceData:{fontSize:e,fontColor:s},rect:a,rotation:r,id:o},textContent:l,parent:{page:{pageNumber:c}}}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(!l||0===l.length)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>=t={annotationType:n.AnnotationEditorType.FREETEXT,color:Array.from(s),fontSize:e,value:l.join("\n"),pageIndex:c-1,rect:a,rotation:r,id:o,deleted:!1}}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >super.deserialize(t,e,s);<span class="cstat-no" title="statement not covered" ></span>a.#de=t.fontSize;<span class="cstat-no" title="statement not covered" >a</span>.#le=n.Util.makeHexColor(...t.color);<span class="cstat-no" title="statement not covered" >a</span>.#ce=t.value;<span class="cstat-no" title="statement not covered" >a</span>.annotationElementId=t.id||null;<span class="cstat-no" title="statement not covered" >a</span>.#ue=i;<span class="cstat-no" title="statement not covered" >r</span>eturn a}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.deleted)<span class="cstat-no" title="statement not covered" >return{pageIndex:this.pageIndex,id:this.annotationElementId,deleted:!0};c</span></span>onst e=<span class="cstat-no" title="statement not covered" >FreeTextEditor._internalPadding*this.parentScale,</span>s=<span class="cstat-no" title="statement not covered" >this.getRect(e,e),</span>i=<span class="cstat-no" title="statement not covered" >a.AnnotationEditor._colorManager.convert(this.isAttachedToDOM?getComputedStyle(this.editorDiv).color:this.#le),</span>r=<span class="cstat-no" title="statement not covered" >{annotationType:n.AnnotationEditorType.FREETEXT,color:i,fontSize:this.#de,value:this.#ce,pageIndex:this.pageIndex,rect:s,rotation:this.rotation};<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.annotationElementId&amp;&amp;!this.#_e(r))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>.id=this.annotationElementId;<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>#_e(t){const{value:e,fontSize:s,color:n,rect:i,pageIndex:a}=<span class="cstat-no" title="statement not covered" >this.#ue;<span class="cstat-no" title="statement not covered" ></span>return t.value!==e||t.fontSize!==s||t.rect.some((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.abs(t-i[e])&gt;=1)</span>)||t.color.some((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t!==n[e])</span>)||t.pageIndex!==a}</span>#me(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!this.annotationElementId)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#fe();<span class="cstat-no" title="statement not covered" >i</span>f(!t&amp;&amp;(0===this.width||0===this.height)){<span class="cstat-no" title="statement not covered" >setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#me(!0))</span>,0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >FreeTextEditor._internalPadding*this.parentScale;<span class="cstat-no" title="statement not covered" ></span>this.#ue.rect=this.getRect(e,e)}</span>}<span class="cstat-no" title="statement not covered" >e.FreeTextEditor=FreeTextEditor}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.InkAnnotationElement=e.FreeTextAnnotationElement=e.AnnotationLayer=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(6),</span>a=<span class="cstat-no" title="statement not covered" >s(3),</span>r=<span class="cstat-no" title="statement not covered" >s(30),</span>o=<span class="cstat-no" title="statement not covered" >s(31);</span>const l=<span class="cstat-no" title="statement not covered" >1e3,</span>c=<span class="cstat-no" title="statement not covered" >new WeakSet;</span>function <span class="fstat-no" title="function not covered" >getRectDims(</span>t){<span class="cstat-no" title="statement not covered" >return{width:t[2]-t[0],height:t[3]-t[1]}}</span>class AnnotationElementFactory{<span class="fstat-no" title="function not covered" >st</span>atic create(t){<span class="cstat-no" title="statement not covered" >switch(t.data.annotationType){case n.AnnotationType.LINK:<span class="cstat-no" title="statement not covered" >return new LinkAnnotationElement(t);c</span>ase n.AnnotationType.TEXT:<span class="cstat-no" title="statement not covered" >return new TextAnnotationElement(t);c</span>ase n.AnnotationType.WIDGET:<span class="cstat-no" title="statement not covered" >switch(t.data.fieldType){case"Tx":<span class="cstat-no" title="statement not covered" >return new TextWidgetAnnotationElement(t);c</span>ase"Btn":<span class="cstat-no" title="statement not covered" >return t.data.radioButton?new RadioButtonWidgetAnnotationElement(t):t.data.checkBox?new CheckboxWidgetAnnotationElement(t):new PushButtonWidgetAnnotationElement(t);c</span>ase"Ch":<span class="cstat-no" title="statement not covered" >return new ChoiceWidgetAnnotationElement(t);c</span>ase"Sig":<span class="cstat-no" title="statement not covered" >return new SignatureWidgetAnnotationElement(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new WidgetAnnotationElement(t);c</span>ase n.AnnotationType.POPUP:<span class="cstat-no" title="statement not covered" >return new PopupAnnotationElement(t);c</span>ase n.AnnotationType.FREETEXT:<span class="cstat-no" title="statement not covered" >return new FreeTextAnnotationElement(t);c</span>ase n.AnnotationType.LINE:<span class="cstat-no" title="statement not covered" >return new LineAnnotationElement(t);c</span>ase n.AnnotationType.SQUARE:<span class="cstat-no" title="statement not covered" >return new SquareAnnotationElement(t);c</span>ase n.AnnotationType.CIRCLE:<span class="cstat-no" title="statement not covered" >return new CircleAnnotationElement(t);c</span>ase n.AnnotationType.POLYLINE:<span class="cstat-no" title="statement not covered" >return new PolylineAnnotationElement(t);c</span>ase n.AnnotationType.CARET:<span class="cstat-no" title="statement not covered" >return new CaretAnnotationElement(t);c</span>ase n.AnnotationType.INK:<span class="cstat-no" title="statement not covered" >return new InkAnnotationElement(t);c</span>ase n.AnnotationType.POLYGON:<span class="cstat-no" title="statement not covered" >return new PolygonAnnotationElement(t);c</span>ase n.AnnotationType.HIGHLIGHT:<span class="cstat-no" title="statement not covered" >return new HighlightAnnotationElement(t);c</span>ase n.AnnotationType.UNDERLINE:<span class="cstat-no" title="statement not covered" >return new UnderlineAnnotationElement(t);c</span>ase n.AnnotationType.SQUIGGLY:<span class="cstat-no" title="statement not covered" >return new SquigglyAnnotationElement(t);c</span>ase n.AnnotationType.STRIKEOUT:<span class="cstat-no" title="statement not covered" >return new StrikeOutAnnotationElement(t);c</span>ase n.AnnotationType.STAMP:<span class="cstat-no" title="statement not covered" >return new StampAnnotationElement(t);c</span>ase n.AnnotationType.FILEATTACHMENT:<span class="cstat-no" title="statement not covered" >return new FileAttachmentAnnotationElement(t);d</span>efault:<span class="cstat-no" title="statement not covered" >return new AnnotationElement(t)}</span>}</span>}class AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{isRenderable:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>ignoreBorder:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>createQuadrilaterals:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.isRenderable=e;<span class="cstat-no" title="statement not covered" >t</span>his.data=t.data;<span class="cstat-no" title="statement not covered" >t</span>his.layer=t.layer;<span class="cstat-no" title="statement not covered" >t</span>his.linkService=t.linkService;<span class="cstat-no" title="statement not covered" >t</span>his.downloadManager=t.downloadManager;<span class="cstat-no" title="statement not covered" >t</span>his.imageResourcesPath=t.imageResourcesPath;<span class="cstat-no" title="statement not covered" >t</span>his.renderForms=t.renderForms;<span class="cstat-no" title="statement not covered" >t</span>his.svgFactory=t.svgFactory;<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage=t.annotationStorage;<span class="cstat-no" title="statement not covered" >t</span>his.enableScripting=t.enableScripting;<span class="cstat-no" title="statement not covered" >t</span>his.hasJSActions=t.hasJSActions;<span class="cstat-no" title="statement not covered" >t</span>his._fieldObjects=t.fieldObjects;<span class="cstat-no" title="statement not covered" >t</span>his.parent=t.parent;<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(this.container=this._createContainer(s));<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(this.quadrilaterals=this._createQuadrilaterals(s))}<span class="fstat-no" title="function not covered" ></span>_c</span>reateContainer(t){const{data:e,parent:{page:s,viewport:i}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >document.createElement("section");<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("data-annotation-id",e.id);<span class="cstat-no" title="statement not covered" >a</span>.style.zIndex=this.parent.zIndex++;<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef&amp;&amp;a.setAttribute("aria-haspopup","dialog");<span class="cstat-no" title="statement not covered" >e</span>.noRotate&amp;&amp;a.classList.add("norotate");c</span>onst{pageWidth:r,pageHeight:o,pageX:l,pageY:c}=<span class="cstat-no" title="statement not covered" >i.rawDims;<span class="cstat-no" title="statement not covered" ></span>if(!e.rect||this instanceof PopupAnnotationElement){const{rotation:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>e.hasOwnCanvas||0===t||this.setRotation(t,a);<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>c</span>onst{width:h,height:d}=<span class="cstat-no" title="statement not covered" >getRectDims(e.rect),</span>u=<span class="cstat-no" title="statement not covered" >n.Util.normalizeRect([e.rect[0],s.view[3]-e.rect[1]+s.view[1],e.rect[2],s.view[3]-e.rect[3]+s.view[1]]);<span class="cstat-no" title="statement not covered" ></span>if(!t&amp;&amp;e.borderStyle.width&gt;0){<span class="cstat-no" title="statement not covered" >a.style.borderWidth=`${e.borderStyle.width}px`;c</span>onst t=<span class="cstat-no" title="statement not covered" >e.borderStyle.horizontalCornerRadius,</span>s=<span class="cstat-no" title="statement not covered" >e.borderStyle.verticalCornerRadius;<span class="cstat-no" title="statement not covered" ></span>if(t&gt;0||s&gt;0){const e=<span class="cstat-no" title="statement not covered" >`calc(${t}px * var(--scale-factor)) / calc(${s}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" ></span>a.style.borderRadius=e}</span>else <span class="cstat-no" title="statement not covered" >if(this instanceof RadioButtonWidgetAnnotationElement){const t=<span class="cstat-no" title="statement not covered" >`calc(${h}px * var(--scale-factor)) / calc(${d}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" ></span>a.style.borderRadius=t}<span class="cstat-no" title="statement not covered" ></span>s</span></span>witch(e.borderStyle.style){case n.AnnotationBorderStyleType.SOLID:<span class="cstat-no" title="statement not covered" >a.style.borderStyle="solid";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationBorderStyleType.DASHED:<span class="cstat-no" title="statement not covered" >a.style.borderStyle="dashed";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationBorderStyleType.BEVELED:<span class="cstat-no" title="statement not covered" >(0,n.warn)("Unimplemented border style: beveled");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationBorderStyleType.INSET:<span class="cstat-no" title="statement not covered" >(0,n.warn)("Unimplemented border style: inset");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationBorderStyleType.UNDERLINE:<span class="cstat-no" title="statement not covered" >a.style.borderBottomStyle="solid"}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >e.borderColor||null;<span class="cstat-no" title="statement not covered" ></span>i?a.style.borderColor=n.Util.makeHexColor(0|i[0],0|i[1],0|i[2]):a.style.borderWidth=0}<span class="cstat-no" title="statement not covered" ></span>a</span>.style.left=100*(u[0]-l)/r+"%";<span class="cstat-no" title="statement not covered" >a</span>.style.top=100*(u[1]-c)/o+"%";c</span>onst{rotation:p}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(e.hasOwnCanvas||0===p){<span class="cstat-no" title="statement not covered" >a.style.width=100*h/r+"%";<span class="cstat-no" title="statement not covered" >a</span>.style.height=100*d/o+"%"}</span>else <span class="cstat-no" title="statement not covered" >this.setRotation(p,a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="fstat-no" title="function not covered" ></span>se</span>tRotation(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >this.container)</span>{const{pageWidth:s,pageHeight:n}=<span class="cstat-no" title="statement not covered" >this.parent.viewport.rawDims,</span>{width:i,height:a}=<span class="cstat-no" title="statement not covered" >getRectDims(this.data.rect);</span>let r,o;<span class="cstat-no" title="statement not covered" >if(t%180==0){<span class="cstat-no" title="statement not covered" >r=100*i/s;<span class="cstat-no" title="statement not covered" >o</span>=100*a/n}</span>else{<span class="cstat-no" title="statement not covered" >r=100*a/s;<span class="cstat-no" title="statement not covered" >o</span>=100*i/n}<span class="cstat-no" title="statement not covered" ></span>e</span>.style.width=`${r}%`;<span class="cstat-no" title="statement not covered" >e</span>.style.height=`${o}%`;<span class="cstat-no" title="statement not covered" >e</span>.setAttribute("data-main-rotation",(360-t)%360)}<span class="fstat-no" title="function not covered" ></span>ge</span>t _commonActions(){const setColor=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >s.detail[t];<span class="cstat-no" title="statement not covered" ></span>s.target.style[e]=r.ColorConverters[`${n[0]}_HTML`](n.slice(1))}</span>;<span class="cstat-no" title="statement not covered" ></span>return(0,n.shadow)(this,"_commonActions",{display:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.detail.display%2==1;<span class="cstat-no" title="statement not covered" ></span>this.container.style.visibility=e?"hidden":"visible";<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{hidden:e,print:0===t.detail.display||3===t.detail.display})}</span>,print:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.annotationStorage.setValue(this.data.id,{print:t.detail.print})}</span>,hidden:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.container.style.visibility=t.detail.hidden?"hidden":"visible";<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{hidden:t.detail.hidden})}</span>,focus:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.target.focus({preventScroll:!1}))</span>,0)}</span>,userName:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.target.title=t.detail.userName}</span>,readonly:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.detail.readonly?t.target.setAttribute("readonly",""):t.target.removeAttribute("readonly")}</span>,required:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._setRequired(t.target,t.detail.required)}</span>,bgColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("bgColor","backgroundColor",t)}</span>,fillColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("fillColor","backgroundColor",t)}</span>,fgColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("fgColor","color",t)}</span>,textColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("textColor","color",t)}</span>,borderColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("borderColor","borderColor",t)}</span>,strokeColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("strokeColor","borderColor",t)}</span>,rotation:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.detail.rotation;<span class="cstat-no" title="statement not covered" ></span>this.setRotation(e);<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{rotation:e})}</span>})}<span class="fstat-no" title="function not covered" ></span>_d</span>ispatchEventFromSandbox(t,e){const s=<span class="cstat-no" title="statement not covered" >this._commonActions;<span class="cstat-no" title="statement not covered" ></span>for(const n of Object.keys(e.detail)){const i=<span class="cstat-no" title="statement not covered" >t[n]||s[n];<span class="cstat-no" title="statement not covered" ></span>i?.(e)}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>etDefaultPropertiesFromJS(t){<span class="cstat-no" title="statement not covered" >if(!this.enableScripting)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.annotationStorage.getRawValue(this.data.id);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this._commonActions;<span class="cstat-no" title="statement not covered" ></span>for(const[n,i]of Object.entries(e)){const a=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >a({detail:{[n]:i},target:t});<span class="cstat-no" title="statement not covered" >d</span>elete e[n]}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>_c</span>reateQuadrilaterals(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!this.data.quadPoints)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >this.data.rect;</span>let n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>for(const s of this.data.quadPoints){<span class="cstat-no" title="statement not covered" >this.data.rect=[s[2].x,s[2].y,s[1].x,s[1].y];<span class="cstat-no" title="statement not covered" >e</span>.push(this._createContainer(t));<span class="cstat-no" title="statement not covered" >n</span>||=this.data.rect}<span class="cstat-no" title="statement not covered" ></span>t</span>his.data.rect=s;<span class="cstat-no" title="statement not covered" >t</span>his.firstQuadRect=n;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_c</span>reatePopup(){const{container:t,data:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("aria-haspopup","dialog");c</span>onst s=<span class="cstat-no" title="statement not covered" >new PopupAnnotationElement({data:{color:e.color,titleObj:e.titleObj,modificationDate:e.modificationDate,contentsObj:e.contentsObj,richText:e.richText,parentRect:this.firstQuadRect||e.rect,borderStyle:0,id:`popup_${e.id}`,rotation:e.rotation},parent:this.parent,elements:[this]});<span class="cstat-no" title="statement not covered" ></span>this.parent.div.append(s.render())}<span class="fstat-no" title="function not covered" ></span>_r</span>enderQuadrilaterals(t){<span class="cstat-no" title="statement not covered" >for(const e of this.quadrilaterals)<span class="cstat-no" title="statement not covered" >e.classList.add(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.quadrilaterals}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Abstract method `AnnotationElement.render` called")}<span class="fstat-no" title="function not covered" ></span>_g</span>etElementsByName(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(this._fieldObjects){const i=<span class="cstat-no" title="statement not covered" >this._fieldObjects[t];<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >for(const{page:t,id:a,exportValues:r}of i){<span class="cstat-no" title="statement not covered" >if(-1===t)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(a===e)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >"string"==typeof r?r:null,</span>o=<span class="cstat-no" title="statement not covered" >document.querySelector(`[data-element-id="${a}"]`);<span class="cstat-no" title="statement not covered" ></span>!o||c.has(o)?s.push({id:a,exportValue:i,domElement:o}):(0,n.warn)(`_getElementsByName - element not allowed: ${a}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn s}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const n of document.getElementsByName(t)){const{exportValue:t}=<span class="cstat-no" title="statement not covered" >n,</span>i=<span class="cstat-no" title="statement not covered" >n.getAttribute("data-element-id");<span class="cstat-no" title="statement not covered" ></span>i!==e&amp;&amp;(c.has(n)&amp;&amp;s.push({id:i,exportValue:t,domElement:n}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(){<span class="cstat-no" title="statement not covered" >this.container&amp;&amp;(this.container.hidden=!1);<span class="cstat-no" title="statement not covered" >t</span>his.popup?.maybeShow()}<span class="fstat-no" title="function not covered" ></span>hi</span>de(){<span class="cstat-no" title="statement not covered" >this.container&amp;&amp;(this.container.hidden=!0);<span class="cstat-no" title="statement not covered" >t</span>his.popup?.forceHide()}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.quadrilaterals||this.container}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){const t=<span class="cstat-no" title="statement not covered" >this.getElementsToTriggerPopup();<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(t))<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.classList.add("highlightArea");e</span></span>lse <span class="cstat-no" title="statement not covered" >t.classList.add("highlightArea")}</span></span>}class LinkAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!0,ignoreBorder:!!e?.ignoreBorder,createQuadrilaterals:!0});<span class="cstat-no" title="statement not covered" >t</span>his.isTooltipOnly=t.data.isTooltipOnly}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const{data:t,linkService:e}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>s.setAttribute("data-element-id",t.id);l</span>et n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(t.url){<span class="cstat-no" title="statement not covered" >e.addLinkAttributes(s,t.url,t.newWindow);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.action){<span class="cstat-no" title="statement not covered" >this._bindNamedAction(s,t.action);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.attachment){<span class="cstat-no" title="statement not covered" >this._bindAttachment(s,t.attachment);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.setOCGState){<span class="cstat-no" title="statement not covered" >this.#ye(s,t.setOCGState);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.dest){<span class="cstat-no" title="statement not covered" >this._bindLink(s,t.dest);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>else{<span class="cstat-no" title="statement not covered" >if(t.actions&amp;&amp;(t.actions.Action||t.actions["Mouse Up"]||t.actions["Mouse Down"])&amp;&amp;this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >this._bindJSAction(s,t);<span class="cstat-no" title="statement not covered" >n</span>=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.resetForm){<span class="cstat-no" title="statement not covered" >this._bindResetFormAction(s,t.resetForm);<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(this.isTooltipOnly&amp;&amp;!n){<span class="cstat-no" title="statement not covered" >this._bindLink(s,"");<span class="cstat-no" title="statement not covered" >n</span>=!0}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span></span></span></span>f(this.quadrilaterals)<span class="cstat-no" title="statement not covered" >return this._renderQuadrilaterals("linkAnnotation").map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >0===e?s:s.cloneNode();<span class="cstat-no" title="statement not covered" ></span>t.append(n);<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>));<span class="cstat-no" title="statement not covered" >t</span></span>his.container.classList.add("linkAnnotation");<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;this.container.append(s);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>#ve(){<span class="cstat-no" title="statement not covered" >this.container.setAttribute("data-internal-link","")}<span class="fstat-no" title="function not covered" ></span>_b</span>indLink(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getDestinationHash(e);<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e&amp;&amp;this.linkService.goToDestination(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >(</span>e||""===e)&amp;&amp;this.#ve()}<span class="fstat-no" title="function not covered" ></span>_b</span>indNamedAction(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.executeNamedAction(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#ve()}<span class="fstat-no" title="function not covered" ></span>_b</span>indAttachment(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.downloadManager?.openOrDownloadData(this.container,e.content,e.filename);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#ve()}</span>#ye(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.executeSetOCGState(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#ve()}<span class="fstat-no" title="function not covered" ></span>_b</span>indJSAction(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");c</span>onst s=<span class="cstat-no" title="statement not covered" >new Map([["Action","onclick"],["Mouse Up","onmouseup"],["Mouse Down","onmousedown"]]);<span class="cstat-no" title="statement not covered" ></span>for(const n of Object.keys(e.actions)){const i=<span class="cstat-no" title="statement not covered" >s.get(n);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(t[i]=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e.id,name:n}});<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>.onclick||(t.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1)</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#ve()}<span class="fstat-no" title="function not covered" ></span>_b</span>indResetFormAction(t,e){const s=<span class="cstat-no" title="statement not covered" >t.onclick;<span class="cstat-no" title="statement not covered" ></span>s||(t.href=this.linkService.getAnchorUrl(""));<span class="cstat-no" title="statement not covered" >t</span>his.#ve();<span class="cstat-no" title="statement not covered" >i</span>f(this._fieldObjects)<span class="cstat-no" title="statement not covered" >t.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s?.();c</span>onst{fields:t,refs:i,include:a}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0!==t.length||0!==i.length){const e=<span class="cstat-no" title="statement not covered" >new Set(i);<span class="cstat-no" title="statement not covered" ></span>for(const s of t){const t=<span class="cstat-no" title="statement not covered" >this._fieldObjects[s]||[];<span class="cstat-no" title="statement not covered" ></span>for(const{id:s}of t)<span class="cstat-no" title="statement not covered" >e.add(s)}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(const t of Object.values(this._fieldObjects))<span class="cstat-no" title="statement not covered" >for(const s of t)<span class="cstat-no" title="statement not covered" >e.has(s.id)===a&amp;&amp;r.push(s)}</span></span></span>else <span class="cstat-no" title="statement not covered" >for(const t of Object.values(this._fieldObjects))<span class="cstat-no" title="statement not covered" >r.push(...t);c</span></span></span>onst o=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const t of r){const{id:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>l.push(e);<span class="cstat-no" title="statement not covered" >s</span>witch(t.type){case"text":{const s=<span class="cstat-no" title="statement not covered" >t.defaultValue||"";<span class="cstat-no" title="statement not covered" ></span>o.setValue(e,{value:s});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"checkbox":case"radiobutton":{const s=<span class="cstat-no" title="statement not covered" >t.defaultValue===t.exportValues;<span class="cstat-no" title="statement not covered" ></span>o.setValue(e,{value:s});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"combobox":case"listbox":{const s=<span class="cstat-no" title="statement not covered" >t.defaultValue||"";<span class="cstat-no" title="statement not covered" ></span>o.setValue(e,{value:s});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >continue}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >document.querySelector(`[data-element-id="${e}"]`);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(c.has(s)?s.dispatchEvent(new Event("resetform")):(0,n.warn)(`_bindResetFormAction - element not allowed: ${e}`))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.enableScripting&amp;&amp;this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:"app",ids:l,name:"ResetForm"}});<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;e</span>lse{<span class="cstat-no" title="statement not covered" >(0,n.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.');<span class="cstat-no" title="statement not covered" >s</span>||(t.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1)</span>}</span>}</span>}class TextAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str)})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("textAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >document.createElement("img");<span class="cstat-no" title="statement not covered" ></span>t.src=this.imageResourcesPath+"annotation-"+this.data.name.toLowerCase()+".svg";<span class="cstat-no" title="statement not covered" >t</span>.alt="[{{type}} Annotation]";<span class="cstat-no" title="statement not covered" >t</span>.dataset.l10nId="text_annotation_type";<span class="cstat-no" title="statement not covered" >t</span>.dataset.l10nArgs=JSON.stringify({type:this.data.name});<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.append(t);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class WidgetAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.alternativeText&amp;&amp;(this.container.title=this.data.alternativeText);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>sh</span>owElementAndHideCanvas(t){<span class="cstat-no" title="statement not covered" >if(this.data.hasOwnCanvas){<span class="cstat-no" title="statement not covered" >"CANVAS"===t.previousSibling?.nodeName&amp;&amp;(t.previousSibling.hidden=!0);<span class="cstat-no" title="statement not covered" >t</span>.hidden=!1}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etKeyModifier(t){const{isWin:e,isMac:s}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;t.ctrlKey||s&amp;&amp;t.metaKey}<span class="fstat-no" title="function not covered" ></span>_s</span>etEventListener(t,e,s,n){<span class="cstat-no" title="statement not covered" >e.includes("mouse")?t.addEventListener(e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:this.data.id,name:s,value:n(t),shift:t.shiftKey,modifier:this._getKeyModifier(t)}})}</span>)):t.addEventListener(e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:this.data.id,name:s,value:n(t)}})}</span>))}<span class="fstat-no" title="function not covered" ></span>_s</span>etEventListeners(t,e,s){<span class="cstat-no" title="statement not covered" >for(const[n,i]of e)<span class="cstat-no" title="statement not covered" >("Action"===i||this.data.actions?.[i])&amp;&amp;this._setEventListener(t,n,i,s)}<span class="fstat-no" title="function not covered" ></span></span>_s</span>etBackgroundColor(t){const e=<span class="cstat-no" title="statement not covered" >this.data.backgroundColor||null;<span class="cstat-no" title="statement not covered" ></span>t.style.backgroundColor=null===e?"transparent":n.Util.makeHexColor(e[0],e[1],e[2])}<span class="fstat-no" title="function not covered" ></span>_s</span>etTextStyle(t){const e=<span class="cstat-no" title="statement not covered" >["left","center","right"],</span>{fontColor:s}=<span class="cstat-no" title="statement not covered" >this.data.defaultAppearanceData,</span>i=<span class="cstat-no" title="statement not covered" >this.data.defaultAppearanceData.fontSize||9,</span>a=<span class="cstat-no" title="statement not covered" >t.style;</span>let r;const roundToOneDecimal=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(10*t)/10;<span class="cstat-no" title="statement not covered" ></span></span>if(this.data.multiLine){const t=<span class="cstat-no" title="statement not covered" >Math.abs(this.data.rect[3]-this.data.rect[1]-2),</span>e=<span class="cstat-no" title="statement not covered" >t/(Math.round(t/(n.LINE_FACTOR*i))||1);<span class="cstat-no" title="statement not covered" ></span>r=Math.min(i,roundToOneDecimal(e/n.LINE_FACTOR))}</span>else{const t=<span class="cstat-no" title="statement not covered" >Math.abs(this.data.rect[3]-this.data.rect[1]-2);<span class="cstat-no" title="statement not covered" ></span>r=Math.min(i,roundToOneDecimal(t/n.LINE_FACTOR))}<span class="cstat-no" title="statement not covered" ></span>a</span>.fontSize=`calc(${r}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" >a</span>.color=n.Util.makeHexColor(s[0],s[1],s[2]);<span class="cstat-no" title="statement not covered" >n</span>ull!==this.data.textAlignment&amp;&amp;(a.textAlign=e[this.data.textAlignment])}<span class="fstat-no" title="function not covered" ></span>_s</span>etRequired(t,e){<span class="cstat-no" title="statement not covered" >e?t.setAttribute("required",!0):t.removeAttribute("required");<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("aria-required",e)}</span>}class TextWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms||!t.data.hasAppearance&amp;&amp;!!t.data.fieldValue})}<span class="fstat-no" title="function not covered" ></span>se</span>tPropertyOnSiblings(t,e,s,n){const i=<span class="cstat-no" title="statement not covered" >this.annotationStorage;<span class="cstat-no" title="statement not covered" ></span>for(const a of this._getElementsByName(t.name,t.id)){<span class="cstat-no" title="statement not covered" >a.domElement&amp;&amp;(a.domElement[e]=s);<span class="cstat-no" title="statement not covered" >i</span>.setValue(a.id,{[n]:s})}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data.id;<span class="cstat-no" title="statement not covered" ></span>this.container.classList.add("textWidgetAnnotation");l</span>et s=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.renderForms){const n=<span class="cstat-no" title="statement not covered" >t.getValue(e,{value:this.data.fieldValue});</span>let i=<span class="cstat-no" title="statement not covered" >n.value||"";</span>const a=<span class="cstat-no" title="statement not covered" >t.getValue(e,{charLimit:this.data.maxLen}).charLimit;<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;i.length&gt;a&amp;&amp;(i=i.slice(0,a));l</span>et r=<span class="cstat-no" title="statement not covered" >n.formattedValue||this.data.textContent?.join("\n")||null;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;this.data.comb&amp;&amp;(r=r.replaceAll(/\s+/g,""));c</span>onst o=<span class="cstat-no" title="statement not covered" >{userValue:i,formattedValue:r,lastCommittedValue:null,commitKey:1};<span class="cstat-no" title="statement not covered" ></span>if(this.data.multiLine){<span class="cstat-no" title="statement not covered" >s=document.createElement("textarea");<span class="cstat-no" title="statement not covered" >s</span>.textContent=r??i;<span class="cstat-no" title="statement not covered" >t</span>his.data.doNotScroll&amp;&amp;(s.style.overflowY="hidden")}</span>else{<span class="cstat-no" title="statement not covered" >s=document.createElement("input");<span class="cstat-no" title="statement not covered" >s</span>.type="text";<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("value",r??i);<span class="cstat-no" title="statement not covered" >t</span>his.data.doNotScroll&amp;&amp;(s.style.overflowX="hidden")}<span class="cstat-no" title="statement not covered" ></span>t</span>his.data.hasOwnCanvas&amp;&amp;(s.hidden=!0);<span class="cstat-no" title="statement not covered" >c</span>.add(s);<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("data-element-id",e);<span class="cstat-no" title="statement not covered" >s</span>.disabled=this.data.readOnly;<span class="cstat-no" title="statement not covered" >s</span>.name=this.data.baseFieldName||this.data.fieldName;<span class="cstat-no" title="statement not covered" >s</span>.tabIndex=l;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(s,this.data.required);<span class="cstat-no" title="statement not covered" >a</span>&amp;&amp;(s.maxLength=a);<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.setValue(e,{value:n.target.value});<span class="cstat-no" title="statement not covered" >t</span>his.setPropertyOnSiblings(s,"value",n.target.value,"value");<span class="cstat-no" title="statement not covered" >o</span>.formattedValue=null}</span>));<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >this.data.defaultFieldValue??"";<span class="cstat-no" title="statement not covered" ></span>s.value=o.userValue=e;<span class="cstat-no" title="statement not covered" >o</span>.formattedValue=null}</span>));l</span>et blurListener=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const{formattedValue:e}=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>null!=e&amp;&amp;(t.target.value=e);<span class="cstat-no" title="statement not covered" >t</span>.target.scrollLeft=0}</span>;<span class="cstat-no" title="statement not covered" ></span>if(this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >s.addEventListener("focus",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{target:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>o.userValue&amp;&amp;(e.value=o.userValue);<span class="cstat-no" title="statement not covered" >o</span>.lastCommittedValue=e.value;<span class="cstat-no" title="statement not covered" >o</span>.commitKey=1}</span>));<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.showElementAndHideCanvas(s.target);c</span>onst n=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >va</span>lue(s){<span class="cstat-no" title="statement not covered" >o.userValue=s.detail.value??"";<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:o.userValue.toString()});<span class="cstat-no" title="statement not covered" >s</span>.target.value=o.userValue}</span>,<span class="fstat-no" title="function not covered" >fo</span>rmattedValue(s){const{formattedValue:n}=<span class="cstat-no" title="statement not covered" >s.detail;<span class="cstat-no" title="statement not covered" ></span>o.formattedValue=n;<span class="cstat-no" title="statement not covered" >n</span>ull!=n&amp;&amp;s.target!==document.activeElement&amp;&amp;(s.target.value=n);<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{formattedValue:n})}</span>,<span class="fstat-no" title="function not covered" >se</span>lRange(t){<span class="cstat-no" title="statement not covered" >t.target.setSelectionRange(...t.detail.selRange)}</span>,charLimit:<span class="fstat-no" title="function not covered" >s=</span>&gt;{const{charLimit:n}=<span class="cstat-no" title="statement not covered" >s.detail,</span>{target:i}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(0===n){<span class="cstat-no" title="statement not covered" >i.removeAttribute("maxLength");<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>.setAttribute("maxLength",n);l</span>et a=<span class="cstat-no" title="statement not covered" >o.userValue;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;!(a.length&lt;=n)){<span class="cstat-no" title="statement not covered" >a=a.slice(0,n);<span class="cstat-no" title="statement not covered" >i</span>.value=o.userValue=a;<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:a});<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:a,willCommit:!0,commitKey:1,selStart:i.selectionStart,selEnd:i.selectionEnd}})}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(n,s)}</span>));<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("keydown",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >o.commitKey=1;l</span>et s=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>"Escape"===t.key?s=0:"Enter"!==t.key||this.data.multiLine?"Tab"===t.key&amp;&amp;(o.commitKey=3):s=2;<span class="cstat-no" title="statement not covered" >i</span>f(-1===s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{value:n}=<span class="cstat-no" title="statement not covered" >t.target;<span class="cstat-no" title="statement not covered" ></span>if(o.lastCommittedValue!==n){<span class="cstat-no" title="statement not covered" >o.lastCommittedValue=n;<span class="cstat-no" title="statement not covered" >o</span>.userValue=n;<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:n,willCommit:!0,commitKey:s,selStart:t.target.selectionStart,selEnd:t.target.selectionEnd}})}</span>}</span>));c</span>onst n=<span class="cstat-no" title="statement not covered" >blurListener;<span class="cstat-no" title="statement not covered" ></span>blurListener=null;<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("blur",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!t.relatedTarget)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{value:s}=<span class="cstat-no" title="statement not covered" >t.target;<span class="cstat-no" title="statement not covered" ></span>o.userValue=s;<span class="cstat-no" title="statement not covered" >o</span>.lastCommittedValue!==s&amp;&amp;this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:s,willCommit:!0,commitKey:o.commitKey,selStart:t.target.selectionStart,selEnd:t.target.selectionEnd}});<span class="cstat-no" title="statement not covered" >n</span>(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his.data.actions?.Keystroke&amp;&amp;s.addEventListener("beforeinput",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >o.lastCommittedValue=null;c</span>onst{data:s,target:n}=<span class="cstat-no" title="statement not covered" >t,</span>{value:i,selectionStart:a,selectionEnd:r}=<span class="cstat-no" title="statement not covered" >n;</span>let l=<span class="cstat-no" title="statement not covered" >a,</span>c=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>switch(t.inputType){case"deleteWordBackward":{const t=<span class="cstat-no" title="statement not covered" >i.substring(0,a).match(/\w*[^\w]*$/);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(l-=t[0].length);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"deleteWordForward":{const t=<span class="cstat-no" title="statement not covered" >i.substring(a).match(/^[^\w]*\w*/);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(c+=t[0].length);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"deleteContentBackward":<span class="cstat-no" title="statement not covered" >a===r&amp;&amp;(l-=1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"deleteContentForward":<span class="cstat-no" title="statement not covered" >a===r&amp;&amp;(c+=1)}<span class="cstat-no" title="statement not covered" ></span>t</span>.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:i,change:s||"",willCommit:!1,selStart:l,selEnd:c}})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(s,[["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.value)</span>)}<span class="cstat-no" title="statement not covered" ></span>b</span>lurListener&amp;&amp;s.addEventListener("blur",blurListener);<span class="cstat-no" title="statement not covered" >i</span>f(this.data.comb){const t=<span class="cstat-no" title="statement not covered" >(this.data.rect[2]-this.data.rect[0])/a;<span class="cstat-no" title="statement not covered" ></span>s.classList.add("comb");<span class="cstat-no" title="statement not covered" >s</span>.style.letterSpacing=`calc(${t}px * var(--scale-factor) - 1ch)`}</span>}</span>else{<span class="cstat-no" title="statement not covered" >s=document.createElement("div");<span class="cstat-no" title="statement not covered" >s</span>.textContent=this.data.fieldValue;<span class="cstat-no" title="statement not covered" >s</span>.style.verticalAlign="middle";<span class="cstat-no" title="statement not covered" >s</span>.style.display="table-cell"}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setTextStyle(s);<span class="cstat-no" title="statement not covered" >t</span>his._setBackgroundColor(s);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(s);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class SignatureWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!t.data.hasOwnCanvas})}</span>}class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data,</span>s=<span class="cstat-no" title="statement not covered" >e.id;</span>let n=<span class="cstat-no" title="statement not covered" >t.getValue(s,{value:e.exportValue===e.fieldValue}).value;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof n){<span class="cstat-no" title="statement not covered" >n="Off"!==n;<span class="cstat-no" title="statement not covered" >t</span>.setValue(s,{value:n})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.classList.add("buttonWidgetAnnotation","checkBox");c</span>onst i=<span class="cstat-no" title="statement not covered" >document.createElement("input");<span class="cstat-no" title="statement not covered" ></span>c.add(i);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("data-element-id",s);<span class="cstat-no" title="statement not covered" >i</span>.disabled=e.readOnly;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(i,this.data.required);<span class="cstat-no" title="statement not covered" >i</span>.type="checkbox";<span class="cstat-no" title="statement not covered" >i</span>.name=e.baseFieldName||e.fieldName;<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;i.setAttribute("checked",!0);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("exportValue",e.exportValue);<span class="cstat-no" title="statement not covered" >i</span>.tabIndex=l;<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("change",(<span class="fstat-no" title="function not covered" >n=</span>&gt;{const{name:i,checked:a}=<span class="cstat-no" title="statement not covered" >n.target;<span class="cstat-no" title="statement not covered" ></span>for(const n of this._getElementsByName(i,s)){const s=<span class="cstat-no" title="statement not covered" >a&amp;&amp;n.exportValue===e.exportValue;<span class="cstat-no" title="statement not covered" ></span>n.domElement&amp;&amp;(n.domElement.checked=s);<span class="cstat-no" title="statement not covered" >t</span>.setValue(n.id,{value:s})}<span class="cstat-no" title="statement not covered" ></span>t</span>.setValue(s,{value:a})}</span>));<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >e.defaultFieldValue||"Off";<span class="cstat-no" title="statement not covered" ></span>t.target.checked=s===e.exportValue}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >i.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >va</span>lue(e){<span class="cstat-no" title="statement not covered" >e.target.checked="Off"!==e.detail.value;<span class="cstat-no" title="statement not covered" >t</span>.setValue(s,{value:e.target.checked})}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(n,e)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(i,[["change","Validate"],["change","Action"],["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.checked)</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setBackgroundColor(i);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(i);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(i);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("buttonWidgetAnnotation","radioButton");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data,</span>s=<span class="cstat-no" title="statement not covered" >e.id;</span>let n=<span class="cstat-no" title="statement not covered" >t.getValue(s,{value:e.fieldValue===e.buttonValue}).value;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof n){<span class="cstat-no" title="statement not covered" >n=n!==e.buttonValue;<span class="cstat-no" title="statement not covered" >t</span>.setValue(s,{value:n})}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >document.createElement("input");<span class="cstat-no" title="statement not covered" ></span>c.add(i);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("data-element-id",s);<span class="cstat-no" title="statement not covered" >i</span>.disabled=e.readOnly;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(i,this.data.required);<span class="cstat-no" title="statement not covered" >i</span>.type="radio";<span class="cstat-no" title="statement not covered" >i</span>.name=e.baseFieldName||e.fieldName;<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;i.setAttribute("checked",!0);<span class="cstat-no" title="statement not covered" >i</span>.tabIndex=l;<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("change",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{name:n,checked:i}=<span class="cstat-no" title="statement not covered" >e.target;<span class="cstat-no" title="statement not covered" ></span>for(const e of this._getElementsByName(n,s))<span class="cstat-no" title="statement not covered" >t.setValue(e.id,{value:!1});<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(s,{value:i})}</span>));<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >e.defaultFieldValue;<span class="cstat-no" title="statement not covered" ></span>t.target.checked=null!=s&amp;&amp;s===e.buttonValue}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(this.enableScripting&amp;&amp;this.hasJSActions){const n=<span class="cstat-no" title="statement not covered" >e.buttonValue;<span class="cstat-no" title="statement not covered" ></span>i.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >{value:<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >n===e.detail.value;<span class="cstat-no" title="statement not covered" ></span>for(const n of this._getElementsByName(e.target.name)){const e=<span class="cstat-no" title="statement not covered" >i&amp;&amp;n.id===s;<span class="cstat-no" title="statement not covered" ></span>n.domElement&amp;&amp;(n.domElement.checked=e);<span class="cstat-no" title="statement not covered" >t</span>.setValue(n.id,{value:e})}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(i,e)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(i,[["change","Validate"],["change","Action"],["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.checked)</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setBackgroundColor(i);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(i);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(i);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class PushButtonWidgetAnnotationElement extends LinkAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{ignoreBorder:t.data.hasAppearance})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >super.render();<span class="cstat-no" title="statement not covered" ></span>t.classList.add("buttonWidgetAnnotation","pushButton");<span class="cstat-no" title="statement not covered" >t</span>his.data.alternativeText&amp;&amp;(t.title=this.data.alternativeText);c</span>onst e=<span class="cstat-no" title="statement not covered" >t.lastChild;<span class="cstat-no" title="statement not covered" ></span>if(this.enableScripting&amp;&amp;this.hasJSActions&amp;&amp;e){<span class="cstat-no" title="statement not covered" >this._setDefaultPropertiesFromJS(e);<span class="cstat-no" title="statement not covered" >e</span>.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._dispatchEventFromSandbox({},t)}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>}class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("choiceWidgetAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data.id,</span>s=<span class="cstat-no" title="statement not covered" >t.getValue(e,{value:this.data.fieldValue}),</span>n=<span class="cstat-no" title="statement not covered" >document.createElement("select");<span class="cstat-no" title="statement not covered" ></span>c.add(n);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("data-element-id",e);<span class="cstat-no" title="statement not covered" >n</span>.disabled=this.data.readOnly;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(n,this.data.required);<span class="cstat-no" title="statement not covered" >n</span>.name=this.data.baseFieldName||this.data.fieldName;<span class="cstat-no" title="statement not covered" >n</span>.tabIndex=l;l</span>et i=<span class="cstat-no" title="statement not covered" >this.data.combo&amp;&amp;this.data.options.length&gt;0;<span class="cstat-no" title="statement not covered" ></span>if(!this.data.combo){<span class="cstat-no" title="statement not covered" >n.size=this.data.options.length;<span class="cstat-no" title="statement not covered" >t</span>his.data.multiSelect&amp;&amp;(n.multiple=!0)}<span class="cstat-no" title="statement not covered" ></span>n</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >this.data.defaultFieldValue;<span class="cstat-no" title="statement not covered" ></span>for(const t of n.options)<span class="cstat-no" title="statement not covered" >t.selected=t.value===e}</span></span>));<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.data.options){const e=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>e.textContent=t.displayValue;<span class="cstat-no" title="statement not covered" >e</span>.value=t.exportValue;<span class="cstat-no" title="statement not covered" >i</span>f(s.value.includes(t.exportValue)){<span class="cstat-no" title="statement not covered" >e.setAttribute("selected",!0);<span class="cstat-no" title="statement not covered" >i</span>=!1}<span class="cstat-no" title="statement not covered" ></span>n</span>.append(e)}</span>l</span>et a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(i){const t=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>t.value=" ";<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("hidden",!0);<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("selected",!0);<span class="cstat-no" title="statement not covered" >n</span>.prepend(t);<span class="cstat-no" title="statement not covered" >a</span>=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.remove();<span class="cstat-no" title="statement not covered" >n</span>.removeEventListener("input",a);<span class="cstat-no" title="statement not covered" >a</span>=null}</span>;<span class="cstat-no" title="statement not covered" >n</span>.addEventListener("input",a)}</span>c</span>onst getValue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t?"value":"textContent",</span>{options:s,multiple:i}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>return i?Array.prototype.filter.call(s,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.selected)</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[e])</span>):-1===s.selectedIndex?null:s[s.selectedIndex][e]}</span>;</span>let r=<span class="cstat-no" title="statement not covered" >getValue(!1);</span>const getItems=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.target.options;<span class="cstat-no" title="statement not covered" ></span>return Array.prototype.map.call(e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{displayValue:t.textContent,exportValue:t.value})</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>if(this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >n.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >s=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >va</span>lue(s){<span class="cstat-no" title="statement not covered" >a?.();c</span>onst i=<span class="cstat-no" title="statement not covered" >s.detail.value,</span>o=<span class="cstat-no" title="statement not covered" >new Set(Array.isArray(i)?i:[i]);<span class="cstat-no" title="statement not covered" ></span>for(const t of n.options)<span class="cstat-no" title="statement not covered" >t.selected=o.has(t.value);<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(e,{value:getValue(!0)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >mu</span>ltipleSelection(t){<span class="cstat-no" title="statement not covered" >n.multiple=!0}</span>,<span class="fstat-no" title="function not covered" >re</span>move(s){const i=<span class="cstat-no" title="statement not covered" >n.options,</span>a=<span class="cstat-no" title="statement not covered" >s.detail.remove;<span class="cstat-no" title="statement not covered" ></span>i[a].selected=!1;<span class="cstat-no" title="statement not covered" >n</span>.remove(a);<span class="cstat-no" title="statement not covered" >i</span>f(i.length&gt;0){<span class="cstat-no" title="statement not covered" >-1===Array.prototype.findIndex.call(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.selected)</span>)&amp;&amp;(i[0].selected=!0)}<span class="cstat-no" title="statement not covered" ></span>t</span>.setValue(e,{value:getValue(!0),items:getItems(s)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >cl</span>ear(s){<span class="cstat-no" title="statement not covered" >for(;0!==n.length;)<span class="cstat-no" title="statement not covered" >n.remove(0);<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(e,{value:null,items:[]});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >in</span>sert(s){const{index:i,displayValue:a,exportValue:o}=<span class="cstat-no" title="statement not covered" >s.detail.insert,</span>l=<span class="cstat-no" title="statement not covered" >n.children[i],</span>c=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>c.textContent=a;<span class="cstat-no" title="statement not covered" >c</span>.value=o;<span class="cstat-no" title="statement not covered" >l</span>?l.before(c):n.append(c);<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:getValue(!0),items:getItems(s)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >it</span>ems(s){const{items:i}=<span class="cstat-no" title="statement not covered" >s.detail;<span class="cstat-no" title="statement not covered" ></span>for(;0!==n.length;)<span class="cstat-no" title="statement not covered" >n.remove(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(const t of i){const{displayValue:e,exportValue:s}=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>i.textContent=e;<span class="cstat-no" title="statement not covered" >i</span>.value=s;<span class="cstat-no" title="statement not covered" >n</span>.append(i)}<span class="cstat-no" title="statement not covered" ></span>n</span>.options.length&gt;0&amp;&amp;(n.options[0].selected=!0);<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:getValue(!0),items:getItems(s)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >in</span>dices(s){const n=<span class="cstat-no" title="statement not covered" >new Set(s.detail.indices);<span class="cstat-no" title="statement not covered" ></span>for(const t of s.target.options)<span class="cstat-no" title="statement not covered" >t.selected=n.has(t.index);<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(e,{value:getValue(!0)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >ed</span>itable(t){<span class="cstat-no" title="statement not covered" >t.target.disabled=!t.detail.editable}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(i,s)}</span>));<span class="cstat-no" title="statement not covered" >n</span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >s=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >getValue(!0);<span class="cstat-no" title="statement not covered" ></span>t.setValue(e,{value:n});<span class="cstat-no" title="statement not covered" >s</span>.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:r,changeEx:n,willCommit:!1,commitKey:1,keyDown:!1}})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(n,[["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"],["input","Action"],["input","Validate"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.value)</span>)}</span>else <span class="cstat-no" title="statement not covered" >n.addEventListener("input",(<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >t.setValue(e,{value:getValue(!0)})}</span>));<span class="cstat-no" title="statement not covered" >t</span></span>his.data.combo&amp;&amp;this._setTextStyle(n);<span class="cstat-no" title="statement not covered" >t</span>his._setBackgroundColor(n);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(n);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class PopupAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){const{data:e,elements:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>super(t,{isRenderable:!!(e.titleObj?.str||e.contentsObj?.str||e.richText?.str)});<span class="cstat-no" title="statement not covered" >t</span>his.elements=s}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("popupAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >new PopupElement({container:this.container,color:this.data.color,titleObj:this.data.titleObj,modificationDate:this.data.modificationDate,contentsObj:this.data.contentsObj,richText:this.data.richText,rect:this.data.rect,parentRect:this.data.parentRect||null,parent:this.parent,elements:this.elements,open:this.data.open}),</span>e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const s of this.elements){<span class="cstat-no" title="statement not covered" >s.popup=t;<span class="cstat-no" title="statement not covered" >e</span>.push(s.data.id);<span class="cstat-no" title="statement not covered" >s</span>.addHighlightArea()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.setAttribute("aria-controls",e.join(","));<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class PopupElement{#Se=<span class="cstat-no" title="statement not covered" >null;</span>#Ee=<span class="cstat-no" title="statement not covered" >this.#xe.bind(this);</span>#Ce=<span class="cstat-no" title="statement not covered" >this.#we.bind(this);</span>#Te=<span class="cstat-no" title="statement not covered" >this.#Pe.bind(this);</span>#le=<span class="cstat-no" title="statement not covered" >null;</span>#st=<span class="cstat-no" title="statement not covered" >null;</span>#Fe=<span class="cstat-no" title="statement not covered" >null;</span>#ke=<span class="cstat-no" title="statement not covered" >null;</span>#Me=<span class="cstat-no" title="statement not covered" >null;</span>#Re=<span class="cstat-no" title="statement not covered" >null;</span>#De=<span class="cstat-no" title="statement not covered" >!1;</span>#Ie=<span class="cstat-no" title="statement not covered" >null;</span>#Oe=<span class="cstat-no" title="statement not covered" >null;</span>#Le=<span class="cstat-no" title="statement not covered" >null;</span>#Ne=<span class="cstat-no" title="statement not covered" >null;</span>#Be=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({container:t,color:e,elements:s,titleObj:n,modificationDate:a,contentsObj:r,richText:o,parent:l,rect:c,parentRect:h,open:d}){<span class="cstat-no" title="statement not covered" >this.#st=t;<span class="cstat-no" title="statement not covered" >t</span>his.#Ne=n;<span class="cstat-no" title="statement not covered" >t</span>his.#Fe=r;<span class="cstat-no" title="statement not covered" >t</span>his.#Le=o;<span class="cstat-no" title="statement not covered" >t</span>his.#Me=l;<span class="cstat-no" title="statement not covered" >t</span>his.#le=e;<span class="cstat-no" title="statement not covered" >t</span>his.#Oe=c;<span class="cstat-no" title="statement not covered" >t</span>his.#Re=h;<span class="cstat-no" title="statement not covered" >t</span>his.#ke=s;c</span>onst u=<span class="cstat-no" title="statement not covered" >i.PDFDateString.toDateObject(a);<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(this.#Se=l.l10n.get("annotation_date_string",{date:u.toLocaleDateString(),time:u.toLocaleTimeString()}));<span class="cstat-no" title="statement not covered" >t</span>his.trigger=s.flatMap((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.getElementsToTriggerPopup())</span>);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.trigger){<span class="cstat-no" title="statement not covered" >t.addEventListener("click",this.#Te);<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("mouseenter",this.#Ce);<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("mouseleave",this.#Ee)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#st.hidden=!0;<span class="cstat-no" title="statement not covered" >d</span>&amp;&amp;this.#Pe()}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.#Ie)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{page:{view:t},viewport:{rawDims:{pageWidth:e,pageHeight:s,pageX:i,pageY:a}}}=<span class="cstat-no" title="statement not covered" >this.#Me,</span>r=<span class="cstat-no" title="statement not covered" >this.#Ie=document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>r.className="popup";<span class="cstat-no" title="statement not covered" >i</span>f(this.#le){const t=<span class="cstat-no" title="statement not covered" >r.style.outlineColor=n.Util.makeHexColor(...this.#le);<span class="cstat-no" title="statement not covered" ></span>if(CSS.supports("background-color","color-mix(in srgb, red 30%, white)"))<span class="cstat-no" title="statement not covered" >r.style.backgroundColor=`color-mix(in srgb, ${t} 30%, white)`;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >.7;<span class="cstat-no" title="statement not covered" ></span>r.style.backgroundColor=n.Util.makeHexColor(...this.#le.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.floor(t*(255-e)+e))</span>))}</span>}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>l.className="header";c</span>onst c=<span class="cstat-no" title="statement not covered" >document.createElement("h1");<span class="cstat-no" title="statement not covered" ></span>l.append(c);<span class="cstat-no" title="statement not covered" >(</span>{dir:c.dir,str:c.textContent}=this.#Ne);<span class="cstat-no" title="statement not covered" >r</span>.append(l);<span class="cstat-no" title="statement not covered" >i</span>f(this.#Se){const t=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>t.classList.add("popupDate");<span class="cstat-no" title="statement not covered" >t</span>his.#Se.then((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.textContent=e}</span>));<span class="cstat-no" title="statement not covered" >l</span>.append(t)}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >this.#Fe,</span>d=<span class="cstat-no" title="statement not covered" >this.#Le;<span class="cstat-no" title="statement not covered" ></span>if(!d?.str||h?.str&amp;&amp;h.str!==d.str){const t=<span class="cstat-no" title="statement not covered" >this._formatContents(h);<span class="cstat-no" title="statement not covered" ></span>r.append(t)}</span>else{<span class="cstat-no" title="statement not covered" >o.XfaLayer.render({xfaHtml:d.html,intent:"richText",div:r});<span class="cstat-no" title="statement not covered" >r</span>.lastChild.classList.add("richText","popupContent")}</span>l</span>et u=<span class="cstat-no" title="statement not covered" >!!this.#Re,</span>p=<span class="cstat-no" title="statement not covered" >u?this.#Re:this.#Oe;<span class="cstat-no" title="statement not covered" ></span>for(const t of this.#ke)<span class="cstat-no" title="statement not covered" >if(!p||null!==n.Util.intersect(t.data.rect,p)){<span class="cstat-no" title="statement not covered" >p=t.data.rect;<span class="cstat-no" title="statement not covered" >u</span>=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>c</span></span>onst g=<span class="cstat-no" title="statement not covered" >n.Util.normalizeRect([p[0],t[3]-p[1]+t[1],p[2],t[3]-p[3]+t[1]]),</span>f=<span class="cstat-no" title="statement not covered" >u?p[2]-p[0]+5:0,</span>m=<span class="cstat-no" title="statement not covered" >g[0]+f,</span>b=<span class="cstat-no" title="statement not covered" >g[1],</span>{style:A}=<span class="cstat-no" title="statement not covered" >this.#st;<span class="cstat-no" title="statement not covered" ></span>A.left=100*(m-i)/e+"%";<span class="cstat-no" title="statement not covered" >A</span>.top=100*(b-a)/s+"%";<span class="cstat-no" title="statement not covered" >t</span>his.#st.append(r)}<span class="fstat-no" title="function not covered" ></span>_f</span>ormatContents({str:t,dir:e}){const s=<span class="cstat-no" title="statement not covered" >document.createElement("p");<span class="cstat-no" title="statement not covered" ></span>s.classList.add("popupContent");<span class="cstat-no" title="statement not covered" >s</span>.dir=e;c</span>onst n=<span class="cstat-no" title="statement not covered" >t.split(/(?:\r\n?|\n)/);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >n.length;</span>t&lt;e;++t){const i=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>s.append(document.createTextNode(i));<span class="cstat-no" title="statement not covered" >t</span>&lt;e-1&amp;&amp;s.append(document.createElement("br"))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>#Pe(){<span class="cstat-no" title="statement not covered" >this.#De=!this.#De;<span class="cstat-no" title="statement not covered" >i</span>f(this.#De){<span class="cstat-no" title="statement not covered" >this.#we();<span class="cstat-no" title="statement not covered" >t</span>his.#st.addEventListener("click",this.#Te)}</span>else{<span class="cstat-no" title="statement not covered" >this.#xe();<span class="cstat-no" title="statement not covered" >t</span>his.#st.removeEventListener("click",this.#Te)}</span>}</span>#we(){<span class="cstat-no" title="statement not covered" >this.#Ie||this.render();<span class="cstat-no" title="statement not covered" >i</span>f(this.isVisible)<span class="cstat-no" title="statement not covered" >this.#De&amp;&amp;this.#st.classList.add("focused");e</span>lse{<span class="cstat-no" title="statement not covered" >this.#st.hidden=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#st.style.zIndex=parseInt(this.#st.style.zIndex)+1e3}</span>}</span>#xe(){<span class="cstat-no" title="statement not covered" >this.#st.classList.remove("focused");<span class="cstat-no" title="statement not covered" >i</span>f(!this.#De){<span class="cstat-no" title="statement not covered" >this.#st.hidden=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#st.style.zIndex=parseInt(this.#st.style.zIndex)-1e3}</span>}<span class="fstat-no" title="function not covered" ></span>fo</span>rceHide(){<span class="cstat-no" title="statement not covered" >this.#Be=this.isVisible;<span class="cstat-no" title="statement not covered" >t</span>his.#Be&amp;&amp;(this.#st.hidden=!0)}<span class="fstat-no" title="function not covered" ></span>ma</span>ybeShow(){<span class="cstat-no" title="statement not covered" >if(this.#Be){<span class="cstat-no" title="statement not covered" >this.#Be=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#st.hidden=!1}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isVisible(){<span class="cstat-no" title="statement not covered" >return!1===this.#st.hidden}</span>}class FreeTextAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0});<span class="cstat-no" title="statement not covered" >t</span>his.textContent=t.data.textContent;<span class="cstat-no" title="statement not covered" >t</span>his.annotationEditorType=n.AnnotationEditorType.FREETEXT}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("freeTextAnnotation");<span class="cstat-no" title="statement not covered" >i</span>f(this.textContent){const t=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>t.classList.add("annotationTextContent");<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("role","comment");<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.textContent){const s=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>s.textContent=e;<span class="cstat-no" title="statement not covered" >t</span>.append(s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.append(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}<span class="cstat-no" title="statement not covered" >e.FreeTextAnnotationElement=FreeTextAnnotationElement;c</span>lass LineAnnotationElement extends AnnotationElement{#je=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("lineAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:s}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>n=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,s,!0),</span>i=<span class="cstat-no" title="statement not covered" >this.#je=this.svgFactory.createElement("svg:line");<span class="cstat-no" title="statement not covered" ></span>i.setAttribute("x1",t.rect[2]-t.lineCoordinates[0]);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("y1",t.rect[3]-t.lineCoordinates[1]);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("x2",t.rect[2]-t.lineCoordinates[2]);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("y2",t.rect[3]-t.lineCoordinates[3]);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("stroke-width",t.borderStyle.width||1);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >n</span>.append(i);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#je}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class SquareAnnotationElement extends AnnotationElement{#Ue=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("squareAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:s}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>n=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,s,!0),</span>i=<span class="cstat-no" title="statement not covered" >t.borderStyle.width,</span>a=<span class="cstat-no" title="statement not covered" >this.#Ue=this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("x",i/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("y",i/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("width",e-i);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("height",s-i);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke-width",i||1);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >n</span>.append(a);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#Ue}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class CircleAnnotationElement extends AnnotationElement{#He=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("circleAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:s}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>n=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,s,!0),</span>i=<span class="cstat-no" title="statement not covered" >t.borderStyle.width,</span>a=<span class="cstat-no" title="statement not covered" >this.#He=this.svgFactory.createElement("svg:ellipse");<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("cx",e/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("cy",s/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("rx",e/2-i/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("ry",s/2-i/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke-width",i||1);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >n</span>.append(a);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#He}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class PolylineAnnotationElement extends AnnotationElement{#qe=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0});<span class="cstat-no" title="statement not covered" >t</span>his.containerClassName="polylineAnnotation";<span class="cstat-no" title="statement not covered" >t</span>his.svgElementName="svg:polyline"}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add(this.containerClassName);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:s}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>n=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,s,!0);</span>let i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of t.vertices){const s=<span class="cstat-no" title="statement not covered" >e.x-t.rect[0],</span>n=<span class="cstat-no" title="statement not covered" >t.rect[3]-e.y;<span class="cstat-no" title="statement not covered" ></span>i.push(s+","+n)}<span class="cstat-no" title="statement not covered" ></span>i</span>=i.join(" ");c</span>onst a=<span class="cstat-no" title="statement not covered" >this.#qe=this.svgFactory.createElement(this.svgElementName);<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("points",i);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke-width",t.borderStyle.width||1);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >n</span>.append(a);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup(a,t);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#qe}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class PolygonAnnotationElement extends PolylineAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);<span class="cstat-no" title="statement not covered" >t</span>his.containerClassName="polygonAnnotation";<span class="cstat-no" title="statement not covered" >t</span>his.svgElementName="svg:polygon"}</span>}class CaretAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("caretAnnotation");<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class InkAnnotationElement extends AnnotationElement{#We=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0});<span class="cstat-no" title="statement not covered" >t</span>his.containerClassName="inkAnnotation";<span class="cstat-no" title="statement not covered" >t</span>his.svgElementName="svg:polyline";<span class="cstat-no" title="statement not covered" >t</span>his.annotationEditorType=n.AnnotationEditorType.INK}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add(this.containerClassName);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:s}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>n=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,s,!0);<span class="cstat-no" title="statement not covered" ></span>for(const e of t.inkLists){let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const n of e){const e=<span class="cstat-no" title="statement not covered" >n.x-t.rect[0],</span>i=<span class="cstat-no" title="statement not covered" >t.rect[3]-n.y;<span class="cstat-no" title="statement not covered" ></span>s.push(`${e},${i}`)}<span class="cstat-no" title="statement not covered" ></span>s</span>=s.join(" ");c</span>onst i=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement(this.svgElementName);<span class="cstat-no" title="statement not covered" ></span>this.#We.push(i);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("points",s);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("stroke-width",t.borderStyle.width||1);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup(i,t);<span class="cstat-no" title="statement not covered" >n</span>.append(i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#We}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}<span class="cstat-no" title="statement not covered" >e.InkAnnotationElement=InkAnnotationElement;c</span>lass HighlightAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >i</span>f(this.quadrilaterals)<span class="cstat-no" title="statement not covered" >return this._renderQuadrilaterals("highlightAnnotation");<span class="cstat-no" title="statement not covered" >t</span></span>his.container.classList.add("highlightAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class UnderlineAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >i</span>f(this.quadrilaterals)<span class="cstat-no" title="statement not covered" >return this._renderQuadrilaterals("underlineAnnotation");<span class="cstat-no" title="statement not covered" >t</span></span>his.container.classList.add("underlineAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class SquigglyAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >i</span>f(this.quadrilaterals)<span class="cstat-no" title="statement not covered" >return this._renderQuadrilaterals("squigglyAnnotation");<span class="cstat-no" title="statement not covered" >t</span></span>his.container.classList.add("squigglyAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class StrikeOutAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >i</span>f(this.quadrilaterals)<span class="cstat-no" title="statement not covered" >return this._renderQuadrilaterals("strikeoutAnnotation");<span class="cstat-no" title="statement not covered" >t</span></span>his.container.classList.add("strikeoutAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class StampAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("stampAnnotation");<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class FileAttachmentAnnotationElement extends AnnotationElement{#Ge=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!0});c</span>onst{filename:e,content:s}=<span class="cstat-no" title="statement not covered" >this.data.file;<span class="cstat-no" title="statement not covered" ></span>this.filename=(0,i.getFilenameFromUrl)(e,!0);<span class="cstat-no" title="statement not covered" >t</span>his.content=s;<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("fileattachmentannotation",{source:this,filename:e,content:s})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("fileAttachmentAnnotation");l</span>et t;<span class="cstat-no" title="statement not covered" >if(this.data.hasAppearance)<span class="cstat-no" title="statement not covered" >t=document.createElement("div");e</span>lse{<span class="cstat-no" title="statement not covered" >t=document.createElement("img");<span class="cstat-no" title="statement not covered" >t</span>.src=`${this.imageResourcesPath}annotation-${/paperclip/i.test(this.data.name)?"paperclip":"pushpin"}.svg`}<span class="cstat-no" title="statement not covered" ></span>t</span>.classList.add("popupTriggerArea");<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("dblclick",this._download.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his.#Ge=t;<span class="cstat-no" title="statement not covered" >!</span>this.data.popupRef&amp;&amp;(this.data.titleObj?.str||this.data.contentsObj?.str||this.data.richText)&amp;&amp;this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.append(t);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#Ge}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}<span class="fstat-no" title="function not covered" ></span>_d</span>ownload(){<span class="cstat-no" title="statement not covered" >this.downloadManager?.openOrDownloadData(this.container,this.content,this.filename)}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationLayer=class AnnotationLayer{#Gt=<span class="cstat-no" title="statement not covered" >null;</span>#ze=<span class="cstat-no" title="statement not covered" >null;</span>#Ve=<span class="cstat-no" title="statement not covered" >new Map;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({div:t,accessibilityManager:e,annotationCanvasMap:n,l10n:i,page:a,viewport:r}){<span class="cstat-no" title="statement not covered" >this.div=t;<span class="cstat-no" title="statement not covered" >t</span>his.#Gt=e;<span class="cstat-no" title="statement not covered" >t</span>his.#ze=n;<span class="cstat-no" title="statement not covered" >t</span>his.l10n=i;<span class="cstat-no" title="statement not covered" >t</span>his.page=a;<span class="cstat-no" title="statement not covered" >t</span>his.viewport=r;<span class="cstat-no" title="statement not covered" >t</span>his.zIndex=0;c</span>onst{NullL10n:o}=<span class="cstat-no" title="statement not covered" >s(32);<span class="cstat-no" title="statement not covered" ></span>this.l10n||=o}</span>#Xe(t,e){const s=<span class="cstat-no" title="statement not covered" >t.firstChild||t;<span class="cstat-no" title="statement not covered" ></span>s.id=`${i.AnnotationPrefix}${e}`;<span class="cstat-no" title="statement not covered" >t</span>his.div.append(t);<span class="cstat-no" title="statement not covered" >t</span>his.#Gt?.moveElementInDOM(this.div,t,s,!1)}<span class="fstat-no" title="function not covered" ></span>as</span>ync render(t){const{annotations:e}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>(0,i.setLayerDimensions)(s,this.viewport);c</span>onst r=<span class="cstat-no" title="statement not covered" >new Map,</span>o=<span class="cstat-no" title="statement not covered" >{data:null,layer:s,linkService:t.linkService,downloadManager:t.downloadManager,imageResourcesPath:t.imageResourcesPath||"",renderForms:!1!==t.renderForms,svgFactory:new i.DOMSVGFactory,annotationStorage:t.annotationStorage||new a.AnnotationStorage,enableScripting:!0===t.enableScripting,hasJSActions:t.hasJSActions,fieldObjects:t.fieldObjects,parent:this,elements:null};<span class="cstat-no" title="statement not covered" ></span>for(const t of e){<span class="cstat-no" title="statement not covered" >if(t.noHTML)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.annotationType===n.AnnotationType.POPUP;<span class="cstat-no" title="statement not covered" ></span>if(e){const e=<span class="cstat-no" title="statement not covered" >r.get(t.id);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >o</span></span>.elements=e}</span>else{const{width:e,height:s}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect);<span class="cstat-no" title="statement not covered" ></span>if(e&lt;=0||s&lt;=0)<span class="cstat-no" title="statement not covered" >continue}<span class="cstat-no" title="statement not covered" ></span></span>o</span>.data=t;c</span>onst s=<span class="cstat-no" title="statement not covered" >AnnotationElementFactory.create(o);<span class="cstat-no" title="statement not covered" ></span>if(!s.isRenderable)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e&amp;&amp;t.popupRef){const e=<span class="cstat-no" title="statement not covered" >r.get(t.popupRef);<span class="cstat-no" title="statement not covered" ></span>e?e.push(s):r.set(t.popupRef,[s])}<span class="cstat-no" title="statement not covered" ></span>s</span>.annotationEditorType&gt;0&amp;&amp;this.#Ve.set(s.data.id,s);c</span>onst i=<span class="cstat-no" title="statement not covered" >s.render();<span class="cstat-no" title="statement not covered" ></span>t.hidden&amp;&amp;(i.style.visibility="hidden");<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(i))<span class="cstat-no" title="statement not covered" >for(const e of i)<span class="cstat-no" title="statement not covered" >this.#Xe(e,t.id);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.#Xe(i,t.id)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.#$e();<span class="cstat-no" title="statement not covered" >a</span>wait this.l10n.translate(s)}<span class="fstat-no" title="function not covered" ></span>up</span>date({viewport:t}){const e=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>this.viewport=t;<span class="cstat-no" title="statement not covered" >(</span>0,i.setLayerDimensions)(e,{rotation:t.rotation});<span class="cstat-no" title="statement not covered" >t</span>his.#$e();<span class="cstat-no" title="statement not covered" >e</span>.hidden=!1}</span>#$e(){<span class="cstat-no" title="statement not covered" >if(!this.#ze)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>for(const[e,s]of this.#ze){const n=<span class="cstat-no" title="statement not covered" >t.querySelector(`[data-annotation-id="${e}"]`);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst{firstChild:i}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>i?"CANVAS"===i.nodeName?i.replaceWith(s):i.before(s):n.append(s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#ze.clear()}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditableAnnotations(){<span class="cstat-no" title="statement not covered" >return Array.from(this.#Ve.values())}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditableAnnotation(t){<span class="cstat-no" title="statement not covered" >return this.#Ve.get(t)}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.ColorConverters=void 0;f</span>unction <span class="fstat-no" title="function not covered" >makeColorComp(</span>t){<span class="cstat-no" title="statement not covered" >return Math.floor(255*Math.max(0,Math.min(1,t))).toString(16).padStart(2,"0")}<span class="cstat-no" title="statement not covered" ></span>e.ColorConverters=class ColorConverters{<span class="fstat-no" title="function not covered" >st</span>atic CMYK_G([t,e,s,n]){<span class="cstat-no" title="statement not covered" >return["G",1-Math.min(1,.3*t+.59*s+.11*e+n)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_CMYK([t]){<span class="cstat-no" title="statement not covered" >return["CMYK",0,0,0,1-t]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_RGB([t]){<span class="cstat-no" title="statement not covered" >return["RGB",t,t,t]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_HTML([t]){const e=<span class="cstat-no" title="statement not covered" >makeColorComp(t);<span class="cstat-no" title="statement not covered" ></span>return`#${e}${e}${e}`}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_G([t,e,s]){<span class="cstat-no" title="statement not covered" >return["G",.3*t+.59*e+.11*s]}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_HTML([t,e,s]){<span class="cstat-no" title="statement not covered" >return`#${makeColorComp(t)}${makeColorComp(e)}${makeColorComp(s)}`}<span class="fstat-no" title="function not covered" ></span>st</span>atic T_HTML(){<span class="cstat-no" title="statement not covered" >return"#00000000"}<span class="fstat-no" title="function not covered" ></span>st</span>atic CMYK_RGB([t,e,s,n]){<span class="cstat-no" title="statement not covered" >return["RGB",1-Math.min(1,t+n),1-Math.min(1,s+n),1-Math.min(1,e+n)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic CMYK_HTML(t){const e=<span class="cstat-no" title="statement not covered" >this.CMYK_RGB(t).slice(1);<span class="cstat-no" title="statement not covered" ></span>return this.RGB_HTML(e)}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_CMYK([t,e,s]){const n=<span class="cstat-no" title="statement not covered" >1-t,</span>i=<span class="cstat-no" title="statement not covered" >1-e,</span>a=<span class="cstat-no" title="statement not covered" >1-s;<span class="cstat-no" title="statement not covered" ></span>return["CMYK",n,i,a,Math.min(n,i,a)]}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.XfaLayer=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(19);<span class="cstat-no" title="statement not covered" ></span>e.XfaLayer=class XfaLayer{<span class="fstat-no" title="function not covered" >st</span>atic setupStorage(t,e,s,n,i){const a=<span class="cstat-no" title="statement not covered" >n.getValue(e,{value:null});<span class="cstat-no" title="statement not covered" ></span>switch(s.name){case"textarea":<span class="cstat-no" title="statement not covered" >null!==a.value&amp;&amp;(t.textContent=a.value);<span class="cstat-no" title="statement not covered" >i</span>f("print"===i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.setValue(e,{value:t.target.value})}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"input":<span class="cstat-no" title="statement not covered" >if("radio"===s.attributes.type||"checkbox"===s.attributes.type){<span class="cstat-no" title="statement not covered" >a.value===s.attributes.xfaOn?t.setAttribute("checked",!0):a.value===s.attributes.xfaOff&amp;&amp;t.removeAttribute("checked");<span class="cstat-no" title="statement not covered" >i</span>f("print"===i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.addEventListener("change",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.setValue(e,{value:t.target.checked?t.target.getAttribute("xfaOn"):t.target.getAttribute("xfaOff")})}</span>))}</span>else{<span class="cstat-no" title="statement not covered" >null!==a.value&amp;&amp;t.setAttribute("value",a.value);<span class="cstat-no" title="statement not covered" >i</span>f("print"===i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.setValue(e,{value:t.target.value})}</span>))}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"select":<span class="cstat-no" title="statement not covered" >if(null!==a.value)<span class="cstat-no" title="statement not covered" >for(const t of s.children)<span class="cstat-no" title="statement not covered" >t.attributes.value===a.value&amp;&amp;(t.attributes.selected=!0);<span class="cstat-no" title="statement not covered" >t</span></span></span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >t.target.options,</span>i=<span class="cstat-no" title="statement not covered" >-1===s.selectedIndex?"":s[s.selectedIndex].value;<span class="cstat-no" title="statement not covered" ></span>n.setValue(e,{value:i})}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic setAttributes({html:t,element:e,storage:s=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>intent:n,linkService:i}){const{attributes:a}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >t instanceof HTMLAnchorElement;<span class="cstat-no" title="statement not covered" ></span>"radio"===a.type&amp;&amp;(a.name=`${a.name}-${n}`);<span class="cstat-no" title="statement not covered" >f</span>or(const[e,s]of Object.entries(a))<span class="cstat-no" title="statement not covered" >if(null!=s)<span class="cstat-no" title="statement not covered" >switch(e){case"class":<span class="cstat-no" title="statement not covered" >s.length&amp;&amp;t.setAttribute(e,s.join(" "));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"dataId":<span class="cstat-no" title="statement not covered" >break;c</span>ase"id":<span class="cstat-no" title="statement not covered" >t.setAttribute("data-element-id",s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"style":<span class="cstat-no" title="statement not covered" >Object.assign(t.style,s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"textContent":<span class="cstat-no" title="statement not covered" >t.textContent=s;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(!r||"href"!==e&amp;&amp;"newWindow"!==e)&amp;&amp;t.setAttribute(e,s)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>&amp;&amp;i.addLinkAttributes(t,a.href,a.newWindow);<span class="cstat-no" title="statement not covered" >s</span>&amp;&amp;a.dataId&amp;&amp;this.setupStorage(t,a.dataId,e,s)}<span class="fstat-no" title="function not covered" ></span>st</span>atic render(t){const e=<span class="cstat-no" title="statement not covered" >t.annotationStorage,</span>s=<span class="cstat-no" title="statement not covered" >t.linkService,</span>i=<span class="cstat-no" title="statement not covered" >t.xfaHtml,</span>a=<span class="cstat-no" title="statement not covered" >t.intent||"display",</span>r=<span class="cstat-no" title="statement not covered" >document.createElement(i.name);<span class="cstat-no" title="statement not covered" ></span>i.attributes&amp;&amp;this.setAttributes({html:r,element:i,intent:a,linkService:s});c</span>onst o=<span class="cstat-no" title="statement not covered" >[[i,-1,r]],</span>l=<span class="cstat-no" title="statement not covered" >t.div;<span class="cstat-no" title="statement not covered" ></span>l.append(r);<span class="cstat-no" title="statement not covered" >i</span>f(t.viewport){const e=<span class="cstat-no" title="statement not covered" >`matrix(${t.viewport.transform.join(",")})`;<span class="cstat-no" title="statement not covered" ></span>l.style.transform=e}<span class="cstat-no" title="statement not covered" ></span>"</span>richText"!==a&amp;&amp;l.setAttribute("class","xfaLayer xfaFont");c</span>onst c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(;o.length&gt;0;){const[t,i,r]=<span class="cstat-no" title="statement not covered" >o.at(-1);<span class="cstat-no" title="statement not covered" ></span>if(i+1===t.children.length){<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >t.children[++o.at(-1)[1]];<span class="cstat-no" title="statement not covered" ></span>if(null===l)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst{name:h}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>if("#text"===h){const t=<span class="cstat-no" title="statement not covered" >document.createTextNode(l.value);<span class="cstat-no" title="statement not covered" ></span>c.push(t);<span class="cstat-no" title="statement not covered" >r</span>.append(t);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et d;<span class="cstat-no" title="statement not covered" >d=l?.attributes?.xmlns?document.createElementNS(l.attributes.xmlns,h):document.createElement(h);<span class="cstat-no" title="statement not covered" >r</span>.append(d);<span class="cstat-no" title="statement not covered" >l</span>.attributes&amp;&amp;this.setAttributes({html:d,element:l,storage:e,intent:a,linkService:s});<span class="cstat-no" title="statement not covered" >i</span>f(l.children&amp;&amp;l.children.length&gt;0)<span class="cstat-no" title="statement not covered" >o.push([l,-1,d]);e</span>lse <span class="cstat-no" title="statement not covered" >if(l.value){const t=<span class="cstat-no" title="statement not covered" >document.createTextNode(l.value);<span class="cstat-no" title="statement not covered" ></span>n.XfaText.shouldBuildText(h)&amp;&amp;c.push(t);<span class="cstat-no" title="statement not covered" >d</span>.append(t)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(const t of l.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))<span class="cstat-no" title="statement not covered" >t.setAttribute("readOnly",!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{textDivs:c}}<span class="fstat-no" title="function not covered" ></span>st</span>atic update(t){const e=<span class="cstat-no" title="statement not covered" >`matrix(${t.viewport.transform.join(",")})`;<span class="cstat-no" title="statement not covered" ></span>t.div.style.transform=e;<span class="cstat-no" title="statement not covered" >t</span>.div.hidden=!1}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.NullL10n=void 0;<span class="cstat-no" title="statement not covered" >e</span>.getL10nFallback=getL10nFallback;c</span>onst s=<span class="cstat-no" title="statement not covered" >{of_pages:"of {{pagesCount}}",page_of_pages:"({{pageNumber}} of {{pagesCount}})",document_properties_kb:"{{size_kb}} KB ({{size_b}} bytes)",document_properties_mb:"{{size_mb}} MB ({{size_b}} bytes)",document_properties_date_string:"{{date}}, {{time}}",document_properties_page_size_unit_inches:"in",document_properties_page_size_unit_millimeters:"mm",document_properties_page_size_orientation_portrait:"portrait",document_properties_page_size_orientation_landscape:"landscape",document_properties_page_size_name_a3:"A3",document_properties_page_size_name_a4:"A4",document_properties_page_size_name_letter:"Letter",document_properties_page_size_name_legal:"Legal",document_properties_page_size_dimension_string:"{{width}} × {{height}} {{unit}} ({{orientation}})",document_properties_page_size_dimension_name_string:"{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",document_properties_linearized_yes:"Yes",document_properties_linearized_no:"No",additional_layers:"Additional Layers",page_landmark:"Page {{page}}",thumb_page_title:"Page {{page}}",thumb_page_canvas:"Thumbnail of Page {{page}}",find_reached_top:"Reached top of document, continued from bottom",find_reached_bottom:"Reached end of document, continued from top","find_match_count[one]":"{{current}} of {{total}} match","find_match_count[other]":"{{current}} of {{total}} matches","find_match_count_limit[one]":"More than {{limit}} match","find_match_count_limit[other]":"More than {{limit}} matches",find_not_found:"Phrase not found",page_scale_width:"Page Width",page_scale_fit:"Page Fit",page_scale_auto:"Automatic Zoom",page_scale_actual:"Actual Size",page_scale_percent:"{{scale}}%",loading_error:"An error occurred while loading the PDF.",invalid_file_error:"Invalid or corrupted PDF file.",missing_file_error:"Missing PDF file.",unexpected_response_error:"Unexpected server response.",rendering_error:"An error occurred while rendering the page.",annotation_date_string:"{{date}}, {{time}}",printing_not_supported:"Warning: Printing is not fully supported by this browser.",printing_not_ready:"Warning: The PDF is not fully loaded for printing.",web_fonts_disabled:"Web fonts are disabled: unable to use embedded PDF fonts.",free_text2_default_content:"Start typing…",editor_free_text2_aria_label:"Text Editor",editor_ink2_aria_label:"Draw Editor",editor_ink_canvas_aria_label:"User-created image",print_progress_percent:"{{progress}}%"};</span>function <span class="fstat-no" title="function not covered" >getL10nFallback(</span>t,e){<span class="cstat-no" title="statement not covered" >switch(t){case"find_match_count":<span class="cstat-no" title="statement not covered" >t=`find_match_count[${1===e.total?"one":"other"}]`;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"find_match_count_limit":<span class="cstat-no" title="statement not covered" >t=`find_match_count_limit[${1===e.limit?"one":"other"}]`}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s[t]||""}</span>const n=<span class="cstat-no" title="statement not covered" >{getLanguage:<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;<span class="cstat-no" title="statement not covered" >"en-us",</span>getDirection:<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;<span class="cstat-no" title="statement not covered" >"ltr",</span>get:<span class="fstat-no" title="function not covered" >as</span>ync(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >getL10nFallback(t,e))</span>=&gt;<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >formatL10nValue(</span>t,e){<span class="cstat-no" title="statement not covered" >return e?t.replaceAll(/\{\{\s*(\w+)\s*\}\}/g,(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >s in e?e[s]:"{{"+s+"}}")</span>):t}</span>(s,e),<span class="fstat-no" title="function not covered" ></span>as</span>ync translate(t){}};<span class="cstat-no" title="statement not covered" ></span>e.NullL10n=n}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.InkEditor=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(1),</span>i=<span class="cstat-no" title="statement not covered" >s(4),</span>a=<span class="cstat-no" title="statement not covered" >s(29),</span>r=<span class="cstat-no" title="statement not covered" >s(5);</span>const o=<span class="cstat-no" title="statement not covered" >16;</span>class InkEditor extends i.AnnotationEditor{#Ke=<span class="cstat-no" title="statement not covered" >0;</span>#Ye=<span class="cstat-no" title="statement not covered" >0;</span>#Je=<span class="cstat-no" title="statement not covered" >0;</span>#Qe=<span class="cstat-no" title="statement not covered" >this.canvasContextMenu.bind(this);</span>#Ze=<span class="cstat-no" title="statement not covered" >this.canvasPointermove.bind(this);</span>#ts=<span class="cstat-no" title="statement not covered" >this.canvasPointerleave.bind(this);</span>#es=<span class="cstat-no" title="statement not covered" >this.canvasPointerup.bind(this);</span>#ss=<span class="cstat-no" title="statement not covered" >this.canvasPointerdown.bind(this);</span>#ns=<span class="cstat-no" title="statement not covered" >new Path2D;</span>#is=<span class="cstat-no" title="statement not covered" >!1;</span>#as=<span class="cstat-no" title="statement not covered" >!1;</span>#rs=<span class="cstat-no" title="statement not covered" >!1;</span>#os=<span class="cstat-no" title="statement not covered" >null;</span>#ls=<span class="cstat-no" title="statement not covered" >0;</span>#cs=<span class="cstat-no" title="statement not covered" >0;</span>#hs=<span class="cstat-no" title="statement not covered" >null;</span>static _defaultColor=<span class="cstat-no" title="statement not covered" >null;</span>static _defaultOpacity=<span class="cstat-no" title="statement not covered" >1;</span>static _defaultThickness=<span class="cstat-no" title="statement not covered" >1;</span>static _l10nPromise;static _type=<span class="cstat-no" title="statement not covered" >"ink";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super({...t,name:"inkEditor"});<span class="cstat-no" title="statement not covered" >t</span>his.color=t.color||null;<span class="cstat-no" title="statement not covered" >t</span>his.thickness=t.thickness||null;<span class="cstat-no" title="statement not covered" >t</span>his.opacity=t.opacity||null;<span class="cstat-no" title="statement not covered" >t</span>his.paths=[];<span class="cstat-no" title="statement not covered" >t</span>his.bezierPath2D=[];<span class="cstat-no" title="statement not covered" >t</span>his.allRawPaths=[];<span class="cstat-no" title="statement not covered" >t</span>his.currentPath=[];<span class="cstat-no" title="statement not covered" >t</span>his.scaleFactor=1;<span class="cstat-no" title="statement not covered" >t</span>his.translationX=this.translationY=0;<span class="cstat-no" title="statement not covered" >t</span>his.x=0;<span class="cstat-no" title="statement not covered" >t</span>his.y=0}<span class="fstat-no" title="function not covered" ></span>st</span>atic initialize(t){<span class="cstat-no" title="statement not covered" >this._l10nPromise=new Map(["editor_ink_canvas_aria_label","editor_ink2_aria_label"].map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >[e,t.get(e)])</span>))}<span class="fstat-no" title="function not covered" ></span>st</span>atic updateDefaultParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case n.AnnotationEditorParamsType.INK_THICKNESS:<span class="cstat-no" title="statement not covered" >InkEditor._defaultThickness=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationEditorParamsType.INK_COLOR:<span class="cstat-no" title="statement not covered" >InkEditor._defaultColor=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationEditorParamsType.INK_OPACITY:<span class="cstat-no" title="statement not covered" >InkEditor._defaultOpacity=e/100}</span>}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case n.AnnotationEditorParamsType.INK_THICKNESS:<span class="cstat-no" title="statement not covered" >this.#ds(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationEditorParamsType.INK_COLOR:<span class="cstat-no" title="statement not covered" >this.#ge(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.AnnotationEditorParamsType.INK_OPACITY:<span class="cstat-no" title="statement not covered" >this.#us(e)}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic get defaultPropertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[n.AnnotationEditorParamsType.INK_THICKNESS,InkEditor._defaultThickness],[n.AnnotationEditorParamsType.INK_COLOR,InkEditor._defaultColor||i.AnnotationEditor._defaultLineColor],[n.AnnotationEditorParamsType.INK_OPACITY,Math.round(100*InkEditor._defaultOpacity)]]}<span class="fstat-no" title="function not covered" ></span>ge</span>t propertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[n.AnnotationEditorParamsType.INK_THICKNESS,this.thickness||InkEditor._defaultThickness],[n.AnnotationEditorParamsType.INK_COLOR,this.color||InkEditor._defaultColor||i.AnnotationEditor._defaultLineColor],[n.AnnotationEditorParamsType.INK_OPACITY,Math.round(100*(this.opacity??InkEditor._defaultOpacity))]]}</span>#ds(t){const e=<span class="cstat-no" title="statement not covered" >this.thickness;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.thickness=t;<span class="cstat-no" title="statement not covered" >t</span>his.#ps()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.thickness=e;<span class="cstat-no" title="statement not covered" >t</span>his.#ps()}</span>,mustExec:!0,type:n.AnnotationEditorParamsType.INK_THICKNESS,overwriteIfSameType:!0,keepUndo:!0})}</span>#ge(t){const e=<span class="cstat-no" title="statement not covered" >this.color;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.color=t;<span class="cstat-no" title="statement not covered" >t</span>his.#gs()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.color=e;<span class="cstat-no" title="statement not covered" >t</span>his.#gs()}</span>,mustExec:!0,type:n.AnnotationEditorParamsType.INK_COLOR,overwriteIfSameType:!0,keepUndo:!0})}</span>#us(t){<span class="cstat-no" title="statement not covered" >t/=100;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.opacity;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.opacity=t;<span class="cstat-no" title="statement not covered" >t</span>his.#gs()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.opacity=e;<span class="cstat-no" title="statement not covered" >t</span>his.#gs()}</span>,mustExec:!0,type:n.AnnotationEditorParamsType.INK_OPACITY,overwriteIfSameType:!0,keepUndo:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >super.rebuild();<span class="cstat-no" title="statement not covered" >i</span>f(null!==this.div){<span class="cstat-no" title="statement not covered" >if(!this.canvas){<span class="cstat-no" title="statement not covered" >this.#fs();<span class="cstat-no" title="statement not covered" >t</span>his.#ms()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.isAttachedToDOM){<span class="cstat-no" title="statement not covered" >this.parent.add(this);<span class="cstat-no" title="statement not covered" >t</span>his.#bs()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#ps()}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >if(null!==this.canvas){<span class="cstat-no" title="statement not covered" >this.isEmpty()||this.commit();<span class="cstat-no" title="statement not covered" >t</span>his.canvas.width=this.canvas.height=0;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.remove();<span class="cstat-no" title="statement not covered" >t</span>his.canvas=null;<span class="cstat-no" title="statement not covered" >t</span>his.#os.disconnect();<span class="cstat-no" title="statement not covered" >t</span>his.#os=null;<span class="cstat-no" title="statement not covered" >s</span>uper.remove()}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tParent(t){<span class="cstat-no" title="statement not covered" >!this.parent&amp;&amp;t?this._uiManager.removeShouldRescale(this):this.parent&amp;&amp;null===t&amp;&amp;this._uiManager.addShouldRescale(this);<span class="cstat-no" title="statement not covered" >s</span>uper.setParent(t)}<span class="fstat-no" title="function not covered" ></span>on</span>ScaleChanging(){const[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions,</span>s=<span class="cstat-no" title="statement not covered" >this.width*t,</span>n=<span class="cstat-no" title="statement not covered" >this.height*e;<span class="cstat-no" title="statement not covered" ></span>this.setDimensions(s,n)}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditMode(){<span class="cstat-no" title="statement not covered" >if(!this.#is&amp;&amp;null!==this.canvas){<span class="cstat-no" title="statement not covered" >super.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.div.draggable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerdown",this.#ss)}</span>}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditMode(){<span class="cstat-no" title="statement not covered" >if(this.isInEditMode()&amp;&amp;null!==this.canvas){<span class="cstat-no" title="statement not covered" >super.disableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.div.draggable=!this.isEmpty();<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.remove("editing");<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointerdown",this.#ss)}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>ceAdded(){<span class="cstat-no" title="statement not covered" >this.div.draggable=!this.isEmpty()}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return 0===this.paths.length||1===this.paths.length&amp;&amp;0===this.paths[0].length}</span>#As(){const{parentRotation:t,parentDimensions:[e,s]}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>switch(t){case 90:<span class="cstat-no" title="statement not covered" >return[0,s,s,e];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[e,s,e,s];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[e,0,s,e];d</span>efault:<span class="cstat-no" title="statement not covered" >return[0,0,e,s]}</span>}</span>#_s(){const{ctx:t,color:e,opacity:s,thickness:n,parentScale:i,scaleFactor:a}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.lineWidth=n*i/a;<span class="cstat-no" title="statement not covered" >t</span>.lineCap="round";<span class="cstat-no" title="statement not covered" >t</span>.lineJoin="round";<span class="cstat-no" title="statement not covered" >t</span>.miterLimit=10;<span class="cstat-no" title="statement not covered" >t</span>.strokeStyle=`${e}${(0,r.opacityToHex)(s)}`}</span>#ys(t,e){<span class="cstat-no" title="statement not covered" >this.canvas.addEventListener("contextmenu",this.#Qe);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerleave",this.#ts);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointermove",this.#Ze);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerup",this.#es);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointerdown",this.#ss);<span class="cstat-no" title="statement not covered" >t</span>his.isEditing=!0;<span class="cstat-no" title="statement not covered" >i</span>f(!this.#rs){<span class="cstat-no" title="statement not covered" >this.#rs=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#bs();<span class="cstat-no" title="statement not covered" >t</span>his.thickness||=InkEditor._defaultThickness;<span class="cstat-no" title="statement not covered" >t</span>his.color||=InkEditor._defaultColor||i.AnnotationEditor._defaultLineColor;<span class="cstat-no" title="statement not covered" >t</span>his.opacity??=InkEditor._defaultOpacity}<span class="cstat-no" title="statement not covered" ></span>t</span>his.currentPath.push([t,e]);<span class="cstat-no" title="statement not covered" >t</span>his.#as=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#_s();<span class="cstat-no" title="statement not covered" >t</span>his.#hs=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#vs();<span class="cstat-no" title="statement not covered" >t</span>his.#hs&amp;&amp;window.requestAnimationFrame(this.#hs)}</span>;<span class="cstat-no" title="statement not covered" >w</span>indow.requestAnimationFrame(this.#hs)}</span>#Ss(t,e){const[s,n]=<span class="cstat-no" title="statement not covered" >this.currentPath.at(-1);<span class="cstat-no" title="statement not covered" ></span>if(this.currentPath.length&gt;1&amp;&amp;t===s&amp;&amp;e===n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.currentPath;</span>let a=<span class="cstat-no" title="statement not covered" >this.#ns;<span class="cstat-no" title="statement not covered" ></span>i.push([t,e]);<span class="cstat-no" title="statement not covered" >t</span>his.#as=!0;<span class="cstat-no" title="statement not covered" >i</span>f(i.length&lt;=2){<span class="cstat-no" title="statement not covered" >a.moveTo(...i[0]);<span class="cstat-no" title="statement not covered" >a</span>.lineTo(t,e)}</span>else{<span class="cstat-no" title="statement not covered" >if(3===i.length){<span class="cstat-no" title="statement not covered" >this.#ns=a=new Path2D;<span class="cstat-no" title="statement not covered" >a</span>.moveTo(...i[0])}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Es(a,...i.at(-3),...i.at(-2),t,e)}</span>}</span>#xs(){<span class="cstat-no" title="statement not covered" >if(0===this.currentPath.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.currentPath.at(-1);<span class="cstat-no" title="statement not covered" ></span>this.#ns.lineTo(...t)}</span>#Cs(t,e){<span class="cstat-no" title="statement not covered" >this.#hs=null;<span class="cstat-no" title="statement not covered" >t</span>=Math.min(Math.max(t,0),this.canvas.width);<span class="cstat-no" title="statement not covered" >e</span>=Math.min(Math.max(e,0),this.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.#Ss(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.#xs();l</span>et s;<span class="cstat-no" title="statement not covered" >if(1!==this.currentPath.length)<span class="cstat-no" title="statement not covered" >s=this.#ws();e</span>lse{const n=<span class="cstat-no" title="statement not covered" >[t,e];<span class="cstat-no" title="statement not covered" ></span>s=[[n,n.slice(),n.slice(),n]]}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >this.#ns,</span>i=<span class="cstat-no" title="statement not covered" >this.currentPath;<span class="cstat-no" title="statement not covered" ></span>this.currentPath=[];<span class="cstat-no" title="statement not covered" >t</span>his.#ns=new Path2D;<span class="cstat-no" title="statement not covered" >t</span>his.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.allRawPaths.push(i);<span class="cstat-no" title="statement not covered" >t</span>his.paths.push(s);<span class="cstat-no" title="statement not covered" >t</span>his.bezierPath2D.push(n);<span class="cstat-no" title="statement not covered" >t</span>his.rebuild()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.allRawPaths.pop();<span class="cstat-no" title="statement not covered" >t</span>his.paths.pop();<span class="cstat-no" title="statement not covered" >t</span>his.bezierPath2D.pop();<span class="cstat-no" title="statement not covered" >i</span>f(0===this.paths.length)<span class="cstat-no" title="statement not covered" >this.remove();e</span>lse{<span class="cstat-no" title="statement not covered" >if(!this.canvas){<span class="cstat-no" title="statement not covered" >this.#fs();<span class="cstat-no" title="statement not covered" >t</span>his.#ms()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#ps()}</span>}</span>,mustExec:!0})}</span>#vs(){<span class="cstat-no" title="statement not covered" >if(!this.#as)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#as=!1;c</span>onst t=<span class="cstat-no" title="statement not covered" >Math.ceil(this.thickness*this.parentScale),</span>e=<span class="cstat-no" title="statement not covered" >this.currentPath.slice(-3),</span>s=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[0])</span>),</span>n=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[1])</span>),</span>{ctx:i}=(<span class="cstat-no" title="statement not covered" >Math.min(...s),Math.max(...s),Math.min(...n),Math.max(...n),this)</span>;<span class="cstat-no" title="statement not covered" >i.save();<span class="cstat-no" title="statement not covered" >i</span>.clearRect(0,0,this.canvas.width,this.canvas.height);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.bezierPath2D)<span class="cstat-no" title="statement not covered" >i.stroke(t);<span class="cstat-no" title="statement not covered" >i</span></span>.stroke(this.#ns);<span class="cstat-no" title="statement not covered" >i</span>.restore()}</span>#Es(t,e,s,n,i,a,r){const o=<span class="cstat-no" title="statement not covered" >(e+n)/2,</span>l=<span class="cstat-no" title="statement not covered" >(s+i)/2,</span>c=<span class="cstat-no" title="statement not covered" >(n+a)/2,</span>h=<span class="cstat-no" title="statement not covered" >(i+r)/2;<span class="cstat-no" title="statement not covered" ></span>t.bezierCurveTo(o+2*(n-o)/3,l+2*(i-l)/3,c+2*(n-c)/3,h+2*(i-h)/3,c,h)}</span>#ws(){const t=<span class="cstat-no" title="statement not covered" >this.currentPath;<span class="cstat-no" title="statement not covered" ></span>if(t.length&lt;=2)<span class="cstat-no" title="statement not covered" >return[[t[0],t[0],t.at(-1),t.at(-1)]];c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];</span>let s,[n,i]=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>for(s=1;s&lt;t.length-2;s++){const[a,r]=<span class="cstat-no" title="statement not covered" >t[s],</span>[o,l]=<span class="cstat-no" title="statement not covered" >t[s+1],</span>c=<span class="cstat-no" title="statement not covered" >(a+o)/2,</span>h=<span class="cstat-no" title="statement not covered" >(r+l)/2,</span>d=<span class="cstat-no" title="statement not covered" >[n+2*(a-n)/3,i+2*(r-i)/3],</span>u=<span class="cstat-no" title="statement not covered" >[c+2*(a-c)/3,h+2*(r-h)/3];<span class="cstat-no" title="statement not covered" ></span>e.push([[n,i],d,u,[c,h]]);<span class="cstat-no" title="statement not covered" >[</span>n,i]=[c,h]}</span>c</span>onst[a,r]=<span class="cstat-no" title="statement not covered" >t[s],</span>[o,l]=<span class="cstat-no" title="statement not covered" >t[s+1],</span>c=<span class="cstat-no" title="statement not covered" >[n+2*(a-n)/3,i+2*(r-i)/3],</span>h=<span class="cstat-no" title="statement not covered" >[o+2*(a-o)/3,l+2*(r-l)/3];<span class="cstat-no" title="statement not covered" ></span>e.push([[n,i],c,h,[o,l]]);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>#gs(){<span class="cstat-no" title="statement not covered" >if(this.isEmpty()){<span class="cstat-no" title="statement not covered" >this.#Ts();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#_s();c</span>onst{canvas:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >e</span>.clearRect(0,0,t.width,t.height);<span class="cstat-no" title="statement not covered" >t</span>his.#Ts();<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.bezierPath2D)<span class="cstat-no" title="statement not covered" >e.stroke(t)}<span class="fstat-no" title="function not covered" ></span></span>co</span>mmit(){<span class="cstat-no" title="statement not covered" >if(!this.#is){<span class="cstat-no" title="statement not covered" >super.commit();<span class="cstat-no" title="statement not covered" >t</span>his.isEditing=!1;<span class="cstat-no" title="statement not covered" >t</span>his.disableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.setInForeground();<span class="cstat-no" title="statement not covered" >t</span>his.#is=!0;<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.add("disabled");<span class="cstat-no" title="statement not covered" >t</span>his.#ps(!0);<span class="cstat-no" title="statement not covered" >t</span>his.parent.addInkEditorIfNeeded(!0);<span class="cstat-no" title="statement not covered" >t</span>his.parent.moveEditorInDOM(this);<span class="cstat-no" title="statement not covered" >t</span>his.div.focus({preventScroll:!0})}</span>}<span class="fstat-no" title="function not covered" ></span>fo</span>cusin(t){<span class="cstat-no" title="statement not covered" >super.focusin(t);<span class="cstat-no" title="statement not covered" >t</span>his.enableEditMode()}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointerdown(t){<span class="cstat-no" title="statement not covered" >if(0===t.button&amp;&amp;this.isInEditMode()&amp;&amp;!this.#is){<span class="cstat-no" title="statement not covered" >this.setInForeground();<span class="cstat-no" title="statement not covered" >t</span>.preventDefault();<span class="cstat-no" title="statement not covered" >"</span>mouse"!==t.type&amp;&amp;this.div.focus();<span class="cstat-no" title="statement not covered" >t</span>his.#ys(t.offsetX,t.offsetY)}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasContextMenu(t){<span class="cstat-no" title="statement not covered" >t.preventDefault()}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointermove(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.#Ss(t.offsetX,t.offsetY)}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointerup(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.#Ps(t)}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointerleave(t){<span class="cstat-no" title="statement not covered" >this.#Ps(t)}</span>#Ps(t){<span class="cstat-no" title="statement not covered" >this.canvas.removeEventListener("pointerleave",this.#ts);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointermove",this.#Ze);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointerup",this.#es);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerdown",this.#ss);<span class="cstat-no" title="statement not covered" >s</span>etTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.canvas.removeEventListener("contextmenu",this.#Qe)}</span>),10);<span class="cstat-no" title="statement not covered" >t</span>his.#Cs(t.offsetX,t.offsetY);<span class="cstat-no" title="statement not covered" >t</span>his.addToAnnotationStorage();<span class="cstat-no" title="statement not covered" >t</span>his.setInBackground()}</span>#fs(){<span class="cstat-no" title="statement not covered" >this.canvas=document.createElement("canvas");<span class="cstat-no" title="statement not covered" >t</span>his.canvas.width=this.canvas.height=0;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.className="inkEditorCanvas";<span class="cstat-no" title="statement not covered" >I</span>nkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.canvas?.setAttribute("aria-label",t))</span>);<span class="cstat-no" title="statement not covered" >t</span>his.div.append(this.canvas);<span class="cstat-no" title="statement not covered" >t</span>his.ctx=this.canvas.getContext("2d")}</span>#ms(){<span class="cstat-no" title="statement not covered" >this.#os=new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0].contentRect;<span class="cstat-no" title="statement not covered" ></span>e.width&amp;&amp;e.height&amp;&amp;this.setDimensions(e.width,e.height)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his.#os.observe(this.div)}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.div)<span class="cstat-no" title="statement not covered" >return this.div;l</span></span>et t,e;<span class="cstat-no" title="statement not covered" >if(this.width){<span class="cstat-no" title="statement not covered" >t=this.x;<span class="cstat-no" title="statement not covered" >e</span>=this.y}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.render();<span class="cstat-no" title="statement not covered" >I</span>nkEditor._l10nPromise.get("editor_ink2_aria_label").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.div?.setAttribute("aria-label",t))</span>);c</span>onst[s,n,i,a]=<span class="cstat-no" title="statement not covered" >this.#As();<span class="cstat-no" title="statement not covered" ></span>this.setAt(s,n,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.setDims(i,a);<span class="cstat-no" title="statement not covered" >t</span>his.#fs();<span class="cstat-no" title="statement not covered" >i</span>f(this.width){const[s,n]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.setAt(t*s,e*n,this.width*s,this.height*n);<span class="cstat-no" title="statement not covered" >t</span>his.#rs=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#bs();<span class="cstat-no" title="statement not covered" >t</span>his.setDims(this.width*s,this.height*n);<span class="cstat-no" title="statement not covered" >t</span>his.#gs();<span class="cstat-no" title="statement not covered" >t</span>his.#Fs();<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.add("disabled")}</span>else{<span class="cstat-no" title="statement not covered" >this.div.classList.add("editing");<span class="cstat-no" title="statement not covered" >t</span>his.enableEditMode()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#ms();<span class="cstat-no" title="statement not covered" >r</span>eturn this.div}</span>#bs(){<span class="cstat-no" title="statement not covered" >if(!this.#rs)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.canvas.width=Math.ceil(this.width*t);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.height=Math.ceil(this.height*e);<span class="cstat-no" title="statement not covered" >t</span>his.#Ts()}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(t,e){const s=<span class="cstat-no" title="statement not covered" >Math.round(t),</span>n=<span class="cstat-no" title="statement not covered" >Math.round(e);<span class="cstat-no" title="statement not covered" ></span>if(this.#ls===s&amp;&amp;this.#cs===n)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#ls=s;<span class="cstat-no" title="statement not covered" >t</span>his.#cs=n;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.style.visibility="hidden";<span class="cstat-no" title="statement not covered" >i</span>f(this.#Ke&amp;&amp;Math.abs(this.#Ke-t/e)&gt;.01){<span class="cstat-no" title="statement not covered" >e=Math.ceil(t/this.#Ke);<span class="cstat-no" title="statement not covered" >t</span>his.setDims(t,e)}</span>c</span>onst[i,a]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.width=t/i;<span class="cstat-no" title="statement not covered" >t</span>his.height=e/a;<span class="cstat-no" title="statement not covered" >t</span>his.#is&amp;&amp;this.#ks(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.#bs();<span class="cstat-no" title="statement not covered" >t</span>his.#gs();<span class="cstat-no" title="statement not covered" >t</span>his.canvas.style.visibility="visible";<span class="cstat-no" title="statement not covered" >t</span>his.fixDims()}</span>#ks(t,e){const s=<span class="cstat-no" title="statement not covered" >this.#Ms(),</span>n=<span class="cstat-no" title="statement not covered" >(t-s)/this.#Je,</span>i=<span class="cstat-no" title="statement not covered" >(e-s)/this.#Ye;<span class="cstat-no" title="statement not covered" ></span>this.scaleFactor=Math.min(n,i)}</span>#Ts(){const t=<span class="cstat-no" title="statement not covered" >this.#Ms()/2;<span class="cstat-no" title="statement not covered" ></span>this.ctx.setTransform(this.scaleFactor,0,0,this.scaleFactor,this.translationX*this.scaleFactor+t,this.translationY*this.scaleFactor+t)}</span>static#Rs(t){const e=<span class="cstat-no" title="statement not covered" >new Path2D;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++){const[n,i,a,r]=<span class="cstat-no" title="statement not covered" >t[s];<span class="cstat-no" title="statement not covered" ></span>0===s&amp;&amp;e.moveTo(...n);<span class="cstat-no" title="statement not covered" >e</span>.bezierCurveTo(i[0],i[1],a[0],a[1],r[0],r[1])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>static#Ds(t,e,s){const[n,i,a,r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>switch(s){case 0:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){<span class="cstat-no" title="statement not covered" >t[e]+=n;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=r-t[e+1]}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){const s=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=t[e+1]+n;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=s+i}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){<span class="cstat-no" title="statement not covered" >t[e]=a-t[e];<span class="cstat-no" title="statement not covered" >t</span>[e+1]+=i}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){const s=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=a-t[e+1];<span class="cstat-no" title="statement not covered" >t</span>[e+1]=r-s}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>static#Is(t,e,s){const[n,i,a,r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>switch(s){case 0:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){<span class="cstat-no" title="statement not covered" >t[e]-=n;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=r-t[e+1]}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){const s=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=t[e+1]-i;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=s-n}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){<span class="cstat-no" title="statement not covered" >t[e]=a-t[e];<span class="cstat-no" title="statement not covered" >t</span>[e+1]-=i}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=2){const s=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=r-t[e+1];<span class="cstat-no" title="statement not covered" >t</span>[e+1]=a-s}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>#Os(t,e,s,n){const i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >this.thickness/2,</span>r=<span class="cstat-no" title="statement not covered" >t*e+a,</span>o=<span class="cstat-no" title="statement not covered" >t*s+a;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.paths){const s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >e.length;</span>n&lt;i;n++){const[l,c,h,d]=<span class="cstat-no" title="statement not covered" >e[n],</span>u=<span class="cstat-no" title="statement not covered" >t*l[0]+r,</span>p=<span class="cstat-no" title="statement not covered" >t*l[1]+o,</span>g=<span class="cstat-no" title="statement not covered" >t*c[0]+r,</span>f=<span class="cstat-no" title="statement not covered" >t*c[1]+o,</span>m=<span class="cstat-no" title="statement not covered" >t*h[0]+r,</span>b=<span class="cstat-no" title="statement not covered" >t*h[1]+o,</span>A=<span class="cstat-no" title="statement not covered" >t*d[0]+r,</span>_=<span class="cstat-no" title="statement not covered" >t*d[1]+o;<span class="cstat-no" title="statement not covered" ></span>if(0===n){<span class="cstat-no" title="statement not covered" >s.push(u,p);<span class="cstat-no" title="statement not covered" >a</span>.push(u,p)}<span class="cstat-no" title="statement not covered" ></span>s</span>.push(g,f,m,b,A,_);<span class="cstat-no" title="statement not covered" >a</span>.push(g,f);<span class="cstat-no" title="statement not covered" >n</span>===i-1&amp;&amp;a.push(A,_)}<span class="cstat-no" title="statement not covered" ></span>i</span>.push({bezier:InkEditor.#Ds(s,n,this.rotation),points:InkEditor.#Ds(a,n,this.rotation)})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>#Ls(){let t=<span class="cstat-no" title="statement not covered" >1/0,</span>e=<span class="cstat-no" title="statement not covered" >-1/0,</span>s=<span class="cstat-no" title="statement not covered" >1/0,</span>i=<span class="cstat-no" title="statement not covered" >-1/0;<span class="cstat-no" title="statement not covered" ></span>for(const a of this.paths)<span class="cstat-no" title="statement not covered" >for(const[r,o,l,c]of a){const a=<span class="cstat-no" title="statement not covered" >n.Util.bezierBoundingBox(...r,...o,...l,...c);<span class="cstat-no" title="statement not covered" ></span>t=Math.min(t,a[0]);<span class="cstat-no" title="statement not covered" >s</span>=Math.min(s,a[1]);<span class="cstat-no" title="statement not covered" >e</span>=Math.max(e,a[2]);<span class="cstat-no" title="statement not covered" >i</span>=Math.max(i,a[3])}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn[t,s,e,i]}</span>#Ms(){<span class="cstat-no" title="statement not covered" >return this.#is?Math.ceil(this.thickness*this.parentScale):0}</span>#ps(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.#is){<span class="cstat-no" title="statement not covered" >this.#gs();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >this.#Ls(),</span>s=<span class="cstat-no" title="statement not covered" >this.#Ms();<span class="cstat-no" title="statement not covered" ></span>this.#Je=Math.max(o,e[2]-e[0]);<span class="cstat-no" title="statement not covered" >t</span>his.#Ye=Math.max(o,e[3]-e[1]);c</span>onst n=<span class="cstat-no" title="statement not covered" >Math.ceil(s+this.#Je*this.scaleFactor),</span>i=<span class="cstat-no" title="statement not covered" >Math.ceil(s+this.#Ye*this.scaleFactor),</span>[a,r]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.width=n/a;<span class="cstat-no" title="statement not covered" >t</span>his.height=i/r;<span class="cstat-no" title="statement not covered" >t</span>his.#Ke=n/i;<span class="cstat-no" title="statement not covered" >t</span>his.#Fs();c</span>onst l=<span class="cstat-no" title="statement not covered" >this.translationX,</span>c=<span class="cstat-no" title="statement not covered" >this.translationY;<span class="cstat-no" title="statement not covered" ></span>this.translationX=-e[0];<span class="cstat-no" title="statement not covered" >t</span>his.translationY=-e[1];<span class="cstat-no" title="statement not covered" >t</span>his.#bs();<span class="cstat-no" title="statement not covered" >t</span>his.#gs();<span class="cstat-no" title="statement not covered" >t</span>his.#ls=n;<span class="cstat-no" title="statement not covered" >t</span>his.#cs=i;<span class="cstat-no" title="statement not covered" >t</span>his.setDims(n,i);c</span>onst h=<span class="cstat-no" title="statement not covered" >t?s/this.scaleFactor/2:0;<span class="cstat-no" title="statement not covered" ></span>this.translate(l-this.translationX-h,c-this.translationY-h)}</span>#Fs(){const{style:t}=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>if(this.#Ke&gt;=1){<span class="cstat-no" title="statement not covered" >t.minHeight="16px";<span class="cstat-no" title="statement not covered" >t</span>.minWidth=`${Math.round(this.#Ke*o)}px`}</span>else{<span class="cstat-no" title="statement not covered" >t.minWidth="16px";<span class="cstat-no" title="statement not covered" >t</span>.minHeight=`${Math.round(o/this.#Ke)}px`}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,s){<span class="cstat-no" title="statement not covered" >if(t instanceof a.InkAnnotationElement)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >super.deserialize(t,e,s);<span class="cstat-no" title="statement not covered" ></span>i.thickness=t.thickness;<span class="cstat-no" title="statement not covered" >i</span>.color=n.Util.makeHexColor(...t.color);<span class="cstat-no" title="statement not covered" >i</span>.opacity=t.opacity;c</span>onst[r,l]=<span class="cstat-no" title="statement not covered" >i.pageDimensions,</span>c=<span class="cstat-no" title="statement not covered" >i.width*r,</span>h=<span class="cstat-no" title="statement not covered" >i.height*l,</span>d=<span class="cstat-no" title="statement not covered" >i.parentScale,</span>u=<span class="cstat-no" title="statement not covered" >t.thickness/2;<span class="cstat-no" title="statement not covered" ></span>i.#Ke=c/h;<span class="cstat-no" title="statement not covered" >i</span>.#is=!0;<span class="cstat-no" title="statement not covered" >i</span>.#ls=Math.round(c);<span class="cstat-no" title="statement not covered" >i</span>.#cs=Math.round(h);c</span>onst{paths:p,rect:g,rotation:f}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let{bezier:t}of p){<span class="cstat-no" title="statement not covered" >t=InkEditor.#Is(t,g,f);c</span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.paths.push(e);l</span>et s=<span class="cstat-no" title="statement not covered" >d*(t[0]-u),</span>n=<span class="cstat-no" title="statement not covered" >d*(t[1]-u);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >2,</span>a=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;a;i+=6){const a=<span class="cstat-no" title="statement not covered" >d*(t[i]-u),</span>r=<span class="cstat-no" title="statement not covered" >d*(t[i+1]-u),</span>o=<span class="cstat-no" title="statement not covered" >d*(t[i+2]-u),</span>l=<span class="cstat-no" title="statement not covered" >d*(t[i+3]-u),</span>c=<span class="cstat-no" title="statement not covered" >d*(t[i+4]-u),</span>h=<span class="cstat-no" title="statement not covered" >d*(t[i+5]-u);<span class="cstat-no" title="statement not covered" ></span>e.push([[s,n],[a,r],[o,l],[c,h]]);<span class="cstat-no" title="statement not covered" >s</span>=c;<span class="cstat-no" title="statement not covered" >n</span>=h}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >this.#Rs(e);<span class="cstat-no" title="statement not covered" ></span>i.bezierPath2D.push(a)}</span>c</span>onst m=<span class="cstat-no" title="statement not covered" >i.#Ls();<span class="cstat-no" title="statement not covered" ></span>i.#Je=Math.max(o,m[2]-m[0]);<span class="cstat-no" title="statement not covered" >i</span>.#Ye=Math.max(o,m[3]-m[1]);<span class="cstat-no" title="statement not covered" >i</span>.#ks(c,h);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(){<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.getRect(0,0),</span>e=<span class="cstat-no" title="statement not covered" >i.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);<span class="cstat-no" title="statement not covered" ></span>return{annotationType:n.AnnotationEditorType.INK,color:e,thickness:this.thickness,opacity:this.opacity,paths:this.#Os(this.scaleFactor/this.parentScale,this.translationX,this.translationY,t),pageIndex:this.pageIndex,rect:t,rotation:this.rotation}}</span>}<span class="cstat-no" title="statement not covered" >e.InkEditor=InkEditor}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.SVGGraphics=void 0;v</span>ar n=<span class="cstat-no" title="statement not covered" >s(6),</span>i=<span class="cstat-no" title="statement not covered" >s(1),</span>a=<span class="cstat-no" title="statement not covered" >s(10);</span>const r=<span class="cstat-no" title="statement not covered" >"normal",</span>o=<span class="cstat-no" title="statement not covered" >"normal",</span>l=<span class="cstat-no" title="statement not covered" >"#000000",</span>c=<span class="cstat-no" title="statement not covered" >["butt","round","square"],</span>h=<span class="cstat-no" title="statement not covered" >["miter","round","bevel"],</span>createObjectURL=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(URL.createObjectURL&amp;&amp;"undefined"!=typeof Blob&amp;&amp;!s)<span class="cstat-no" title="statement not covered" >return URL.createObjectURL(new Blob([t],{type:e}));c</span></span>onst n=<span class="cstat-no" title="statement not covered" >"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";</span>let i=<span class="cstat-no" title="statement not covered" >`data:${e};base64,`;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=3){const a=<span class="cstat-no" title="statement not covered" >255&amp;t[e],</span>r=<span class="cstat-no" title="statement not covered" >255&amp;t[e+1],</span>o=<span class="cstat-no" title="statement not covered" >255&amp;t[e+2];<span class="cstat-no" title="statement not covered" ></span>i+=n[a&gt;&gt;2]+n[(3&amp;a)&lt;&lt;4|r&gt;&gt;4]+n[e+1&lt;s?(15&amp;r)&lt;&lt;2|o&gt;&gt;6:64]+n[e+2&lt;s?63&amp;o:64]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>,</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >new Uint8Array([137,80,78,71,13,10,26,10]),</span>e=<span class="cstat-no" title="statement not covered" >new Int32Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;256;t++){let s=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;8;t++)<span class="cstat-no" title="statement not covered" >s=1&amp;s?3988292384^s&gt;&gt;1&amp;2147483647:s&gt;&gt;1&amp;2147483647;<span class="cstat-no" title="statement not covered" >e</span></span>[t]=s}</span>f</span>unction <span class="fstat-no" title="function not covered" >writePngChunk(</span>t,s,n,i){let a=<span class="cstat-no" title="statement not covered" >i;</span>const r=<span class="cstat-no" title="statement not covered" >s.length;<span class="cstat-no" title="statement not covered" ></span>n[a]=r&gt;&gt;24&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a+1]=r&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a+2]=r&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a+3]=255&amp;r;<span class="cstat-no" title="statement not covered" >a</span>+=4;<span class="cstat-no" title="statement not covered" >n</span>[a]=255&amp;t.charCodeAt(0);<span class="cstat-no" title="statement not covered" >n</span>[a+1]=255&amp;t.charCodeAt(1);<span class="cstat-no" title="statement not covered" >n</span>[a+2]=255&amp;t.charCodeAt(2);<span class="cstat-no" title="statement not covered" >n</span>[a+3]=255&amp;t.charCodeAt(3);<span class="cstat-no" title="statement not covered" >a</span>+=4;<span class="cstat-no" title="statement not covered" >n</span>.set(s,a);<span class="cstat-no" title="statement not covered" >a</span>+=s.length;c</span>onst o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >crc32(</span>t,s,n){let i=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >s;</span>a&lt;n;a++){const s=<span class="cstat-no" title="statement not covered" >255&amp;(i^t[a]);<span class="cstat-no" title="statement not covered" ></span>i=i&gt;&gt;&gt;8^e[s]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn-1^i}</span>(n,i+4,a);<span class="cstat-no" title="statement not covered" ></span>n[a]=o&gt;&gt;24&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a+1]=o&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a+2]=o&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a+3]=255&amp;o}</span>function <span class="fstat-no" title="function not covered" >deflateSyncUncompressed(</span>t){let e=<span class="cstat-no" title="statement not covered" >t.length;</span>const s=<span class="cstat-no" title="statement not covered" >65535,</span>n=<span class="cstat-no" title="statement not covered" >Math.ceil(e/s),</span>i=<span class="cstat-no" title="statement not covered" >new Uint8Array(2+e+5*n+4);</span>let a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>i[a++]=120;<span class="cstat-no" title="statement not covered" >i</span>[a++]=156;l</span>et r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;e&gt;s;){<span class="cstat-no" title="statement not covered" >i[a++]=0;<span class="cstat-no" title="statement not covered" >i</span>[a++]=255;<span class="cstat-no" title="statement not covered" >i</span>[a++]=255;<span class="cstat-no" title="statement not covered" >i</span>[a++]=0;<span class="cstat-no" title="statement not covered" >i</span>[a++]=0;<span class="cstat-no" title="statement not covered" >i</span>.set(t.subarray(r,r+s),a);<span class="cstat-no" title="statement not covered" >a</span>+=s;<span class="cstat-no" title="statement not covered" >r</span>+=s;<span class="cstat-no" title="statement not covered" >e</span>-=s}<span class="cstat-no" title="statement not covered" ></span>i</span>[a++]=1;<span class="cstat-no" title="statement not covered" >i</span>[a++]=255&amp;e;<span class="cstat-no" title="statement not covered" >i</span>[a++]=e&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >i</span>[a++]=255&amp;~e;<span class="cstat-no" title="statement not covered" >i</span>[a++]=(65535&amp;~e)&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >i</span>.set(t.subarray(r),a);<span class="cstat-no" title="statement not covered" >a</span>+=t.length-r;c</span>onst o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >adler32(</span>t,e,s){let n=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >e;</span>a&lt;s;++a){<span class="cstat-no" title="statement not covered" >n=(n+(255&amp;t[a]))%65521;<span class="cstat-no" title="statement not covered" >i</span>=(i+n)%65521}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i&lt;&lt;16|n}</span>(t,0,t.length);<span class="cstat-no" title="statement not covered" ></span>i[a++]=o&gt;&gt;24&amp;255;<span class="cstat-no" title="statement not covered" >i</span>[a++]=o&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >i</span>[a++]=o&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >i</span>[a++]=255&amp;o;<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >encode(</span>e,s,n,r){const o=<span class="cstat-no" title="statement not covered" >e.width,</span>l=<span class="cstat-no" title="statement not covered" >e.height;</span>let c,h,d;const u=<span class="cstat-no" title="statement not covered" >e.data;<span class="cstat-no" title="statement not covered" ></span>switch(s){case i.ImageKind.GRAYSCALE_1BPP:<span class="cstat-no" title="statement not covered" >h=0;<span class="cstat-no" title="statement not covered" >c</span>=1;<span class="cstat-no" title="statement not covered" >d</span>=o+7&gt;&gt;3;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ImageKind.RGB_24BPP:<span class="cstat-no" title="statement not covered" >h=2;<span class="cstat-no" title="statement not covered" >c</span>=8;<span class="cstat-no" title="statement not covered" >d</span>=3*o;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ImageKind.RGBA_32BPP:<span class="cstat-no" title="statement not covered" >h=6;<span class="cstat-no" title="statement not covered" >c</span>=8;<span class="cstat-no" title="statement not covered" >d</span>=4*o;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("invalid format")}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >new Uint8Array((1+d)*l);</span>let g=<span class="cstat-no" title="statement not covered" >0,</span>f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;l;++t){<span class="cstat-no" title="statement not covered" >p[g++]=0;<span class="cstat-no" title="statement not covered" >p</span>.set(u.subarray(f,f+d),g);<span class="cstat-no" title="statement not covered" >f</span>+=d;<span class="cstat-no" title="statement not covered" >g</span>+=d}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===i.ImageKind.GRAYSCALE_1BPP&amp;&amp;r){<span class="cstat-no" title="statement not covered" >g=0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;l;t++){<span class="cstat-no" title="statement not covered" >g++;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;d;t++)<span class="cstat-no" title="statement not covered" >p[g++]^=255}</span></span>}</span>c</span>onst m=<span class="cstat-no" title="statement not covered" >new Uint8Array([o&gt;&gt;24&amp;255,o&gt;&gt;16&amp;255,o&gt;&gt;8&amp;255,255&amp;o,l&gt;&gt;24&amp;255,l&gt;&gt;16&amp;255,l&gt;&gt;8&amp;255,255&amp;l,c,h,0,0,0]),</span>b=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >deflateSync(</span>t){<span class="cstat-no" title="statement not covered" >if(!a.isNodeJS)<span class="cstat-no" title="statement not covered" >return deflateSyncUncompressed(t);<span class="cstat-no" title="statement not covered" >t</span></span>ry{let e;<span class="cstat-no" title="statement not covered" >e=parseInt(process.versions.node)&gt;=8?t:Buffer.from(t);c</span>onst s=<span class="cstat-no" title="statement not covered" >require("zlib").deflateSync(e,{level:9});<span class="cstat-no" title="statement not covered" ></span>return s instanceof Uint8Array?s:new Uint8Array(s)}</span>catch(t){<span class="cstat-no" title="statement not covered" >(0,i.warn)("Not compressing PNG because zlib.deflateSync is unavailable: "+t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn deflateSyncUncompressed(t)}</span>(p),</span>A=<span class="cstat-no" title="statement not covered" >t.length+36+m.length+b.length,</span>_=<span class="cstat-no" title="statement not covered" >new Uint8Array(A);</span>let y=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>_.set(t,y);<span class="cstat-no" title="statement not covered" >y</span>+=t.length;<span class="cstat-no" title="statement not covered" >w</span>ritePngChunk("IHDR",m,_,y);<span class="cstat-no" title="statement not covered" >y</span>+=12+m.length;<span class="cstat-no" title="statement not covered" >w</span>ritePngChunk("IDATA",b,_,y);<span class="cstat-no" title="statement not covered" >y</span>+=12+b.length;<span class="cstat-no" title="statement not covered" >w</span>ritePngChunk("IEND",new Uint8Array(0),_,y);<span class="cstat-no" title="statement not covered" >r</span>eturn createObjectURL(_,"image/png",n)}<span class="cstat-no" title="statement not covered" ></span>return function <span class="fstat-no" title="function not covered" >convertImgDataToPng(</span>t,e,s){<span class="cstat-no" title="statement not covered" >return encode(t,void 0===t.kind?i.ImageKind.GRAYSCALE_1BPP:t.kind,e,s)}</span>}</span>();</span>class SVGExtraState{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.fontSizeScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.fontWeight=o;<span class="cstat-no" title="statement not covered" >t</span>his.fontSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrix=i.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.fontMatrix=i.FONT_IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.leading=0;<span class="cstat-no" title="statement not covered" >t</span>his.textRenderingMode=i.TextRenderingMode.FILL;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.x=0;<span class="cstat-no" title="statement not covered" >t</span>his.y=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineY=0;<span class="cstat-no" title="statement not covered" >t</span>his.charSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.wordSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.textHScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.textRise=0;<span class="cstat-no" title="statement not covered" >t</span>his.fillColor=l;<span class="cstat-no" title="statement not covered" >t</span>his.strokeColor="#000000";<span class="cstat-no" title="statement not covered" >t</span>his.fillAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.strokeAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>his.lineJoin="";<span class="cstat-no" title="statement not covered" >t</span>his.lineCap="";<span class="cstat-no" title="statement not covered" >t</span>his.miterLimit=0;<span class="cstat-no" title="statement not covered" >t</span>his.dashArray=[];<span class="cstat-no" title="statement not covered" >t</span>his.dashPhase=0;<span class="cstat-no" title="statement not covered" >t</span>his.dependencies=[];<span class="cstat-no" title="statement not covered" >t</span>his.activeClipUrl=null;<span class="cstat-no" title="statement not covered" >t</span>his.clipGroup=null;<span class="cstat-no" title="statement not covered" >t</span>his.maskId=""}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){<span class="cstat-no" title="statement not covered" >return Object.create(this)}<span class="fstat-no" title="function not covered" ></span>se</span>tCurrentPoint(t,e){<span class="cstat-no" title="statement not covered" >this.x=t;<span class="cstat-no" title="statement not covered" >t</span>his.y=e}</span>}function <span class="fstat-no" title="function not covered" >pf(</span>t){<span class="cstat-no" title="statement not covered" >if(Number.isInteger(t))<span class="cstat-no" title="statement not covered" >return t.toString();c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.toFixed(10);</span>let s=<span class="cstat-no" title="statement not covered" >e.length-1;<span class="cstat-no" title="statement not covered" ></span>if("0"!==e[s])<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >d</span></span>o{<span class="cstat-no" title="statement not covered" >s--}</span>while("0"===e[s]);<span class="cstat-no" title="statement not covered" >r</span>eturn e.substring(0,"."===e[s]?s:s+1)}</span>function <span class="fstat-no" title="function not covered" >pm(</span>t){<span class="cstat-no" title="statement not covered" >if(0===t[4]&amp;&amp;0===t[5]){<span class="cstat-no" title="statement not covered" >if(0===t[1]&amp;&amp;0===t[2])<span class="cstat-no" title="statement not covered" >return 1===t[0]&amp;&amp;1===t[3]?"":`scale(${pf(t[0])} ${pf(t[3])})`;<span class="cstat-no" title="statement not covered" >i</span></span>f(t[0]===t[3]&amp;&amp;t[1]===-t[2]){<span class="cstat-no" title="statement not covered" >return`rotate(${pf(180*Math.acos(t[0])/Math.PI)})`}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(1===t[0]&amp;&amp;0===t[1]&amp;&amp;0===t[2]&amp;&amp;1===t[3])<span class="cstat-no" title="statement not covered" >return`translate(${pf(t[4])} ${pf(t[5])})`;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn`matrix(${pf(t[0])} ${pf(t[1])} ${pf(t[2])} ${pf(t[3])} ${pf(t[4])} ${pf(t[5])})`}</span>let u=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.SVGGraphics=class SVGGraphics{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >(0,n.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");<span class="cstat-no" title="statement not covered" >t</span>his.svgFactory=new n.DOMSVGFactory;<span class="cstat-no" title="statement not covered" >t</span>his.current=new SVGExtraState;<span class="cstat-no" title="statement not covered" >t</span>his.transformMatrix=i.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.transformStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.extraStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=t;<span class="cstat-no" title="statement not covered" >t</span>his.objs=e;<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his.pendingEOFill=!1;<span class="cstat-no" title="statement not covered" >t</span>his.embedFonts=!1;<span class="cstat-no" title="statement not covered" >t</span>his.embeddedFonts=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.cssStyle=null;<span class="cstat-no" title="statement not covered" >t</span>his.forceDataSchema=!!s;<span class="cstat-no" title="statement not covered" >t</span>his._operatorIdMapping=[];<span class="cstat-no" title="statement not covered" >f</span>or(const t in i.OPS)<span class="cstat-no" title="statement not covered" >this._operatorIdMapping[i.OPS[t]]=t}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tObject(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return"string"==typeof t?t.startsWith("g_")?this.commonObjs.get(t):this.objs.get(t):e}<span class="fstat-no" title="function not covered" ></span>sa</span>ve(){<span class="cstat-no" title="statement not covered" >this.transformStack.push(this.transformMatrix);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>this.extraStack.push(t);<span class="cstat-no" title="statement not covered" >t</span>his.current=t.clone()}<span class="fstat-no" title="function not covered" ></span>re</span>store(){<span class="cstat-no" title="statement not covered" >this.transformMatrix=this.transformStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.current=this.extraStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his.tgrp=null}<span class="fstat-no" title="function not covered" ></span>gr</span>oup(t){<span class="cstat-no" title="statement not covered" >this.save();<span class="cstat-no" title="statement not covered" >t</span>his.executeOpTree(t);<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="fstat-no" title="function not covered" ></span>lo</span>adDependencies(t){const e=<span class="cstat-no" title="statement not covered" >t.fnArray,</span>s=<span class="cstat-no" title="statement not covered" >t.argsArray;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.length;</span>t&lt;n;t++)<span class="cstat-no" title="statement not covered" >if(e[t]===i.OPS.dependency)<span class="cstat-no" title="statement not covered" >for(const e of s[t]){const t=<span class="cstat-no" title="statement not covered" >e.startsWith("g_")?this.commonObjs:this.objs,</span>s=<span class="cstat-no" title="statement not covered" >new Promise((<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.get(e,s)}</span>));<span class="cstat-no" title="statement not covered" ></span>this.current.dependencies.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn Promise.all(this.current.dependencies)}<span class="fstat-no" title="function not covered" ></span>tr</span>ansform(t,e,s,n,a,r){const o=<span class="cstat-no" title="statement not covered" >[t,e,s,n,a,r];<span class="cstat-no" title="statement not covered" ></span>this.transformMatrix=i.Util.transform(this.transformMatrix,o);<span class="cstat-no" title="statement not covered" >t</span>his.tgrp=null}<span class="fstat-no" title="function not covered" ></span>ge</span>tSVG(t,e){<span class="cstat-no" title="statement not covered" >this.viewport=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >this._initialize(e);<span class="cstat-no" title="statement not covered" ></span>return this.loadDependencies(t).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.transformMatrix=i.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.executeOpTree(this.convertOpList(t));<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>))}<span class="fstat-no" title="function not covered" ></span>co</span>nvertOpList(t){const e=<span class="cstat-no" title="statement not covered" >this._operatorIdMapping,</span>s=<span class="cstat-no" title="statement not covered" >t.argsArray,</span>n=<span class="cstat-no" title="statement not covered" >t.fnArray,</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >n.length;</span>t&lt;a;t++){const a=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>i.push({fnId:a,fn:e[a],args:s[t]})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn function <span class="fstat-no" title="function not covered" >opListToTree(</span>t){let e=<span class="cstat-no" title="statement not covered" >[];</span>const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const n of t)<span class="cstat-no" title="statement not covered" >if("save"!==n.fn)<span class="cstat-no" title="statement not covered" >"restore"===n.fn?e=s.pop():e.push(n);e</span>lse{<span class="cstat-no" title="statement not covered" >e.push({fnId:92,fn:"group",items:[]});<span class="cstat-no" title="statement not covered" >s</span>.push(e);<span class="cstat-no" title="statement not covered" >e</span>=e.at(-1).items}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>(i)}<span class="fstat-no" title="function not covered" ></span>ex</span>ecuteOpTree(t){<span class="cstat-no" title="statement not covered" >for(const e of t){const t=<span class="cstat-no" title="statement not covered" >e.fn,</span>s=<span class="cstat-no" title="statement not covered" >e.fnId,</span>n=<span class="cstat-no" title="statement not covered" >e.args;<span class="cstat-no" title="statement not covered" ></span>switch(0|s){case i.OPS.beginText:<span class="cstat-no" title="statement not covered" >this.beginText();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.dependency:<span class="cstat-no" title="statement not covered" >break;c</span>ase i.OPS.setLeading:<span class="cstat-no" title="statement not covered" >this.setLeading(n);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setLeadingMoveText:<span class="cstat-no" title="statement not covered" >this.setLeadingMoveText(n[0],n[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setFont:<span class="cstat-no" title="statement not covered" >this.setFont(n);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.showText:case i.OPS.showSpacedText:<span class="cstat-no" title="statement not covered" >this.showText(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.endText:<span class="cstat-no" title="statement not covered" >this.endText();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.moveText:<span class="cstat-no" title="statement not covered" >this.moveText(n[0],n[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setCharSpacing:<span class="cstat-no" title="statement not covered" >this.setCharSpacing(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setWordSpacing:<span class="cstat-no" title="statement not covered" >this.setWordSpacing(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setHScale:<span class="cstat-no" title="statement not covered" >this.setHScale(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setTextMatrix:<span class="cstat-no" title="statement not covered" >this.setTextMatrix(n[0],n[1],n[2],n[3],n[4],n[5]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setTextRise:<span class="cstat-no" title="statement not covered" >this.setTextRise(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setTextRenderingMode:<span class="cstat-no" title="statement not covered" >this.setTextRenderingMode(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setLineWidth:<span class="cstat-no" title="statement not covered" >this.setLineWidth(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setLineJoin:<span class="cstat-no" title="statement not covered" >this.setLineJoin(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setLineCap:<span class="cstat-no" title="statement not covered" >this.setLineCap(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setMiterLimit:<span class="cstat-no" title="statement not covered" >this.setMiterLimit(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setFillRGBColor:<span class="cstat-no" title="statement not covered" >this.setFillRGBColor(n[0],n[1],n[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setStrokeRGBColor:<span class="cstat-no" title="statement not covered" >this.setStrokeRGBColor(n[0],n[1],n[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setStrokeColorN:<span class="cstat-no" title="statement not covered" >this.setStrokeColorN(n);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setFillColorN:<span class="cstat-no" title="statement not covered" >this.setFillColorN(n);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.shadingFill:<span class="cstat-no" title="statement not covered" >this.shadingFill(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setDash:<span class="cstat-no" title="statement not covered" >this.setDash(n[0],n[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setRenderingIntent:<span class="cstat-no" title="statement not covered" >this.setRenderingIntent(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setFlatness:<span class="cstat-no" title="statement not covered" >this.setFlatness(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.setGState:<span class="cstat-no" title="statement not covered" >this.setGState(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.fill:<span class="cstat-no" title="statement not covered" >this.fill();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.eoFill:<span class="cstat-no" title="statement not covered" >this.eoFill();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.stroke:<span class="cstat-no" title="statement not covered" >this.stroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.fillStroke:<span class="cstat-no" title="statement not covered" >this.fillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.eoFillStroke:<span class="cstat-no" title="statement not covered" >this.eoFillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.clip:<span class="cstat-no" title="statement not covered" >this.clip("nonzero");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.eoClip:<span class="cstat-no" title="statement not covered" >this.clip("evenodd");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.paintSolidColorImageMask:<span class="cstat-no" title="statement not covered" >this.paintSolidColorImageMask();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.paintImageXObject:<span class="cstat-no" title="statement not covered" >this.paintImageXObject(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.paintInlineImageXObject:<span class="cstat-no" title="statement not covered" >this.paintInlineImageXObject(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.paintImageMaskXObject:<span class="cstat-no" title="statement not covered" >this.paintImageMaskXObject(n[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.paintFormXObjectBegin:<span class="cstat-no" title="statement not covered" >this.paintFormXObjectBegin(n[0],n[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.paintFormXObjectEnd:<span class="cstat-no" title="statement not covered" >this.paintFormXObjectEnd();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.closePath:<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.closeStroke:<span class="cstat-no" title="statement not covered" >this.closeStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.closeFillStroke:<span class="cstat-no" title="statement not covered" >this.closeFillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.closeEOFillStroke:<span class="cstat-no" title="statement not covered" >this.closeEOFillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.nextLine:<span class="cstat-no" title="statement not covered" >this.nextLine();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.transform:<span class="cstat-no" title="statement not covered" >this.transform(n[0],n[1],n[2],n[3],n[4],n[5]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.constructPath:<span class="cstat-no" title="statement not covered" >this.constructPath(n[0],n[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.endPath:<span class="cstat-no" title="statement not covered" >this.endPath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 92:<span class="cstat-no" title="statement not covered" >this.group(e.items);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,i.warn)(`Unimplemented operator ${t}`)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tWordSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.wordSpacing=t}<span class="fstat-no" title="function not covered" ></span>se</span>tCharSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.charSpacing=t}<span class="fstat-no" title="function not covered" ></span>ne</span>xtLine(){<span class="cstat-no" title="statement not covered" >this.moveText(0,this.current.leading)}<span class="fstat-no" title="function not covered" ></span>se</span>tTextMatrix(t,e,s,n,i,a){const r=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>r.textMatrix=r.lineMatrix=[t,e,s,n,i,a];<span class="cstat-no" title="statement not covered" >r</span>.textMatrixScale=Math.hypot(t,e);<span class="cstat-no" title="statement not covered" >r</span>.x=r.lineX=0;<span class="cstat-no" title="statement not covered" >r</span>.y=r.lineY=0;<span class="cstat-no" title="statement not covered" >r</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >r</span>.ycoords=[];<span class="cstat-no" title="statement not covered" >r</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >r</span>.tspan.setAttributeNS(null,"font-family",r.fontFamily);<span class="cstat-no" title="statement not covered" >r</span>.tspan.setAttributeNS(null,"font-size",`${pf(r.fontSize)}px`);<span class="cstat-no" title="statement not covered" >r</span>.tspan.setAttributeNS(null,"y",pf(-r.y));<span class="cstat-no" title="statement not covered" >r</span>.txtElement=this.svgFactory.createElement("svg:text");<span class="cstat-no" title="statement not covered" >r</span>.txtElement.append(r.tspan)}<span class="fstat-no" title="function not covered" ></span>be</span>ginText(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>t.x=t.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>.y=t.lineY=0;<span class="cstat-no" title="statement not covered" >t</span>.textMatrix=i.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>.lineMatrix=i.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >t</span>.txtElement=this.svgFactory.createElement("svg:text");<span class="cstat-no" title="statement not covered" >t</span>.txtgrp=this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" >t</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >t</span>.ycoords=[]}<span class="fstat-no" title="function not covered" ></span>mo</span>veText(t,e){const s=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>s.x=s.lineX+=t;<span class="cstat-no" title="statement not covered" >s</span>.y=s.lineY+=e;<span class="cstat-no" title="statement not covered" >s</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >s</span>.ycoords=[];<span class="cstat-no" title="statement not covered" >s</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >s</span>.tspan.setAttributeNS(null,"font-family",s.fontFamily);<span class="cstat-no" title="statement not covered" >s</span>.tspan.setAttributeNS(null,"font-size",`${pf(s.fontSize)}px`);<span class="cstat-no" title="statement not covered" >s</span>.tspan.setAttributeNS(null,"y",pf(-s.y))}<span class="fstat-no" title="function not covered" ></span>sh</span>owText(t){const e=<span class="cstat-no" title="statement not covered" >this.current,</span>s=<span class="cstat-no" title="statement not covered" >e.font,</span>n=<span class="cstat-no" title="statement not covered" >e.fontSize;<span class="cstat-no" title="statement not covered" ></span>if(0===n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >e.fontSizeScale,</span>c=<span class="cstat-no" title="statement not covered" >e.charSpacing,</span>h=<span class="cstat-no" title="statement not covered" >e.wordSpacing,</span>d=<span class="cstat-no" title="statement not covered" >e.fontDirection,</span>u=<span class="cstat-no" title="statement not covered" >e.textHScale*d,</span>p=<span class="cstat-no" title="statement not covered" >s.vertical,</span>g=<span class="cstat-no" title="statement not covered" >p?1:-1,</span>f=<span class="cstat-no" title="statement not covered" >s.defaultVMetrics,</span>m=<span class="cstat-no" title="statement not covered" >n*e.fontMatrix[0];</span>let b=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const i of t){<span class="cstat-no" title="statement not covered" >if(null===i){<span class="cstat-no" title="statement not covered" >b+=d*h;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("number"==typeof i){<span class="cstat-no" title="statement not covered" >b+=g*i*n/1e3;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst t=<span class="cstat-no" title="statement not covered" >(i.isSpace?h:0)+c,</span>r=<span class="cstat-no" title="statement not covered" >i.fontChar;</span>let o,l,u,A=<span class="cstat-no" title="statement not covered" >i.width;<span class="cstat-no" title="statement not covered" ></span>if(p){let t;const e=<span class="cstat-no" title="statement not covered" >i.vmetric||f;<span class="cstat-no" title="statement not covered" ></span>t=i.vmetric?e[1]:.5*A;<span class="cstat-no" title="statement not covered" >t</span>=-t*m;c</span>onst s=<span class="cstat-no" title="statement not covered" >e[2]*m;<span class="cstat-no" title="statement not covered" ></span>A=e?-e[0]:A;<span class="cstat-no" title="statement not covered" >o</span>=t/a;<span class="cstat-no" title="statement not covered" >l</span>=(b+s)/a}</span>else{<span class="cstat-no" title="statement not covered" >o=b/a;<span class="cstat-no" title="statement not covered" >l</span>=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i.isInFont||s.missingFile){<span class="cstat-no" title="statement not covered" >e.xcoords.push(e.x+o);<span class="cstat-no" title="statement not covered" >p</span>&amp;&amp;e.ycoords.push(-e.y+l);<span class="cstat-no" title="statement not covered" >e</span>.tspan.textContent+=r}<span class="cstat-no" title="statement not covered" ></span>u</span>=p?A*m-t*d:A*m+t*d;<span class="cstat-no" title="statement not covered" >b</span>+=u}<span class="cstat-no" title="statement not covered" ></span>e</span>.tspan.setAttributeNS(null,"x",e.xcoords.map(pf).join(" "));<span class="cstat-no" title="statement not covered" >p</span>?e.tspan.setAttributeNS(null,"y",e.ycoords.map(pf).join(" ")):e.tspan.setAttributeNS(null,"y",pf(-e.y));<span class="cstat-no" title="statement not covered" >p</span>?e.y-=b:e.x+=b*u;<span class="cstat-no" title="statement not covered" >e</span>.tspan.setAttributeNS(null,"font-family",e.fontFamily);<span class="cstat-no" title="statement not covered" >e</span>.tspan.setAttributeNS(null,"font-size",`${pf(e.fontSize)}px`);<span class="cstat-no" title="statement not covered" >e</span>.fontStyle!==r&amp;&amp;e.tspan.setAttributeNS(null,"font-style",e.fontStyle);<span class="cstat-no" title="statement not covered" >e</span>.fontWeight!==o&amp;&amp;e.tspan.setAttributeNS(null,"font-weight",e.fontWeight);c</span>onst A=<span class="cstat-no" title="statement not covered" >e.textRenderingMode&amp;i.TextRenderingMode.FILL_STROKE_MASK;<span class="cstat-no" title="statement not covered" ></span>if(A===i.TextRenderingMode.FILL||A===i.TextRenderingMode.FILL_STROKE){<span class="cstat-no" title="statement not covered" >e.fillColor!==l&amp;&amp;e.tspan.setAttributeNS(null,"fill",e.fillColor);<span class="cstat-no" title="statement not covered" >e</span>.fillAlpha&lt;1&amp;&amp;e.tspan.setAttributeNS(null,"fill-opacity",e.fillAlpha)}</span>else <span class="cstat-no" title="statement not covered" >e.textRenderingMode===i.TextRenderingMode.ADD_TO_PATH?e.tspan.setAttributeNS(null,"fill","transparent"):e.tspan.setAttributeNS(null,"fill","none");<span class="cstat-no" title="statement not covered" >i</span></span>f(A===i.TextRenderingMode.STROKE||A===i.TextRenderingMode.FILL_STROKE){const t=<span class="cstat-no" title="statement not covered" >1/(e.textMatrixScale||1);<span class="cstat-no" title="statement not covered" ></span>this._setStrokeAttributes(e.tspan,t)}</span>l</span>et _=<span class="cstat-no" title="statement not covered" >e.textMatrix;<span class="cstat-no" title="statement not covered" ></span>if(0!==e.textRise){<span class="cstat-no" title="statement not covered" >_=_.slice();<span class="cstat-no" title="statement not covered" >_</span>[5]+=e.textRise}<span class="cstat-no" title="statement not covered" ></span>e</span>.txtElement.setAttributeNS(null,"transform",`${pm(_)} scale(${pf(u)}, -1)`);<span class="cstat-no" title="statement not covered" >e</span>.txtElement.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve");<span class="cstat-no" title="statement not covered" >e</span>.txtElement.append(e.tspan);<span class="cstat-no" title="statement not covered" >e</span>.txtgrp.append(e.txtElement);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(e.txtElement)}<span class="fstat-no" title="function not covered" ></span>se</span>tLeadingMoveText(t,e){<span class="cstat-no" title="statement not covered" >this.setLeading(-e);<span class="cstat-no" title="statement not covered" >t</span>his.moveText(t,e)}<span class="fstat-no" title="function not covered" ></span>ad</span>dFontStyle(t){<span class="cstat-no" title="statement not covered" >if(!t.data)<span class="cstat-no" title="statement not covered" >throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.cssStyle){<span class="cstat-no" title="statement not covered" >this.cssStyle=this.svgFactory.createElement("svg:style");<span class="cstat-no" title="statement not covered" >t</span>his.cssStyle.setAttributeNS(null,"type","text/css");<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(this.cssStyle)}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >createObjectURL(t.data,t.mimetype,this.forceDataSchema);<span class="cstat-no" title="statement not covered" ></span>this.cssStyle.textContent+=`@font-face { font-family: "${t.loadedName}"; src: url(${e}); }\n`}<span class="fstat-no" title="function not covered" ></span>se</span>tFont(t){const e=<span class="cstat-no" title="statement not covered" >this.current,</span>s=<span class="cstat-no" title="statement not covered" >this.commonObjs.get(t[0]);</span>let n=<span class="cstat-no" title="statement not covered" >t[1];<span class="cstat-no" title="statement not covered" ></span>e.font=s;<span class="cstat-no" title="statement not covered" >i</span>f(this.embedFonts&amp;&amp;!s.missingFile&amp;&amp;!this.embeddedFonts[s.loadedName]){<span class="cstat-no" title="statement not covered" >this.addFontStyle(s);<span class="cstat-no" title="statement not covered" >t</span>his.embeddedFonts[s.loadedName]=s}<span class="cstat-no" title="statement not covered" ></span>e</span>.fontMatrix=s.fontMatrix||i.FONT_IDENTITY_MATRIX;l</span>et a=<span class="cstat-no" title="statement not covered" >"normal";<span class="cstat-no" title="statement not covered" ></span>s.black?a="900":s.bold&amp;&amp;(a="bold");c</span>onst r=<span class="cstat-no" title="statement not covered" >s.italic?"italic":"normal";<span class="cstat-no" title="statement not covered" ></span>if(n&lt;0){<span class="cstat-no" title="statement not covered" >n=-n;<span class="cstat-no" title="statement not covered" >e</span>.fontDirection=-1}</span>else <span class="cstat-no" title="statement not covered" >e.fontDirection=1;<span class="cstat-no" title="statement not covered" >e</span></span>.fontSize=n;<span class="cstat-no" title="statement not covered" >e</span>.fontFamily=s.loadedName;<span class="cstat-no" title="statement not covered" >e</span>.fontWeight=a;<span class="cstat-no" title="statement not covered" >e</span>.fontStyle=r;<span class="cstat-no" title="statement not covered" >e</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >e</span>.tspan.setAttributeNS(null,"y",pf(-e.y));<span class="cstat-no" title="statement not covered" >e</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >e</span>.ycoords=[]}<span class="fstat-no" title="function not covered" ></span>en</span>dText(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.textRenderingMode&amp;i.TextRenderingMode.ADD_TO_PATH_FLAG&amp;&amp;t.txtElement?.hasChildNodes()){<span class="cstat-no" title="statement not covered" >t.element=t.txtElement;<span class="cstat-no" title="statement not covered" >t</span>his.clip("nonzero");<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tLineWidth(t){<span class="cstat-no" title="statement not covered" >t&gt;0&amp;&amp;(this.current.lineWidth=t)}<span class="fstat-no" title="function not covered" ></span>se</span>tLineCap(t){<span class="cstat-no" title="statement not covered" >this.current.lineCap=c[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tLineJoin(t){<span class="cstat-no" title="statement not covered" >this.current.lineJoin=h[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tMiterLimit(t){<span class="cstat-no" title="statement not covered" >this.current.miterLimit=t}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeAlpha(t){<span class="cstat-no" title="statement not covered" >this.current.strokeAlpha=t}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeRGBColor(t,e,s){<span class="cstat-no" title="statement not covered" >this.current.strokeColor=i.Util.makeHexColor(t,e,s)}<span class="fstat-no" title="function not covered" ></span>se</span>tFillAlpha(t){<span class="cstat-no" title="statement not covered" >this.current.fillAlpha=t}<span class="fstat-no" title="function not covered" ></span>se</span>tFillRGBColor(t,e,s){<span class="cstat-no" title="statement not covered" >this.current.fillColor=i.Util.makeHexColor(t,e,s);<span class="cstat-no" title="statement not covered" >t</span>his.current.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >t</span>his.current.xcoords=[];<span class="cstat-no" title="statement not covered" >t</span>his.current.ycoords=[]}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeColorN(t){<span class="cstat-no" title="statement not covered" >this.current.strokeColor=this._makeColorN_Pattern(t)}<span class="fstat-no" title="function not covered" ></span>se</span>tFillColorN(t){<span class="cstat-no" title="statement not covered" >this.current.fillColor=this._makeColorN_Pattern(t)}<span class="fstat-no" title="function not covered" ></span>sh</span>adingFill(t){const{width:e,height:s}=<span class="cstat-no" title="statement not covered" >this.viewport,</span>n=<span class="cstat-no" title="statement not covered" >i.Util.inverseTransform(this.transformMatrix),</span>[a,r,o,l]=<span class="cstat-no" title="statement not covered" >i.Util.getAxialAlignedBoundingBox([0,0,e,s],n),</span>c=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>c.setAttributeNS(null,"x",a);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"y",r);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"width",o-a);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"height",l-r);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"fill",this._makeShadingPattern(t));<span class="cstat-no" title="statement not covered" >t</span>his.current.fillAlpha&lt;1&amp;&amp;c.setAttributeNS(null,"fill-opacity",this.current.fillAlpha);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(c)}<span class="fstat-no" title="function not covered" ></span>_m</span>akeColorN_Pattern(t){<span class="cstat-no" title="statement not covered" >return"TilingPattern"===t[0]?this._makeTilingPattern(t):this._makeShadingPattern(t)}<span class="fstat-no" title="function not covered" ></span>_m</span>akeTilingPattern(t){const e=<span class="cstat-no" title="statement not covered" >t[1],</span>s=<span class="cstat-no" title="statement not covered" >t[2],</span>n=<span class="cstat-no" title="statement not covered" >t[3]||i.IDENTITY_MATRIX,</span>[a,r,o,l]=<span class="cstat-no" title="statement not covered" >t[4],</span>c=<span class="cstat-no" title="statement not covered" >t[5],</span>h=<span class="cstat-no" title="statement not covered" >t[6],</span>d=<span class="cstat-no" title="statement not covered" >t[7],</span>u=<span class="cstat-no" title="statement not covered" >"shading"+g++,</span>[p,f,m,b]=<span class="cstat-no" title="statement not covered" >i.Util.normalizeRect([...i.Util.applyTransform([a,r],n),...i.Util.applyTransform([o,l],n)]),</span>[A,_]=<span class="cstat-no" title="statement not covered" >i.Util.singularValueDecompose2dScale(n),</span>y=<span class="cstat-no" title="statement not covered" >c*A,</span>v=<span class="cstat-no" title="statement not covered" >h*_,</span>S=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:pattern");<span class="cstat-no" title="statement not covered" ></span>S.setAttributeNS(null,"id",u);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"patternUnits","userSpaceOnUse");<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"width",y);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"height",v);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"x",`${p}`);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"y",`${f}`);c</span>onst E=<span class="cstat-no" title="statement not covered" >this.svg,</span>x=<span class="cstat-no" title="statement not covered" >this.transformMatrix,</span>C=<span class="cstat-no" title="statement not covered" >this.current.fillColor,</span>w=<span class="cstat-no" title="statement not covered" >this.current.strokeColor,</span>T=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(m-p,b-f);<span class="cstat-no" title="statement not covered" ></span>this.svg=T;<span class="cstat-no" title="statement not covered" >t</span>his.transformMatrix=n;<span class="cstat-no" title="statement not covered" >i</span>f(2===d){const t=<span class="cstat-no" title="statement not covered" >i.Util.makeHexColor(...e);<span class="cstat-no" title="statement not covered" ></span>this.current.fillColor=t;<span class="cstat-no" title="statement not covered" >t</span>his.current.strokeColor=t}<span class="cstat-no" title="statement not covered" ></span>t</span>his.executeOpTree(this.convertOpList(s));<span class="cstat-no" title="statement not covered" >t</span>his.svg=E;<span class="cstat-no" title="statement not covered" >t</span>his.transformMatrix=x;<span class="cstat-no" title="statement not covered" >t</span>his.current.fillColor=C;<span class="cstat-no" title="statement not covered" >t</span>his.current.strokeColor=w;<span class="cstat-no" title="statement not covered" >S</span>.append(T.childNodes[0]);<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(S);<span class="cstat-no" title="statement not covered" >r</span>eturn`url(#${u})`}<span class="fstat-no" title="function not covered" ></span>_m</span>akeShadingPattern(t){<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;(t=this.objs.get(t));<span class="cstat-no" title="statement not covered" >s</span>witch(t[0]){case"RadialAxial":const e=<span class="cstat-no" title="statement not covered" >"shading"+g++,</span>s=<span class="cstat-no" title="statement not covered" >t[3];</span>let n;<span class="cstat-no" title="statement not covered" >switch(t[1]){case"axial":const s=<span class="cstat-no" title="statement not covered" >t[4],</span>i=<span class="cstat-no" title="statement not covered" >t[5];<span class="cstat-no" title="statement not covered" ></span>n=this.svgFactory.createElement("svg:linearGradient");<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"id",e);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"gradientUnits","userSpaceOnUse");<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"x1",s[0]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"y1",s[1]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"x2",i[0]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"y2",i[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"radial":const a=<span class="cstat-no" title="statement not covered" >t[4],</span>r=<span class="cstat-no" title="statement not covered" >t[5],</span>o=<span class="cstat-no" title="statement not covered" >t[6],</span>l=<span class="cstat-no" title="statement not covered" >t[7];<span class="cstat-no" title="statement not covered" ></span>n=this.svgFactory.createElement("svg:radialGradient");<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"id",e);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"gradientUnits","userSpaceOnUse");<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"cx",r[0]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"cy",r[1]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"r",l);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"fx",a[0]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"fy",a[1]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"fr",o);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Unknown RadialAxial type: ${t[1]}`)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of s){const e=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:stop");<span class="cstat-no" title="statement not covered" ></span>e.setAttributeNS(null,"offset",t[0]);<span class="cstat-no" title="statement not covered" >e</span>.setAttributeNS(null,"stop-color",t[1]);<span class="cstat-no" title="statement not covered" >n</span>.append(e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.defs.append(n);<span class="cstat-no" title="statement not covered" >r</span>eturn`url(#${e})`;c</span>ase"Mesh":<span class="cstat-no" title="statement not covered" >(0,i.warn)("Unimplemented pattern Mesh");<span class="cstat-no" title="statement not covered" >r</span>eturn null;c</span>ase"Dummy":<span class="cstat-no" title="statement not covered" >return"hotpink";d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Unknown IR type: ${t[0]}`)}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tDash(t,e){<span class="cstat-no" title="statement not covered" >this.current.dashArray=t;<span class="cstat-no" title="statement not covered" >t</span>his.current.dashPhase=e}<span class="fstat-no" title="function not covered" ></span>co</span>nstructPath(t,e){const s=<span class="cstat-no" title="statement not covered" >this.current;</span>let n=<span class="cstat-no" title="statement not covered" >s.x,</span>a=<span class="cstat-no" title="statement not covered" >s.y,</span>r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const s of t)<span class="cstat-no" title="statement not covered" >switch(0|s){case i.OPS.rectangle:<span class="cstat-no" title="statement not covered" >n=e[o++];<span class="cstat-no" title="statement not covered" >a</span>=e[o++];c</span>onst t=<span class="cstat-no" title="statement not covered" >n+e[o++],</span>s=<span class="cstat-no" title="statement not covered" >a+e[o++];<span class="cstat-no" title="statement not covered" ></span>r.push("M",pf(n),pf(a),"L",pf(t),pf(a),"L",pf(t),pf(s),"L",pf(n),pf(s),"Z");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.moveTo:<span class="cstat-no" title="statement not covered" >n=e[o++];<span class="cstat-no" title="statement not covered" >a</span>=e[o++];<span class="cstat-no" title="statement not covered" >r</span>.push("M",pf(n),pf(a));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.lineTo:<span class="cstat-no" title="statement not covered" >n=e[o++];<span class="cstat-no" title="statement not covered" >a</span>=e[o++];<span class="cstat-no" title="statement not covered" >r</span>.push("L",pf(n),pf(a));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.curveTo:<span class="cstat-no" title="statement not covered" >n=e[o+4];<span class="cstat-no" title="statement not covered" >a</span>=e[o+5];<span class="cstat-no" title="statement not covered" >r</span>.push("C",pf(e[o]),pf(e[o+1]),pf(e[o+2]),pf(e[o+3]),pf(n),pf(a));<span class="cstat-no" title="statement not covered" >o</span>+=6;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.curveTo2:<span class="cstat-no" title="statement not covered" >r.push("C",pf(n),pf(a),pf(e[o]),pf(e[o+1]),pf(e[o+2]),pf(e[o+3]));<span class="cstat-no" title="statement not covered" >n</span>=e[o+2];<span class="cstat-no" title="statement not covered" >a</span>=e[o+3];<span class="cstat-no" title="statement not covered" >o</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.curveTo3:<span class="cstat-no" title="statement not covered" >n=e[o+2];<span class="cstat-no" title="statement not covered" >a</span>=e[o+3];<span class="cstat-no" title="statement not covered" >r</span>.push("C",pf(e[o]),pf(e[o+1]),pf(n),pf(a),pf(n),pf(a));<span class="cstat-no" title="statement not covered" >o</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.OPS.closePath:<span class="cstat-no" title="statement not covered" >r.push("Z")}<span class="cstat-no" title="statement not covered" ></span>r</span></span>=r.join(" ");<span class="cstat-no" title="statement not covered" >i</span>f(s.path&amp;&amp;t.length&gt;0&amp;&amp;t[0]!==i.OPS.rectangle&amp;&amp;t[0]!==i.OPS.moveTo)<span class="cstat-no" title="statement not covered" >r=s.path.getAttributeNS(null,"d")+r;e</span>lse{<span class="cstat-no" title="statement not covered" >s.path=this.svgFactory.createElement("svg:path");<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(s.path)}<span class="cstat-no" title="statement not covered" ></span>s</span>.path.setAttributeNS(null,"d",r);<span class="cstat-no" title="statement not covered" >s</span>.path.setAttributeNS(null,"fill","none");<span class="cstat-no" title="statement not covered" >s</span>.element=s.path;<span class="cstat-no" title="statement not covered" >s</span>.setCurrentPoint(n,a)}<span class="fstat-no" title="function not covered" ></span>en</span>dPath(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>t.path=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this.pendingClip)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.element){<span class="cstat-no" title="statement not covered" >this.pendingClip=null;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >"clippath"+u++,</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:clipPath");<span class="cstat-no" title="statement not covered" ></span>s.setAttributeNS(null,"id",e);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"transform",pm(this.transformMatrix));c</span>onst n=<span class="cstat-no" title="statement not covered" >t.element.cloneNode(!0);<span class="cstat-no" title="statement not covered" ></span>"evenodd"===this.pendingClip?n.setAttributeNS(null,"clip-rule","evenodd"):n.setAttributeNS(null,"clip-rule","nonzero");<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >s</span>.append(n);<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(s);<span class="cstat-no" title="statement not covered" >i</span>f(t.activeClipUrl){<span class="cstat-no" title="statement not covered" >t.clipGroup=null;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.extraStack)<span class="cstat-no" title="statement not covered" >t.clipGroup=null;<span class="cstat-no" title="statement not covered" >s</span></span>.setAttributeNS(null,"clip-path",t.activeClipUrl)}<span class="cstat-no" title="statement not covered" ></span>t</span>.activeClipUrl=`url(#${e})`;<span class="cstat-no" title="statement not covered" >t</span>his.tgrp=null}<span class="fstat-no" title="function not covered" ></span>cl</span>ip(t){<span class="cstat-no" title="statement not covered" >this.pendingClip=t}<span class="fstat-no" title="function not covered" ></span>cl</span>osePath(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.path){const e=<span class="cstat-no" title="statement not covered" >`${t.path.getAttributeNS(null,"d")}Z`;<span class="cstat-no" title="statement not covered" ></span>t.path.setAttributeNS(null,"d",e)}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tLeading(t){<span class="cstat-no" title="statement not covered" >this.current.leading=-t}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRise(t){<span class="cstat-no" title="statement not covered" >this.current.textRise=t}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRenderingMode(t){<span class="cstat-no" title="statement not covered" >this.current.textRenderingMode=t}<span class="fstat-no" title="function not covered" ></span>se</span>tHScale(t){<span class="cstat-no" title="statement not covered" >this.current.textHScale=t/100}<span class="fstat-no" title="function not covered" ></span>se</span>tRenderingIntent(t){}<span class="fstat-no" title="function not covered" >se</span>tFlatness(t){}<span class="fstat-no" title="function not covered" >se</span>tGState(t){<span class="cstat-no" title="statement not covered" >for(const[e,s]of t)<span class="cstat-no" title="statement not covered" >switch(e){case"LW":<span class="cstat-no" title="statement not covered" >this.setLineWidth(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LC":<span class="cstat-no" title="statement not covered" >this.setLineCap(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LJ":<span class="cstat-no" title="statement not covered" >this.setLineJoin(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ML":<span class="cstat-no" title="statement not covered" >this.setMiterLimit(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"D":<span class="cstat-no" title="statement not covered" >this.setDash(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RI":<span class="cstat-no" title="statement not covered" >this.setRenderingIntent(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"FL":<span class="cstat-no" title="statement not covered" >this.setFlatness(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Font":<span class="cstat-no" title="statement not covered" >this.setFont(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CA":<span class="cstat-no" title="statement not covered" >this.setStrokeAlpha(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ca":<span class="cstat-no" title="statement not covered" >this.setFillAlpha(s);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,i.warn)(`Unimplemented graphic state operator ${e}`)}</span>}<span class="fstat-no" title="function not covered" ></span></span>fi</span>ll(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.element){<span class="cstat-no" title="statement not covered" >t.element.setAttributeNS(null,"fill",t.fillColor);<span class="cstat-no" title="statement not covered" >t</span>.element.setAttributeNS(null,"fill-opacity",t.fillAlpha);<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>roke(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.element){<span class="cstat-no" title="statement not covered" >this._setStrokeAttributes(t.element);<span class="cstat-no" title="statement not covered" >t</span>.element.setAttributeNS(null,"fill","none");<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>etStrokeAttributes(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{const s=<span class="cstat-no" title="statement not covered" >this.current;</span>let n=<span class="cstat-no" title="statement not covered" >s.dashArray;<span class="cstat-no" title="statement not covered" ></span>1!==e&amp;&amp;n.length&gt;0&amp;&amp;(n=n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e*t}</span>)));<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke",s.strokeColor);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-opacity",s.strokeAlpha);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-miterlimit",pf(s.miterLimit));<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-linecap",s.lineCap);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-linejoin",s.lineJoin);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-width",pf(e*s.lineWidth)+"px");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-dasharray",n.map(pf).join(" "));<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-dashoffset",pf(e*s.dashPhase)+"px")}<span class="fstat-no" title="function not covered" ></span>eo</span>Fill(){<span class="cstat-no" title="statement not covered" >this.current.element?.setAttributeNS(null,"fill-rule","evenodd");<span class="cstat-no" title="statement not covered" >t</span>his.fill()}<span class="fstat-no" title="function not covered" ></span>fi</span>llStroke(){<span class="cstat-no" title="statement not covered" >this.stroke();<span class="cstat-no" title="statement not covered" >t</span>his.fill()}<span class="fstat-no" title="function not covered" ></span>eo</span>FillStroke(){<span class="cstat-no" title="statement not covered" >this.current.element?.setAttributeNS(null,"fill-rule","evenodd");<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.stroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseFillStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseEOFillStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.eoFillStroke()}<span class="fstat-no" title="function not covered" ></span>pa</span>intSolidColorImageMask(){const t=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>t.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"y","0");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"width","1px");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"height","1px");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"fill",this.current.fillColor);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(t)}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageXObject(t){const e=<span class="cstat-no" title="statement not covered" >this.getObject(t);<span class="cstat-no" title="statement not covered" ></span>e?this.paintInlineImageXObject(e):(0,i.warn)(`Dependent image with object ID ${t} is not ready yet`)}<span class="fstat-no" title="function not covered" ></span>pa</span>intInlineImageXObject(t,e){const s=<span class="cstat-no" title="statement not covered" >t.width,</span>n=<span class="cstat-no" title="statement not covered" >t.height,</span>i=<span class="cstat-no" title="statement not covered" >d(t,this.forceDataSchema,!!e),</span>a=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>a.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >a</span>.setAttributeNS(null,"y","0");<span class="cstat-no" title="statement not covered" >a</span>.setAttributeNS(null,"width",pf(s));<span class="cstat-no" title="statement not covered" >a</span>.setAttributeNS(null,"height",pf(n));<span class="cstat-no" title="statement not covered" >t</span>his.current.element=a;<span class="cstat-no" title="statement not covered" >t</span>his.clip("nonzero");c</span>onst r=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:image");<span class="cstat-no" title="statement not covered" ></span>r.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",i);<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"y",pf(-n));<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"width",pf(s)+"px");<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"height",pf(n)+"px");<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"transform",`scale(${pf(1/s)} ${pf(-1/n)})`);<span class="cstat-no" title="statement not covered" >e</span>?e.append(r):this._ensureTransformGroup().append(r)}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObject(t){const e=<span class="cstat-no" title="statement not covered" >this.getObject(t.data,t);<span class="cstat-no" title="statement not covered" ></span>if(e.bitmap){<span class="cstat-no" title="statement not covered" >(0,i.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >this.current,</span>n=<span class="cstat-no" title="statement not covered" >e.width,</span>a=<span class="cstat-no" title="statement not covered" >e.height,</span>r=<span class="cstat-no" title="statement not covered" >s.fillColor;<span class="cstat-no" title="statement not covered" ></span>s.maskId="mask"+p++;c</span>onst o=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:mask");<span class="cstat-no" title="statement not covered" ></span>o.setAttributeNS(null,"id",s.maskId);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>l.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"y","0");<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"width",pf(n));<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"height",pf(a));<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"fill",r);<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"mask",`url(#${s.maskId})`);<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(o);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(l);<span class="cstat-no" title="statement not covered" >t</span>his.paintInlineImageXObject(e,o)}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectBegin(t,e){<span class="cstat-no" title="statement not covered" >Array.isArray(t)&amp;&amp;6===t.length&amp;&amp;this.transform(t[0],t[1],t[2],t[3],t[4],t[5]);<span class="cstat-no" title="statement not covered" >i</span>f(e){const t=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>s=<span class="cstat-no" title="statement not covered" >e[3]-e[1],</span>n=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>n.setAttributeNS(null,"x",e[0]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"y",e[1]);<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"width",pf(t));<span class="cstat-no" title="statement not covered" >n</span>.setAttributeNS(null,"height",pf(s));<span class="cstat-no" title="statement not covered" >t</span>his.current.element=n;<span class="cstat-no" title="statement not covered" >t</span>his.clip("nonzero");<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectEnd(){}<span class="fstat-no" title="function not covered" >_i</span>nitialize(t){const e=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(t.width,t.height),</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:defs");<span class="cstat-no" title="statement not covered" ></span>e.append(s);<span class="cstat-no" title="statement not covered" >t</span>his.defs=s;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" ></span>n.setAttributeNS(null,"transform",pm(t.transform));<span class="cstat-no" title="statement not covered" >e</span>.append(n);<span class="cstat-no" title="statement not covered" >t</span>his.svg=n;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_e</span>nsureClipGroup(){<span class="cstat-no" title="statement not covered" >if(!this.current.clipGroup){const t=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" ></span>t.setAttributeNS(null,"clip-path",this.current.activeClipUrl);<span class="cstat-no" title="statement not covered" >t</span>his.svg.append(t);<span class="cstat-no" title="statement not covered" >t</span>his.current.clipGroup=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.current.clipGroup}<span class="fstat-no" title="function not covered" ></span>_e</span>nsureTransformGroup(){<span class="cstat-no" title="statement not covered" >if(!this.tgrp){<span class="cstat-no" title="statement not covered" >this.tgrp=this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" >t</span>his.tgrp.setAttributeNS(null,"transform",pm(this.transformMatrix));<span class="cstat-no" title="statement not covered" >t</span>his.current.activeClipUrl?this._ensureClipGroup().append(this.tgrp):this.svg.append(this.tgrp)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.tgrp}</span>}}</span>],</span>__webpack_module_cache__=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >__w_pdfjs_require__(</span>t){var e=<span class="cstat-no" title="statement not covered" >__webpack_module_cache__[t];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==e)<span class="cstat-no" title="statement not covered" >return e.exports;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >__webpack_module_cache__[t]={exports:{}};<span class="cstat-no" title="statement not covered" ></span>__webpack_modules__[t](s,s.exports,__w_pdfjs_require__);<span class="cstat-no" title="statement not covered" >r</span>eturn s.exports}</span>var __webpack_exports__=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t=<span class="cstat-no" title="statement not covered" >__webpack_exports__;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AbortException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AbortException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.AnnotationEditorLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorParamsType",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AnnotationEditorParamsType}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorType",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AnnotationEditorType}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorUIManager",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r.AnnotationEditorUIManager}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.AnnotationLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationMode",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AnnotationMode}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"CMapCompressionType",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.CMapCompressionType}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"FeatureTest",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.FeatureTest}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"GlobalWorkerOptions",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l.GlobalWorkerOptions}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"ImageKind",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.ImageKind}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"InvalidPDFException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.InvalidPDFException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"MissingPDFException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.MissingPDFException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"OPS",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.OPS}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PDFDataRangeTransport",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.PDFDataRangeTransport}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PDFDateString",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.PDFDateString}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PDFWorker",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.PDFWorker}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PasswordResponses",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.PasswordResponses}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PermissionFlag",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.PermissionFlag}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PixelsPerInch",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.PixelsPerInch}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PromiseCapability",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.PromiseCapability}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"RenderingCancelledException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.RenderingCancelledException}</span>});<span class="cstat-no" title="statement not covered" >t</span>.SVGGraphics=void 0;<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"UnexpectedResponseException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.UnexpectedResponseException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"Util",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.Util}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"VerbosityLevel",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.VerbosityLevel}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"XfaLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c.XfaLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"build",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.build}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"createValidAbsoluteUrl",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.createValidAbsoluteUrl}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getDocument",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.getDocument}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getFilenameFromUrl",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.getFilenameFromUrl}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getPdfFilenameFromUrl",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.getPdfFilenameFromUrl}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getXfaPageViewport",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.getXfaPageViewport}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"isDataScheme",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.isDataScheme}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"isPdfFile",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.isPdfFile}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"loadScript",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.loadScript}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"normalizeUnicode",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.normalizeUnicode}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"renderTextLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.renderTextLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"setLayerDimensions",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.setLayerDimensions}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"shadow",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.shadow}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"updateTextLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.updateTextLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"version",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.version}</span>});v</span>ar e=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(1),</span>s=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(2),</span>n=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(6),</span>i=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(26),</span>a=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(27),</span>r=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(5),</span>o=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(29),</span>l=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(14),</span>c=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(31);</span>const h=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(34).SVGGraphics;<span class="cstat-no" title="statement not covered" ></span>t.SVGGraphics=h}</span>)();<span class="cstat-no" title="statement not covered" >r</span>eturn __webpack_exports__}</span>)())</span>);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-08-05T19:46:07.360Z
            </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    